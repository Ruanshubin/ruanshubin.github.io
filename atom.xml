<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>阮树斌 | 技术改变生活</title>
  
  <subtitle>交通 | 数据 | 算法 &lt;br&gt; Java | Python | Scala | Matlab | GIS</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ruanshubin.top/"/>
  <updated>2019-09-16T01:59:59.107Z</updated>
  <id>http://ruanshubin.top/</id>
  
  <author>
    <name>Ruan Shubin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Flink的分布式缓存</title>
    <link href="http://ruanshubin.top/2019/09/16/Flink%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/"/>
    <id>http://ruanshubin.top/2019/09/16/Flink的分布式缓存/</id>
    <published>2019-09-16T01:55:00.000Z</published>
    <updated>2019-09-16T01:59:59.107Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h2><p>Flink提供了一个分布式缓存，类似于hadoop，可以使用户在并行函数中很方便的读取本地文件，并把它放在taskmanager节点中，防止task重复拉取。</p><p>此缓存的工作机制如下：程序注册一个文件或者目录(本地或者远程文件系统，例如hdfs或者s3)，通过ExecutionEnvironment注册缓存文件并为它起一个名称。</p><p>当程序执行，Flink自动将文件或者目录复制到所有taskmanager节点的本地文件系统，仅会执行一次。用户可以通过这个指定的名称查找文件或者目录，然后从taskmanager节点的本地文件系统访问它。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>在ExecutionEnvironment中注册一个文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 获取运行环境</span><br><span class="line">ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">// 注册一个文件 本地文件或者分布式文件</span><br><span class="line">env.registerCachedFile(&quot;flink-common\\src\\main\\resources\\cache.txt&quot;, &quot;cache&quot;);</span><br></pre></td></tr></table></figure><p>在用户函数中访问缓存文件或者目录(这里是一个map函数)。这个函数必须继承RichFunction,因为它需要使用RuntimeContext读取数据:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">DataSet&lt;String&gt; result = data.map(new RichMapFunction&lt;String, String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">String cacheString;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void open(Configuration parameters) throws Exception &#123;</span><br><span class="line">super.open(parameters);</span><br><span class="line">File cache = getRuntimeContext().getDistributedCache().getFile(&quot;cache&quot;);</span><br><span class="line">cacheString = FileUtils.readFileUtf8(cache);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public String map(String value) throws Exception &#123;</span><br><span class="line">return cacheString + &quot;: &quot; + value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>完整代码见：<a href="https://github.com/Ruanshubin/awesome-flink/tree/master/flink-common/src/main/java/com/ruanshubin/bigdata/flink/common/cache" target="_blank" rel="noopener">https://github.com/Ruanshubin/awesome-flink/tree/master/flink-common/src/main/java/com/ruanshubin/bigdata/flink/common/cache</a></p><h2 id="开源推荐"><a href="#开源推荐" class="headerlink" title="开源推荐"></a>开源推荐</h2><p>在学习Flink的过程中，本人将涉及到的测试案例、源码解读、开发技巧等系统整理了一下，并开源到Github上，地址为：</p><p><a href="https://github.com/Ruanshubin/awesome-flink" target="_blank" rel="noopener">https://github.com/Ruanshubin/awesome-flink</a></p><p><strong>欢迎大家Star支持！</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;分布式缓存&quot;&gt;&lt;a href=&quot;#分布式缓存&quot; class=&quot;headerlink&quot; title=&quot;分布式缓存&quot;&gt;&lt;/a&gt;分布式缓存&lt;/h2&gt;&lt;p&gt;Flink提供了一个分布式缓存，类似于hadoop，可以使用户在并行函数中很方便的读取本地文件，并把它放在taskm
      
    
    </summary>
    
      <category term="Flink" scheme="http://ruanshubin.top/categories/Flink/"/>
    
    
      <category term="大数据" scheme="http://ruanshubin.top/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Flink" scheme="http://ruanshubin.top/tags/Flink/"/>
    
  </entry>
  
  <entry>
    <title>Flink的Window源码剖析</title>
    <link href="http://ruanshubin.top/2019/08/19/Flink%E7%9A%84Window%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    <id>http://ruanshubin.top/2019/08/19/Flink的Window源码剖析/</id>
    <published>2019-08-19T10:52:00.000Z</published>
    <updated>2019-09-16T05:45:59.279Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h2><p><img src="/2019/08/19/Flink的Window源码剖析/1.jpg" alt=""></p><p>可以看到，GlobalWindow和TimeWindow均继承自抽象类Window，其源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Window &#123;</span><br><span class="line">public abstract long maxTimestamp();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，Window抽象类仅有一个maxTimestamp()方法用于获取仍属于该窗口的最大时间戳。</p><h3 id="TimeWindow"><a href="#TimeWindow" class="headerlink" title="TimeWindow"></a>TimeWindow</h3><p>首先看TimeWindow的数据结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">public class TimeWindow extends Window &#123;</span><br><span class="line"></span><br><span class="line">private final long start;</span><br><span class="line">private final long end;</span><br><span class="line"></span><br><span class="line">public TimeWindow(long start, long end) &#123;</span><br><span class="line">this.start = start;</span><br><span class="line">this.end = end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public long getStart() &#123;</span><br><span class="line">return start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public long getEnd() &#123;</span><br><span class="line">return end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public long maxTimestamp() &#123;</span><br><span class="line">return end - 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public boolean equals(Object o) &#123;</span><br><span class="line">if (this == o) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">if (o == null || getClass() != o.getClass()) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TimeWindow window = (TimeWindow) o;</span><br><span class="line"></span><br><span class="line">return end == window.end &amp;&amp; start == window.start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int hashCode() &#123;</span><br><span class="line">return MathUtils.longToIntWithBitMixing(start + end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;TimeWindow&#123;&quot; +</span><br><span class="line">&quot;start=&quot; + start +</span><br><span class="line">&quot;, end=&quot; + end +</span><br><span class="line">&apos;&#125;&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean intersects(TimeWindow other) &#123;</span><br><span class="line">return this.start &lt;= other.end &amp;&amp; this.end &gt;= other.start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public TimeWindow cover(TimeWindow other) &#123;</span><br><span class="line">return new TimeWindow(Math.min(start, other.start), Math.max(end, other.end));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">public static void mergeWindows(Collection&lt;TimeWindow&gt; windows, MergingWindowAssigner.MergeCallback&lt;TimeWindow&gt; c) &#123;</span><br><span class="line"></span><br><span class="line">List&lt;TimeWindow&gt; sortedWindows = new ArrayList&lt;&gt;(windows);</span><br><span class="line"></span><br><span class="line">Collections.sort(sortedWindows, new Comparator&lt;TimeWindow&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">public int compare(TimeWindow o1, TimeWindow o2) &#123;</span><br><span class="line">return Long.compare(o1.getStart(), o2.getStart());</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">List&lt;Tuple2&lt;TimeWindow, Set&lt;TimeWindow&gt;&gt;&gt; merged = new ArrayList&lt;&gt;();</span><br><span class="line">Tuple2&lt;TimeWindow, Set&lt;TimeWindow&gt;&gt; currentMerge = null;</span><br><span class="line"></span><br><span class="line">for (TimeWindow candidate: sortedWindows) &#123;</span><br><span class="line">if (currentMerge == null) &#123;</span><br><span class="line">currentMerge = new Tuple2&lt;&gt;();</span><br><span class="line">currentMerge.f0 = candidate;</span><br><span class="line">currentMerge.f1 = new HashSet&lt;&gt;();</span><br><span class="line">currentMerge.f1.add(candidate);</span><br><span class="line">&#125; else if (currentMerge.f0.intersects(candidate)) &#123;</span><br><span class="line">currentMerge.f0 = currentMerge.f0.cover(candidate);</span><br><span class="line">currentMerge.f1.add(candidate);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">merged.add(currentMerge);</span><br><span class="line">currentMerge = new Tuple2&lt;&gt;();</span><br><span class="line">currentMerge.f0 = candidate;</span><br><span class="line">currentMerge.f1 = new HashSet&lt;&gt;();</span><br><span class="line">currentMerge.f1.add(candidate);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (currentMerge != null) &#123;</span><br><span class="line">merged.add(currentMerge);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (Tuple2&lt;TimeWindow, Set&lt;TimeWindow&gt;&gt; m: merged) &#123;</span><br><span class="line">if (m.f1.size() &gt; 1) &#123;</span><br><span class="line">c.merge(m.f1, m.f0);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static long getWindowStartWithOffset(long timestamp, long offset, long windowSize) &#123;</span><br><span class="line">return timestamp - (timestamp - offset + windowSize) % windowSize;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>该窗口主要用于实现时间驱动的相关操作</strong>。</p><p>可以看到。TimeWindow由start和end2个时间戳组成，最大时间戳为end-1，同时，TimeWindow提供了getWindowStartWithOffset静态方法，用于获取时间戳所属时间窗的起点，其中的offset为偏移量。例如，没有偏移量的话，小时滚动窗口将按时间纪元来对齐，也就是1:00:00—1:59:59,2:00:00—2:59:59等，如果你指定了15分钟的偏移，你将得到1:15:00—2:14:59,2:15:00—3:14:59等。时间偏移主要用于调准非0时区的窗口，例如:在中国你需要指定8小时的时间偏移。</p><p>intersects方法用于判断2个时间窗是否有交集，cover方法用于求2个时间窗的合集，mergeWindows用于将时间窗集合进行合并，该方法是实现Session Window的关键。</p><p>对于session window来说，我们需要窗口变得更灵活。基本的思想是这样的：SessionWindows assigner 会为每个进入的元素分配一个窗口，该窗口以元素的时间戳作为起始点，时间戳加会话超时时间为结束点，也就是该窗口为[timestamp, timestamp+sessionGap)。比如我们现在到了两个元素，它们被分配到两个独立的窗口中，两个窗口目前不相交，如图：</p><p><img src="/2019/08/19/Flink的Window源码剖析/2.jpg" alt=""></p><p>当第三个元素进入时，分配到的窗口与现有的两个窗口发生了叠加，情况变成了这样：</p><p><img src="/2019/08/19/Flink的Window源码剖析/3.jpg" alt=""></p><p>由于我们支持了窗口的合并，WindowAssigner可以合并这些窗口。它会遍历现有的窗口，并告诉系统哪些窗口需要合并成新的窗口。Flink 会将这些窗口进行合并，合并的主要内容有两部分：</p><ul><li>需要合并的窗口的底层状态的合并（也就是窗口中缓存的数据，或者对于聚合窗口来说是一个聚合值）；</li><li>需要合并的窗口的Trigger的合并（比如对于EventTime来说，会删除旧窗口注册的定时器，并注册新窗口的定时器）。</li></ul><p>总之，结果是三个元素现在在同一个窗口中：</p><p><img src="/2019/08/19/Flink的Window源码剖析/4.jpg" alt=""></p><p>需要注意的是，对于每一个新进入的元素，都会分配一个属于该元素的窗口，都会检查并合并现有的窗口。在触发窗口计算之前，每一次都会检查该窗口是否可以和其他窗口合并，直到trigger触发后，会将该窗口从窗口列表中移除。对于 event time 来说，窗口的触发是要等到大于窗口结束时间的 watermark 到达，当watermark没有到，窗口会一直缓存着。所以基于这种机制，可以做到对乱序消息的支持。</p><p>这里有一个优化点可以做，因为每一个新进入的元素都会创建属于该元素的窗口，然后合并。如果新元素连续不断地进来，并且新元素的窗口一直都是可以和之前的窗口重叠合并的，那么其实这里多了很多不必要的创建窗口、合并窗口的操作，我们可以直接将新元素放到那个已存在的窗口，然后扩展该窗口的大小，看起来就像和新元素的窗口合并了一样。</p><h3 id="GlobalWindow"><a href="#GlobalWindow" class="headerlink" title="GlobalWindow"></a>GlobalWindow</h3><p>接着看GlobalWindow：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class GlobalWindow extends Window &#123;</span><br><span class="line"></span><br><span class="line">private static final GlobalWindow INSTANCE = new GlobalWindow();</span><br><span class="line"></span><br><span class="line">private GlobalWindow() &#123; &#125;</span><br><span class="line"></span><br><span class="line">public static GlobalWindow get() &#123;</span><br><span class="line">return INSTANCE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public long maxTimestamp() &#123;</span><br><span class="line">return Long.MAX_VALUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public boolean equals(Object o) &#123;</span><br><span class="line">return this == o || !(o == null || getClass() != o.getClass());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int hashCode() &#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;GlobalWindow&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 序列化相关操作</span><br><span class="line"> */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GlobalWindow提供了get()静态方法用于获取GlobalWindow实例，maxTimestamp()统一返回Long的最大值，而hashCode统一返回0。</p><p><strong>该窗口主要用于实现数据驱动的相关操作</strong>。</p><h2 id="WindowAssigner"><a href="#WindowAssigner" class="headerlink" title="WindowAssigner"></a>WindowAssigner</h2><p>顾名思义，WindowAssigner用来决定某个元素被分配到哪个/哪些窗口中去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public abstract class WindowAssigner&lt;T, W extends Window&gt; implements Serializable &#123;</span><br><span class="line">private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line">public abstract Collection&lt;W&gt; assignWindows(T element, long timestamp, WindowAssignerContext context);</span><br><span class="line"></span><br><span class="line">public abstract Trigger&lt;T, W&gt; getDefaultTrigger(StreamExecutionEnvironment env);</span><br><span class="line"></span><br><span class="line">public abstract TypeSerializer&lt;W&gt; getWindowSerializer(ExecutionConfig executionConfig);</span><br><span class="line"></span><br><span class="line">public abstract boolean isEventTime();</span><br><span class="line"></span><br><span class="line">public abstract static class WindowAssignerContext &#123;</span><br><span class="line"></span><br><span class="line">public abstract long getCurrentProcessingTime();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先看assignWindows方法，其输入element为待分配的元素，timestamp为element持有的时间戳，context为该分配器的上下文容器，返回值为element所属的窗口集合，也就说，同一条数据元素，可能会被分配到多个窗口中去。但并不是将该数据复制到多个窗口中去，Window本身只是一个ID标识符，其内部可能存储了一些元数据，如TimeWindow中有开始和结束时间，但是并不会存储窗口中的元素。窗口中的元素实际存储在 Key/Value State 中，key为Window，value为元素集合（或聚合值）。为了保证窗口的容错性，该实现依赖了 Flink 的 State 机制（参见 state 文档）。</p><p>接着看其他方法，getDefaultTrigger用于返回该窗口默认的触发器，getWindowSerializer用于返回窗口的序列化器，isEventTime用于判断是否基于event time来进行元素的分配。</p><p>最后看一下WindowAssignerContext这个上下文容器，其是一个内部静态抽象类，提供了getCurrentProcessingTime方法用于获取当前的processing time。</p><p><img src="/2019/08/19/Flink的Window源码剖析/6.jpg" alt=""></p><p><img src="/2019/08/19/Flink的Window源码剖析/5.jpg" alt=""></p><p>看一下WindowAssigner的实现类，GlobalWindows主要用于实现CountWindow，MergingWindowAssigner主要用于实现SessionWindow，剩下的分别基于processing time和event time实现了翻滚窗口和滑动窗口。</p><p>先捡软柿子捏，首先看较为简单的GlobalWindows：</p><h3 id="GlobalWindows"><a href="#GlobalWindows" class="headerlink" title="GlobalWindows"></a>GlobalWindows</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">public class GlobalWindows extends WindowAssigner&lt;Object, GlobalWindow&gt; &#123;</span><br><span class="line">private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line">private GlobalWindows() &#123;&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Collection&lt;GlobalWindow&gt; assignWindows(Object element, long timestamp, WindowAssignerContext context) &#123;</span><br><span class="line">return Collections.singletonList(GlobalWindow.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Trigger&lt;Object, GlobalWindow&gt; getDefaultTrigger(StreamExecutionEnvironment env) &#123;</span><br><span class="line">return new NeverTrigger();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;GlobalWindows()&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static GlobalWindows create() &#123;</span><br><span class="line">return new GlobalWindows();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Internal</span><br><span class="line">public static class NeverTrigger extends Trigger&lt;Object, GlobalWindow&gt; &#123;</span><br><span class="line">private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public TriggerResult onElement(Object element, long timestamp, GlobalWindow window, TriggerContext ctx) &#123;</span><br><span class="line">return TriggerResult.CONTINUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public TriggerResult onEventTime(long time, GlobalWindow window, TriggerContext ctx) &#123;</span><br><span class="line">return TriggerResult.CONTINUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public TriggerResult onProcessingTime(long time, GlobalWindow window, TriggerContext ctx) &#123;</span><br><span class="line">return TriggerResult.CONTINUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void clear(GlobalWindow window, TriggerContext ctx) throws Exception &#123;&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onMerge(GlobalWindow window, OnMergeContext ctx) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public TypeSerializer&lt;GlobalWindow&gt; getWindowSerializer(ExecutionConfig executionConfig) &#123;</span><br><span class="line">return new GlobalWindow.Serializer();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public boolean isEventTime() &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GlobalWindows提供了create静态方法用于返回GlobalWindows实例，assignWindows方法会将上游的元素全都分配到一个单例GlobalWindow中，其默认的Trigger为NeverTrigger，即永不触发fire计算。</p><h3 id="TumblingProcessingTimeWindows和TumblingEventTimeWindows"><a href="#TumblingProcessingTimeWindows和TumblingEventTimeWindows" class="headerlink" title="TumblingProcessingTimeWindows和TumblingEventTimeWindows"></a>TumblingProcessingTimeWindows和TumblingEventTimeWindows</h3><p>TumblingProcessingTimeWindows和TumblingEventTimeWindows的assignWindows方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// TumblingProcessingTimeWindows</span><br><span class="line">@Override</span><br><span class="line">public Collection&lt;TimeWindow&gt; assignWindows(Object element, long timestamp, WindowAssignerContext context) &#123;</span><br><span class="line">// 获取当前的processing time</span><br><span class="line">final long now = context.getCurrentProcessingTime();</span><br><span class="line">// 计算当前processing time所属窗口的start</span><br><span class="line">long start = TimeWindow.getWindowStartWithOffset(now, offset, size);</span><br><span class="line">return Collections.singletonList(new TimeWindow(start, start + size));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// TumblingEventTimeWindows</span><br><span class="line">@Override</span><br><span class="line">public Collection&lt;TimeWindow&gt; assignWindows(Object element, long timestamp, WindowAssignerContext context) &#123;</span><br><span class="line">if (timestamp &gt; Long.MIN_VALUE) &#123;</span><br><span class="line">// Long.MIN_VALUE is currently assigned when no timestamp is present</span><br><span class="line">// 以元素自带的时间戳(event time)计算窗口的start</span><br><span class="line">long start = TimeWindow.getWindowStartWithOffset(timestamp, offset, size);</span><br><span class="line">return Collections.singletonList(new TimeWindow(start, start + size));</span><br><span class="line">&#125; else &#123;</span><br><span class="line">throw new RuntimeException(&quot;Record has Long.MIN_VALUE timestamp (= no timestamp marker). &quot; +</span><br><span class="line">&quot;Is the time characteristic set to &apos;ProcessingTime&apos;, or did you forget to call &quot; +</span><br><span class="line">&quot;&apos;DataStream.assignTimestampsAndWatermarks(...)&apos;?&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，其逻辑是相似的，区别就在于窗口的start时间，一个使用的是WindowAssignerContext获取的当前时间戳，另外一个则是利用元素的EventTime，通过TimeWindow的getWindowStartWithOffset方法计算得到的。</p><h3 id="SlidingProcessingTimeWindows和SlidingEventTimeWindows"><a href="#SlidingProcessingTimeWindows和SlidingEventTimeWindows" class="headerlink" title="SlidingProcessingTimeWindows和SlidingEventTimeWindows"></a>SlidingProcessingTimeWindows和SlidingEventTimeWindows</h3><p>接着看滑动窗口，以SlidingProcessingTimeWindows为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Collection&lt;TimeWindow&gt; assignWindows(Object element, long timestamp, WindowAssignerContext context) &#123;</span><br><span class="line">// 获取当前系统的Processing Time</span><br><span class="line">timestamp = context.getCurrentProcessingTime();</span><br><span class="line">// 初始化窗口集合，窗口个数为size/slide</span><br><span class="line">List&lt;TimeWindow&gt; windows = new ArrayList&lt;&gt;((int) (size / slide));</span><br><span class="line">long lastStart = TimeWindow.getWindowStartWithOffset(timestamp, offset, slide);</span><br><span class="line">// 计算窗口集合</span><br><span class="line">for (long start = lastStart;</span><br><span class="line">start &gt; timestamp - size;</span><br><span class="line">start -= slide) &#123;</span><br><span class="line">windows.add(new TimeWindow(start, start + size));</span><br><span class="line">&#125;</span><br><span class="line">return windows;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码可能不够直观，我们以一个简单例子来解释上述方法。</p><p>假设基础数据如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">timestamp=73;</span><br><span class="line">offset=6;</span><br><span class="line">size=60;</span><br><span class="line">slide=10;</span><br></pre></td></tr></table></figure><p>计算过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">集合的大小为：</span><br><span class="line">60/10=6</span><br><span class="line">上一次起始起始时间:</span><br><span class="line">lastStart=timestamp-(timestamp-offset+slide)%slide=73-(73-6+10)%10=73-7=66</span><br><span class="line">则for(start=66; start&gt;73-60; start=start-10)&#123;</span><br><span class="line">windows.add(new TimeWindow(start, start + size));</span><br><span class="line">&#125;</span><br><span class="line">windows集合为：</span><br><span class="line">[66, 126]</span><br><span class="line">[56, 116]</span><br><span class="line">[46, 106]</span><br><span class="line">[36, 96]</span><br><span class="line">[26, 86]</span><br><span class="line">[16, 76]</span><br></pre></td></tr></table></figure><p>SlidingEventTimeWindows与SlidingProcessingTimeWindows的assignWindows基本一致，只是额外添加了一层对timestamp的判断，只有当timestamp &gt; Long.MIN_VALUE才会进入到窗口分配，否则抛异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Collection&lt;TimeWindow&gt; assignWindows(Object element, long timestamp, WindowAssignerContext context) &#123;</span><br><span class="line">if (timestamp &gt; Long.MIN_VALUE) &#123;</span><br><span class="line">List&lt;TimeWindow&gt; windows = new ArrayList&lt;&gt;((int) (size / slide));</span><br><span class="line">long lastStart = TimeWindow.getWindowStartWithOffset(timestamp, offset, slide);</span><br><span class="line">for (long start = lastStart;</span><br><span class="line">start &gt; timestamp - size;</span><br><span class="line">start -= slide) &#123;</span><br><span class="line">windows.add(new TimeWindow(start, start + size));</span><br><span class="line">&#125;</span><br><span class="line">return windows;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">throw new RuntimeException(&quot;Record has Long.MIN_VALUE timestamp (= no timestamp marker). &quot; +</span><br><span class="line">&quot;Is the time characteristic set to &apos;ProcessingTime&apos;, or did you forget to call &quot; +</span><br><span class="line">&quot;&apos;DataStream.assignTimestampsAndWatermarks(...)&apos;?&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MergingWindowAssigner"><a href="#MergingWindowAssigner" class="headerlink" title="MergingWindowAssigner"></a>MergingWindowAssigner</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public abstract class MergingWindowAssigner&lt;T, W extends Window&gt; extends WindowAssigner&lt;T, W&gt; &#123;</span><br><span class="line">private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line">public abstract void mergeWindows(Collection&lt;W&gt; windows, MergeCallback&lt;W&gt; callback);</span><br><span class="line"></span><br><span class="line">public interface MergeCallback&lt;W&gt; &#123;</span><br><span class="line"></span><br><span class="line">void merge(Collection&lt;W&gt; toBeMerged, W mergeResult);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MergingWindowAssigner主要提供了MergeCallback抽象接口，然后将该接口传递给TimeWindow的mergeWindows方法来进行窗口的合并(具体可看TimeWindow)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void mergeWindows(Collection&lt;TimeWindow&gt; windows, MergingWindowAssigner.MergeCallback&lt;TimeWindow&gt; c) &#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Trigger"><a href="#Trigger" class="headerlink" title="Trigger"></a>Trigger</h2><p>触发器。决定了一个窗口何时能够被计算或清除，每个窗口都会拥有一个自己的Trigger。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Trigger&lt;T, W extends Window&gt; implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">private static final long serialVersionUID = -4104633972991191369L;</span><br><span class="line"></span><br><span class="line">public abstract TriggerResult onElement(T element, long timestamp, W window, TriggerContext ctx) throws Exception;</span><br><span class="line"></span><br><span class="line">public abstract TriggerResult onProcessingTime(long time, W window, TriggerContext ctx) throws Exception;</span><br><span class="line"></span><br><span class="line">public abstract TriggerResult onEventTime(long time, W window, TriggerContext ctx) throws Exception;</span><br><span class="line"></span><br><span class="line">public boolean canMerge() &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void onMerge(W window, OnMergeContext ctx) throws Exception &#123;</span><br><span class="line">throw new UnsupportedOperationException(&quot;This trigger does not support merging.&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public abstract void clear(W window, TriggerContext ctx) throws Exception;</span><br><span class="line"></span><br><span class="line">public interface TriggerContext &#123;</span><br><span class="line">long getCurrentProcessingTime();</span><br><span class="line">MetricGroup getMetricGroup();</span><br><span class="line">long getCurrentWatermark();</span><br><span class="line">void registerProcessingTimeTimer(long time);</span><br><span class="line">void registerEventTimeTimer(long time);</span><br><span class="line">void deleteProcessingTimeTimer(long time);</span><br><span class="line">void deleteEventTimeTimer(long time);</span><br><span class="line">&lt;S extends State&gt; S getPartitionedState(StateDescriptor&lt;S, ?&gt; stateDescriptor);</span><br><span class="line">@Deprecated</span><br><span class="line">&lt;S extends Serializable&gt; ValueState&lt;S&gt; getKeyValueState(String name, Class&lt;S&gt; stateType, S defaultState);</span><br><span class="line">@Deprecated</span><br><span class="line">&lt;S extends Serializable&gt; ValueState&lt;S&gt; getKeyValueState(String name, TypeInformation&lt;S&gt; stateType, S defaultState);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface OnMergeContext extends TriggerContext &#123;</span><br><span class="line">&lt;S extends MergingState&lt;?, ?&gt;&gt; void mergePartitionedState(StateDescriptor&lt;S, ?&gt; stateDescriptor);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当元素加入窗口时，onElement方法被调用，主要完成定时器的注册，当基于processing time的timer被触发后，onProcessingTime方法被调用，同样的，当基于event time的timer被触发后，onEventTime方法被调用。</p><p>其实现类有以下几种：</p><p><img src="/2019/08/19/Flink的Window源码剖析/7.jpg" alt=""></p><p>常用的主要有CountTrigger、EventTimeTrigger、ProcessingTimeTrigger，下面分别看看这几个触发器。</p><h3 id="CountTrigger"><a href="#CountTrigger" class="headerlink" title="CountTrigger"></a>CountTrigger</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">public class CountTrigger&lt;W extends Window&gt; extends Trigger&lt;Object, W&gt; &#123;</span><br><span class="line">private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line">// 当窗口中的元素&gt;=maxCount时，窗口操作将被触发</span><br><span class="line">private final long maxCount;</span><br><span class="line"></span><br><span class="line">// 声明count的ReducingStateDescriptor，相当于一个分布式环境下的共享变量，主要记录当前窗口中元素的数量</span><br><span class="line">private final ReducingStateDescriptor&lt;Long&gt; stateDesc =</span><br><span class="line">new ReducingStateDescriptor&lt;&gt;(&quot;count&quot;, new Sum(), LongSerializer.INSTANCE);</span><br><span class="line"></span><br><span class="line">private CountTrigger(long maxCount) &#123;</span><br><span class="line">this.maxCount = maxCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public TriggerResult onElement(Object element, long timestamp, W window, TriggerContext ctx) throws Exception &#123;</span><br><span class="line">// 获取窗口中的元素的数量</span><br><span class="line">ReducingState&lt;Long&gt; count = ctx.getPartitionedState(stateDesc);</span><br><span class="line">// 执行+1操作</span><br><span class="line">count.add(1L);</span><br><span class="line">// 若count值&gt;=maxCount，则窗口执行fire操作，否则continue</span><br><span class="line">if (count.get() &gt;= maxCount) &#123;</span><br><span class="line">count.clear();</span><br><span class="line">return TriggerResult.FIRE;</span><br><span class="line">&#125;</span><br><span class="line">return TriggerResult.CONTINUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public TriggerResult onEventTime(long time, W window, TriggerContext ctx) &#123;</span><br><span class="line">return TriggerResult.CONTINUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public TriggerResult onProcessingTime(long time, W window, TriggerContext ctx) throws Exception &#123;</span><br><span class="line">return TriggerResult.CONTINUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void clear(W window, TriggerContext ctx) throws Exception &#123;</span><br><span class="line">// 清空共享变量</span><br><span class="line">ctx.getPartitionedState(stateDesc).clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public boolean canMerge() &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onMerge(W window, OnMergeContext ctx) throws Exception &#123;</span><br><span class="line">// 当发生窗口merge时，合并共享变量</span><br><span class="line">ctx.mergePartitionedState(stateDesc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;CountTrigger(&quot; +  maxCount + &quot;)&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 提供of(long maxCount)方法返回CountTrigger的实例</span><br><span class="line">public static &lt;W extends Window&gt; CountTrigger&lt;W&gt; of(long maxCount) &#123;</span><br><span class="line">return new CountTrigger&lt;&gt;(maxCount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static class Sum implements ReduceFunction&lt;Long&gt; &#123;</span><br><span class="line">private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Long reduce(Long value1, Long value2) throws Exception &#123;</span><br><span class="line">return value1 + value2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ProcessingTimeTrigger"><a href="#ProcessingTimeTrigger" class="headerlink" title="ProcessingTimeTrigger"></a>ProcessingTimeTrigger</h3><p>当processing time超过窗口的end值时，窗口将执行fire操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public TriggerResult onElement(Object element, long timestamp, TimeWindow window, TriggerContext ctx) &#123;</span><br><span class="line">// 注册processing time的时钟，相当于定了个闹钟，闹钟时间为window.maxTimestamp()</span><br><span class="line">ctx.registerProcessingTimeTimer(window.maxTimestamp());</span><br><span class="line">return TriggerResult.CONTINUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public TriggerResult onEventTime(long time, TimeWindow window, TriggerContext ctx) throws Exception &#123;</span><br><span class="line">// 不做处理</span><br><span class="line">return TriggerResult.CONTINUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public TriggerResult onProcessingTime(long time, TimeWindow window, TriggerContext ctx) &#123;</span><br><span class="line">// 当闹钟定的时间到了，执行fire操作</span><br><span class="line">return TriggerResult.FIRE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void clear(TimeWindow window, TriggerContext ctx) throws Exception &#123;</span><br><span class="line">// 清除时钟</span><br><span class="line">ctx.deleteProcessingTimeTimer(window.maxTimestamp());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，onElement方法主要用于注册时钟，时钟时间到达后(onProcessingTime)，会触发窗口的fire操作。</p><h3 id="EventTimeTrigger"><a href="#EventTimeTrigger" class="headerlink" title="EventTimeTrigger"></a>EventTimeTrigger</h3><p>EventTimeTrigger与ProcessingTimeTrigger类似：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public TriggerResult onElement(Object element, long timestamp, TimeWindow window, TriggerContext ctx) throws Exception &#123;</span><br><span class="line">if (window.maxTimestamp() &lt;= ctx.getCurrentWatermark()) &#123;</span><br><span class="line">// if the watermark is already past the window fire immediately</span><br><span class="line">return TriggerResult.FIRE;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">ctx.registerEventTimeTimer(window.maxTimestamp());</span><br><span class="line">return TriggerResult.CONTINUE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public TriggerResult onEventTime(long time, TimeWindow window, TriggerContext ctx) &#123;</span><br><span class="line">return time == window.maxTimestamp() ?</span><br><span class="line">TriggerResult.FIRE :</span><br><span class="line">TriggerResult.CONTINUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public TriggerResult onProcessingTime(long time, TimeWindow window, TriggerContext ctx) throws Exception &#123;</span><br><span class="line">return TriggerResult.CONTINUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void clear(TimeWindow window, TriggerContext ctx) throws Exception &#123;</span><br><span class="line">ctx.deleteEventTimeTimer(window.maxTimestamp());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>onElement方法会检查当前窗口的最大时间戳是否大于水印，若大于水印，则直接触发窗口的fire操作，若小于水印，则注册EventTime的时钟，当<strong>水印时间到达时钟设定值</strong>时，会触发窗口的fire操作。</p><p>最后，我们看一个很有用的Trigger工具类—PurgingTrigger。</p><h3 id="PurgingTrigger"><a href="#PurgingTrigger" class="headerlink" title="PurgingTrigger"></a>PurgingTrigger</h3><p>首先看PurgingTrigger的构造器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private PurgingTrigger(Trigger&lt;T, W&gt; nestedTrigger) &#123;</span><br><span class="line">this.nestedTrigger = nestedTrigger;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PurgingTrigger会将传入的nestedTrigger进行”二次处理”，当nestedTrigger执行fire操作时，PurgingTrigger会将其转换为fire+purge操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public TriggerResult onElement(T element, long timestamp, W window, TriggerContext ctx) throws Exception &#123;</span><br><span class="line">TriggerResult triggerResult = nestedTrigger.onElement(element, timestamp, window, ctx);</span><br><span class="line">return triggerResult.isFire() ? TriggerResult.FIRE_AND_PURGE : triggerResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public TriggerResult onEventTime(long time, W window, TriggerContext ctx) throws Exception &#123;</span><br><span class="line">TriggerResult triggerResult = nestedTrigger.onEventTime(time, window, ctx);</span><br><span class="line">return triggerResult.isFire() ? TriggerResult.FIRE_AND_PURGE : triggerResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public TriggerResult onProcessingTime(long time, W window, TriggerContext ctx) throws Exception &#123;</span><br><span class="line">TriggerResult triggerResult = nestedTrigger.onProcessingTime(time, window, ctx);</span><br><span class="line">return triggerResult.isFire() ? TriggerResult.FIRE_AND_PURGE : triggerResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>典型的修饰器模式。</strong></p><p>KeyedStream的countWindow(long size)直接应用了PurgingTrigger工具类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public WindowedStream&lt;T, KEY, GlobalWindow&gt; countWindow(long size) &#123;</span><br><span class="line">return window(GlobalWindows.create()).trigger(PurgingTrigger.of(CountTrigger.of(size)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Evictor"><a href="#Evictor" class="headerlink" title="Evictor"></a>Evictor</h2><p>可以译为“驱逐者”。在Trigger触发之后，在窗口被处理前/后，Evictor（如果有Evictor的话）会用来剔除窗口中不需要的元素，相当于一个filter。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public interface Evictor&lt;T, W extends Window&gt; extends Serializable &#123;</span><br><span class="line"></span><br><span class="line">void evictBefore(Iterable&lt;TimestampedValue&lt;T&gt;&gt; elements, int size, W window, EvictorContext evictorContext);</span><br><span class="line"></span><br><span class="line">void evictAfter(Iterable&lt;TimestampedValue&lt;T&gt;&gt; elements, int size, W window, EvictorContext evictorContext);</span><br><span class="line"></span><br><span class="line">interface EvictorContext &#123;</span><br><span class="line"></span><br><span class="line">long getCurrentProcessingTime();</span><br><span class="line"></span><br><span class="line">MetricGroup getMetricGroup();</span><br><span class="line"></span><br><span class="line">long getCurrentWatermark();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其主要有如下实现类：</p><p><img src="/2019/08/19/Flink的Window源码剖析/8.jpg" alt=""></p><h3 id="CountEvictor"><a href="#CountEvictor" class="headerlink" title="CountEvictor"></a>CountEvictor</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">public class CountEvictor&lt;W extends Window&gt; implements Evictor&lt;Object, W&gt; &#123;</span><br><span class="line">private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line">// 窗口的最大元素数量</span><br><span class="line">private final long maxCount;</span><br><span class="line">// 是否在计算后驱逐元素</span><br><span class="line">private final boolean doEvictAfter;</span><br><span class="line"></span><br><span class="line">private CountEvictor(long count, boolean doEvictAfter) &#123;</span><br><span class="line">this.maxCount = count;</span><br><span class="line">this.doEvictAfter = doEvictAfter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private CountEvictor(long count) &#123;</span><br><span class="line">this.maxCount = count;</span><br><span class="line">// 默认在计算前执行Evictor操作</span><br><span class="line">this.doEvictAfter = false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void evictBefore(Iterable&lt;TimestampedValue&lt;Object&gt;&gt; elements, int size, W window, EvictorContext ctx) &#123;</span><br><span class="line">// 若doEvictAfter为false</span><br><span class="line">if (!doEvictAfter) &#123;</span><br><span class="line">evict(elements, size, ctx);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void evictAfter(Iterable&lt;TimestampedValue&lt;Object&gt;&gt; elements, int size, W window, EvictorContext ctx) &#123;</span><br><span class="line">// 若doEvictAfter为true</span><br><span class="line">if (doEvictAfter) &#123;</span><br><span class="line">evict(elements, size, ctx);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void evict(Iterable&lt;TimestampedValue&lt;Object&gt;&gt; elements, int size, EvictorContext ctx) &#123;</span><br><span class="line">if (size &lt;= maxCount) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">int evictedCount = 0;</span><br><span class="line">// Iterator&lt;TimestampedValue&lt;Object&gt;&gt; iterator是按照元素到达时间排序的有序迭代器，第1个元素为时间最old的</span><br><span class="line">for (Iterator&lt;TimestampedValue&lt;Object&gt;&gt; iterator = elements.iterator(); iterator.hasNext();)&#123;</span><br><span class="line">iterator.next();</span><br><span class="line">evictedCount++;</span><br><span class="line">if (evictedCount &gt; size - maxCount) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">// 将多余的元素剔除</span><br><span class="line">iterator.remove();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Creates a &#123;@code CountEvictor&#125; that keeps the given number of elements.</span><br><span class="line"> * Eviction is done before the window function.</span><br><span class="line"> *</span><br><span class="line"> * @param maxCount The number of elements to keep in the pane.</span><br><span class="line"> */</span><br><span class="line">public static &lt;W extends Window&gt; CountEvictor&lt;W&gt; of(long maxCount) &#123;</span><br><span class="line">return new CountEvictor&lt;&gt;(maxCount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static &lt;W extends Window&gt; CountEvictor&lt;W&gt; of(long maxCount, boolean doEvictAfter) &#123;</span><br><span class="line">return new CountEvictor&lt;&gt;(maxCount, doEvictAfter);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>KeyedStream的countWindow(long size, long slide)方法应用CountEvictor实现了滑动窗口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public WindowedStream&lt;T, KEY, GlobalWindow&gt; countWindow(long size, long slide) &#123;</span><br><span class="line">return window(GlobalWindows.create())</span><br><span class="line">.evictor(CountEvictor.of(size))</span><br><span class="line">.trigger(CountTrigger.of(slide));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TimeEvictor"><a href="#TimeEvictor" class="headerlink" title="TimeEvictor"></a>TimeEvictor</h3><p>TimeEvictor与CountEvictor类似，TimeEvictor基于时间驱动，故其windowSize参数对应CountEvictor的maxCount，均表征窗口的大小，重点看一下evict方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private void evict(Iterable&lt;TimestampedValue&lt;Object&gt;&gt; elements, int size, EvictorContext ctx) &#123;</span><br><span class="line">if (!hasTimestamp(elements)) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">// 获取所有元素时间戳的最大值</span><br><span class="line">long currentTime = getMaxTimestamp(elements);</span><br><span class="line">// 获取evict分割线</span><br><span class="line">long evictCutoff = currentTime - windowSize;</span><br><span class="line"></span><br><span class="line">for (Iterator&lt;TimestampedValue&lt;Object&gt;&gt; iterator = elements.iterator(); iterator.hasNext(); ) &#123;</span><br><span class="line">TimestampedValue&lt;Object&gt; record = iterator.next();</span><br><span class="line">// 若元素的时间戳不大于evict分割线，执行删除操作</span><br><span class="line">if (record.getTimestamp() &lt;= evictCutoff) &#123;</span><br><span class="line">iterator.remove();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DeltaEvictor"><a href="#DeltaEvictor" class="headerlink" title="DeltaEvictor"></a>DeltaEvictor</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class DeltaEvictor&lt;T, W extends Window&gt; implements Evictor&lt;T, W&gt; &#123;</span><br><span class="line">private static final long serialVersionUID = 1L;</span><br><span class="line">// 求两元素间距离的函数</span><br><span class="line">DeltaFunction&lt;T&gt; deltaFunction;</span><br><span class="line">// 阈值</span><br><span class="line">private double threshold;</span><br><span class="line">private final boolean doEvictAfter;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">private void evict(Iterable&lt;TimestampedValue&lt;T&gt;&gt; elements, int size, EvictorContext ctx) &#123;</span><br><span class="line">// 获取最新的元素</span><br><span class="line">TimestampedValue&lt;T&gt; lastElement = Iterables.getLast(elements);</span><br><span class="line">for (Iterator&lt;TimestampedValue&lt;T&gt;&gt; iterator = elements.iterator(); iterator.hasNext();)&#123;</span><br><span class="line">TimestampedValue&lt;T&gt; element = iterator.next();</span><br><span class="line">// 若当前元素与最新元素之间的距离超过阈值，则删除该元素</span><br><span class="line">if (deltaFunction.getDelta(element.getValue(), lastElement.getValue()) &gt;= this.threshold) &#123;</span><br><span class="line">iterator.remove();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上述代码易知，基于DeltaEvictor可以实现CountEvictor和TimeEvictor，只要实现各自的DeltaFunction即可，所以DeltaEvictor更具有一般性。</p><h2 id="开源推荐"><a href="#开源推荐" class="headerlink" title="开源推荐"></a>开源推荐</h2><p>在学习Flink的过程中，本人将涉及到的测试案例、源码解读、开发技巧等系统整理了一下，并开源到Github上，地址为：</p><p><a href="https://github.com/Ruanshubin/awesome-flink" target="_blank" rel="noopener">https://github.com/Ruanshubin/awesome-flink</a></p><p><strong>欢迎大家Star支持！</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Window&quot;&gt;&lt;a href=&quot;#Window&quot; class=&quot;headerlink&quot; title=&quot;Window&quot;&gt;&lt;/a&gt;Window&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2019/08/19/Flink的Window源码剖析/1.jpg&quot; alt=&quot;&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="Flink" scheme="http://ruanshubin.top/categories/Flink/"/>
    
    
      <category term="大数据" scheme="http://ruanshubin.top/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Flink" scheme="http://ruanshubin.top/tags/Flink/"/>
    
  </entry>
  
  <entry>
    <title>Flink的Window初探</title>
    <link href="http://ruanshubin.top/2019/08/15/Flink%E7%9A%84Window%E5%88%9D%E6%8E%A2/"/>
    <id>http://ruanshubin.top/2019/08/15/Flink的Window初探/</id>
    <published>2019-08-15T08:38:00.000Z</published>
    <updated>2019-09-16T05:45:40.929Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Flink 认为 Batch 是 Streaming 的一个特例，所以 Flink 底层引擎是一个流式引擎，在上面实现了流处理和批处理。而窗口（window）就是从 Streaming 到 Batch 的一个桥梁。</p></blockquote><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在流处理应用中，数据是连续不断的，因此我们不可能等到所有数据都到了才开始处理。当然我们可以每来一个消息就处理一次，但是有时我们需要做一些聚合类的处理。</p><p>基于窗口驱动方式可分为:</p><ul><li>时间驱动的（Time Window，例如：每30秒钟）</li><li>数据驱动的（Count Window，例如：每一百个元素）</li></ul><p>基于窗口处理方式可分为：</p><ul><li>翻滚窗口（Tumbling Window，无重叠）</li><li>滚动窗口（Sliding Window，有重叠）</li><li>会话窗口（Session Window，活动间隙）</li></ul><p><img src="/2019/08/15/Flink的Window初探/1.jpg" alt=""></p><p>需要说明的是，Flink将Time分为3种:</p><ul><li>event time（事件时间：事件发生时的时间）</li><li>ingestion time（摄取时间：事件进入流处理系统的时间）</li><li>processing time（处理时间：消息被计算处理的时间）</li></ul><p><img src="/2019/08/15/Flink的Window初探/2.jpg" alt=""></p><h2 id="Count-Window"><a href="#Count-Window" class="headerlink" title="Count Window"></a>Count Window</h2><p>Count Window 是根据元素个数对数据流进行分组的。</p><h3 id="Tumbling-Count-Window"><a href="#Tumbling-Count-Window" class="headerlink" title="Tumbling Count Window"></a>Tumbling Count Window</h3><p>当我们想要每100个用户购买行为事件统计购买总数，那么每当窗口中填满100个元素了，就会对窗口进行计算，这种窗口我们称之为翻滚计数窗口（Tumbling Count Window），通过使用 DataStream API，我们可以这样实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Stream of (userId, buyCnts)</span><br><span class="line">val buyCnts: DataStream[(Int, Int)] = ...</span><br><span class="line"></span><br><span class="line">val tumblingCnts: DataStream[(Int, Int)] = buyCnts</span><br><span class="line">  // key stream by sensorId</span><br><span class="line">  .keyBy(0)</span><br><span class="line">  // tumbling count window of 100 elements size</span><br><span class="line">  .countWindow(100)</span><br><span class="line">  // compute the buyCnt sum </span><br><span class="line">  .sum(1)</span><br></pre></td></tr></table></figure><h3 id="Sliding-Count-Window"><a href="#Sliding-Count-Window" class="headerlink" title="Sliding Count Window"></a>Sliding Count Window</h3><p>Count Window 也支持 Sliding Window，虽在上图中未描述出来，但和Sliding Time Window含义是类似的，例如计算每10个元素计算一次最近100个元素的总和，代码示例如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val slidingCnts: DataStream[(Int, Int)] = vehicleCnts</span><br><span class="line">  .keyBy(0)</span><br><span class="line">  // sliding count window of 100 elements size and 10 elements trigger interval</span><br><span class="line">  .countWindow(100, 10)</span><br><span class="line">  .sum(1)</span><br></pre></td></tr></table></figure><h2 id="Time-Window"><a href="#Time-Window" class="headerlink" title="Time Window"></a>Time Window</h2><h3 id="Tumbling-Time-Window"><a href="#Tumbling-Time-Window" class="headerlink" title="Tumbling Time Window"></a>Tumbling Time Window</h3><p>统计每一分钟中用户购买的商品的总数，需要将用户的行为事件按每一分钟进行切分，这种切分被成为翻滚时间窗口（Tumbling Time Window）。</p><p>翻滚窗口能将数据流切分成不重叠的窗口，每一个事件只能属于一个窗口。通过使用DataStream API，可以这样实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Stream of (userId, buyCnt)</span><br><span class="line">val buyCnts: DataStream[(Int, Int)] = ...</span><br><span class="line"></span><br><span class="line">val tumblingCnts: DataStream[(Int, Int)] = buyCnts</span><br><span class="line">  // key stream by userId</span><br><span class="line">  .keyBy(0) </span><br><span class="line">  // tumbling time window of 1 minute length</span><br><span class="line">  .timeWindow(Time.minutes(1))</span><br><span class="line">  // compute sum over buyCnt</span><br><span class="line">  .sum(1)</span><br></pre></td></tr></table></figure><h3 id="Sliding-Time-Window"><a href="#Sliding-Time-Window" class="headerlink" title="Sliding Time Window"></a>Sliding Time Window</h3><p>对于某些应用，它们需要的窗口是不间断的，需要平滑地进行窗口聚合。比如，我们可以每30秒计算一次最近一分钟用户购买的商品总数。这种窗口我们称为滑动时间窗口（Sliding Time Window）。在滑窗中，一个元素可以对应多个窗口。通过使用 DataStream API，我们可以这样实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val slidingCnts: DataStream[(Int, Int)] = buyCnts</span><br><span class="line">  .keyBy(0) </span><br><span class="line">  // sliding time window of 1 minute length and 30 secs trigger interval</span><br><span class="line">  .timeWindow(Time.minutes(1), Time.seconds(30))</span><br><span class="line">  .sum(1)</span><br></pre></td></tr></table></figure><h2 id="Session-Window"><a href="#Session-Window" class="headerlink" title="Session Window"></a>Session Window</h2><p>在这种用户交互事件流中，我们首先想到的是将事件聚合到会话窗口中（一段用户持续活跃的周期），由非活跃的间隙分隔开。如上图所示，就是需要计算每个用户在活跃期间总共购买的商品数量，如果用户30秒没有活动则视为会话断开（假设raw data stream是单个用户的购买行为流）。Session Window 的示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Stream of (userId, buyCnts)</span><br><span class="line">val buyCnts: DataStream[(Int, Int)] = ...</span><br><span class="line">    </span><br><span class="line">val sessionCnts: DataStream[(Int, Int)] = vehicleCnts</span><br><span class="line">    .keyBy(0)</span><br><span class="line">    // session window based on a 30 seconds session gap interval </span><br><span class="line">    .window(ProcessingTimeSessionWindows.withGap(Time.seconds(30)))</span><br><span class="line">    .sum(1)</span><br></pre></td></tr></table></figure><p>session 是指一段持续活跃的期间，由活跃间隙分隔开。通俗一点说，消息之间的间隔小于超时阈值（sessionGap）的，则被分配到同一个窗口，间隔大于阈值的，则被分配到不同的窗口。</p><p>目前开源领域大部分的流计算引擎都有窗口的概念，但是没有对 session window 的支持，要实现 session window，需要用户自己去做完大部分事情。而当 Flink 1.1.0 版本正式发布时，Flink 将会是开源流计算领域第一个内建支持 session window 的引擎。</p><p>在 Flink 1.1.0 之前，Flink 也可以通过自定义的window assigner和trigger来实现一个基本能用的session window。</p><p>基于GlobleWindow这个window assigner，将所有元素都分配到同一个窗口中，然后指定一个自定义的trigger来触发执行窗口。这个trigger的触发机制是，对于每个到达的元素都会根据其时间戳（timestamp）注册一个会话超时的定时器（timestamp+sessionTimeout），并移除上一次注册的定时器。最新一个元素到达后，如果超过 sessionTimeout 的时间还没有新元素到达，那么trigger就会触发，当前窗口就会是一个session window。处理完窗口后，窗口中的数据会清空，用来缓存下一个session window的数据。</p><p>但是这种session window的实现是非常弱的，无法应用到实际生产环境中的。因为它无法处理乱序 event time 的消息。</p><p>Flink 1.1.0 版本中，Flink提供了对session window的直接支持，用户可以通过SessionWindows.withGap()来轻松地定义session widnow，而且能够处理乱序消息。Flink对session window的支持主要借鉴自Google的DataFlow。</p><h2 id="Window-API"><a href="#Window-API" class="headerlink" title="Window API"></a>Window API</h2><h3 id="Window-Assigner"><a href="#Window-Assigner" class="headerlink" title="Window Assigner"></a>Window Assigner</h3><p>用来决定某个元素被分配到哪个/哪些窗口中去。</p><p><img src="/2019/08/15/Flink的Window初探/3.jpg" alt=""></p><p>Window本身只是一个ID标识符，其内部可能存储了一些元数据，如TimeWindow中有开始和结束时间，但是并不会存储窗口中的元素。窗口中的元素实际存储在 Key/Value State 中，key为Window，value为元素集合（或聚合值）。为了保证窗口的容错性，该实现依赖了 Flink 的 State 机制（参见 state 文档）。</p><h3 id="Trigger"><a href="#Trigger" class="headerlink" title="Trigger"></a>Trigger</h3><p>触发器。决定了一个窗口何时能够被计算或清除，每个窗口都会拥有一个自己的Trigger。</p><p><img src="/2019/08/15/Flink的Window初探/4.jpg" alt=""></p><p>Trigger的返回结果可以是 continue（不做任何操作），fire（处理窗口数据），purge（移除窗口和窗口中的数据），或者 fire + purge。一个Trigger的调用结果只是fire的话，那么会计算窗口并保留窗口原样，也就是说窗口中的数据仍然保留不变，等待下次Trigger fire的时候再次执行计算。一个窗口可以被重复计算多次知道它被 purge 了。在purge之前，窗口会一直占用着内存。</p><h3 id="Evictor"><a href="#Evictor" class="headerlink" title="Evictor"></a>Evictor</h3><p>可以译为“驱逐者”。在Trigger触发之后，在窗口被处理之前，Evictor（如果有Evictor的话）会用来剔除窗口中不需要的元素，相当于一个filter。</p><p><img src="/2019/08/15/Flink的Window初探/5.jpg" alt=""></p><p>当Trigger fire了，窗口中的元素集合就会交给Evictor（如果指定了的话）。Evictor 主要用来遍历窗口中的元素列表，并决定最先进入窗口的多少个元素需要被移除。剩余的元素会交给用户指定的函数进行窗口的计算。如果没有 Evictor 的话，窗口中的所有元素会一起交给函数进行计算。</p><p>上述三个组件的不同实现的不同组合，可以定义出非常复杂的窗口。Flink 中内置的窗口也都是基于这三个组件构成的，当然内置窗口有时候无法解决用户特殊的需求，所以 Flink 也暴露了这些窗口机制的内部接口供用户实现自定义的窗口。</p><p><img src="/2019/08/15/Flink的Window初探/6.jpg" alt=""></p><p><img src="/2019/08/15/Flink的Window初探/7.jpg" alt=""></p><p>在后面的章节里，我们会从源码剖析Flink的Window机制。</p><h2 id="开源推荐"><a href="#开源推荐" class="headerlink" title="开源推荐"></a>开源推荐</h2><p>在学习Flink的过程中，本人将涉及到的测试案例、源码解读、开发技巧等系统整理了一下，并开源到Github上，地址为：</p><p><a href="https://github.com/Ruanshubin/awesome-flink" target="_blank" rel="noopener">https://github.com/Ruanshubin/awesome-flink</a></p><p><strong>欢迎大家Star支持！</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Flink 认为 Batch 是 Streaming 的一个特例，所以 Flink 底层引擎是一个流式引擎，在上面实现了流处理和批处理。而窗口（window）就是从 Streaming 到 Batch 的一个桥梁。&lt;/p&gt;
&lt;/blockquote
      
    
    </summary>
    
      <category term="Flink" scheme="http://ruanshubin.top/categories/Flink/"/>
    
    
      <category term="大数据" scheme="http://ruanshubin.top/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Flink" scheme="http://ruanshubin.top/tags/Flink/"/>
    
  </entry>
  
  <entry>
    <title>Spark从入门到放弃--3RDD和共享变量</title>
    <link href="http://ruanshubin.top/2019/06/14/Spark%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83--3RDD%E5%92%8C%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F/"/>
    <id>http://ruanshubin.top/2019/06/14/Spark从入门到放弃--3RDD和共享变量/</id>
    <published>2019-06-14T10:20:00.000Z</published>
    <updated>2019-09-16T01:37:16.323Z</updated>
    
    <content type="html"><![CDATA[<p>为进行分布式环境下数据资源的描述，Spark引入了2类抽象概念：</p><p>第1个抽象概念是RDD。</p><h2 id="RDD"><a href="#RDD" class="headerlink" title="RDD"></a>RDD</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>RDD全称为Resilient Distributed Dataset，即弹性分布式数据集，设计理念源自AMP实验室发表的论文《Resilient Distributed Datasets: A Fault-Tolerant Abstraction for In-Memory Cluster Computing》。</p><p>RDDs是跨集群节点分区的元素集合，可以执行并行操作。</p><p>RDDs可以读取HDFS中的文件进行创建，或者由Driver程序的已有Scala集合进行转化后创建。用户可以将RDDs持久存储在内存中，以便在并行操作中复用。</p><h3 id="RDD操作"><a href="#RDD操作" class="headerlink" title="RDD操作"></a>RDD操作</h3><p>一个RDD就是一个分布式对象集合，本质上是一个只读的分区记录集合，每个RDD可以分成多个分区，每个分区就是一个数据集片段，并且一个RDD的不同分区可以被保存到集群中不同的节点上，从而可以在集群中的不同节点上进行并行计算。RDD提供了一种高度受限的共享内存模型，即RDD是只读的记录分区的集合，不能直接修改，只能基于稳定的物理存储中的数据集来创建RDD，或者通过在其他RDD上执行确定的转换操作（如map、join和groupBy）而创建得到新的RDD。</p><p>RDD提供了一组丰富的操作以支持常见的数据运算，分为Action和Transformation两种类型。</p><ul><li>Action操作</li></ul><p>用于执行计算并指定输出的形式，行动操作（比如count、collect等）接受RDD但是返回非RDD（即输出一个值或结果）。</p><ul><li>Transformation操作</li></ul><p>指定RDD之间的相互依赖关系，转换操作（比如map、filter、groupBy、join等）接受RDD并返回RDD。</p><p>RDD提供的转换接口都非常简单，都是类似map、filter、groupBy、join等粗粒度的数据转换操作，而不是针对某个数据项的细粒度修改。因此，RDD比较适合对于数据集中元素执行相同操作的批处理式应用，而不适合用于需要异步、细粒度状态的应用，比如Web应用系统、增量式的网页爬虫等。正因为这样，这种粗粒度转换接口设计，会使人直觉上认为RDD的功能很受限、不够强大。但是，实际上RDD已经被实践证明可以很好地应用于许多并行计算应用中，可以具备很多现有计算框架（比如MapReduce、SQL、Pregel等）的表达能力，并且可以应用于这些框架处理不了的交互式数据挖掘应用。</p><h3 id="懒执行及DAG"><a href="#懒执行及DAG" class="headerlink" title="懒执行及DAG"></a>懒执行及DAG</h3><p>RDD采用了懒执行策略，即在RDD的执行过程中，真正的计算发生在RDD的Action操作，对于Action之前的所有Transformation操作，Spark只是记录下Transformation操作应用的一些基础数据集以及RDD生成的轨迹，即相互之间的依赖关系，而不会触发真正的计算。</p><p><img src="/2019/06/14/Spark从入门到放弃--3RDD和共享变量/1.jpg" alt=""></p><p>如上图，从输入中逻辑上生成A和C两个RDD，经过一系列Transformation操作，逻辑上生成了F（也是一个RDD），之所以说是逻辑上，是因为这时候计算并没有发生，Spark只是记录了RDD之间的生成和依赖关系。当F要进行输出时，也就是当F进行Action操作的时候，Spark才会根据RDD的依赖关系生成DAG，并从起点开始真正的计算。</p><p>上述这一系列处理称为一个“血缘关系（Lineage）”，即DAG拓扑排序的结果。采用惰性调用，通过血缘关系连接起来的一系列RDD操作就可以实现管道化（pipeline），避免了多次转换操作之间数据同步的等待，而且不用担心有过多的中间数据，因为这些具有血缘关系的操作都管道化了，一个操作得到的结果不需要保存为中间数据，而是直接管道式地流入到下一个操作进行处理。同时，这种通过血缘关系把一系列操作进行管道化连接的设计方式，也使得管道中每次操作的计算变得相对简单，保证了每个操作在处理逻辑上的单一性；相反，在MapReduce的设计中，为了尽可能地减少MapReduce过程，在单个MapReduce中会写入过多复杂的逻辑。</p><h3 id="RDD依赖"><a href="#RDD依赖" class="headerlink" title="RDD依赖"></a>RDD依赖</h3><p>RDD中不同的操作会使得不同RDD中的分区会产生不同的依赖。RDD中的依赖关系分为窄依赖（Narrow Dependency）与宽依赖（Wide Dependency）。</p><p><img src="/2019/06/14/Spark从入门到放弃--3RDD和共享变量/2.jpg" alt=""></p><p>其实宽、窄依赖的区分非常简单：</p><ul><li>若每个父RDD分区仅流向1个子RDD分区，则为窄依赖；</li><li>若每个父RDD分区流向多个子RDD分区，则为宽依赖。</li></ul><p>对于窄依赖的RDD，可以以流水线的方式计算所有父分区，不会造成网络之间的数据混合。对于宽依赖的RDD，则通常伴随着Shuffle操作，即首先需要计算好所有父分区数据，然后在节点之间进行Shuffle。</p><h3 id="Stage划分"><a href="#Stage划分" class="headerlink" title="Stage划分"></a>Stage划分</h3><p>Spark通过分析各个RDD的依赖关系生成了DAG，再通过分析各个RDD中的分区之间的依赖关系来决定如何划分Stage(阶段)。</p><p>具体划分方法是：</p><ul><li>在DAG中进行反向解析，遇到宽依赖就断开，遇到窄依赖就把当前的RDD加入到当前的Stage中；</li><li>将窄依赖尽量划分在同一个Stage中，可以实现流水线计算。</li></ul><p><img src="/2019/06/14/Spark从入门到放弃--3RDD和共享变量/3.jpg" alt=""></p><p>假设从HDFS中读入数据生成3个不同的RDD（即A、C和E），通过一系列转换操作后再将计算结果保存回HDFS。对DAG进行解析时，在依赖图中进行反向解析，由于从RDD A到RDD B的转换以及从RDD B和F到RDD G的转换，都属于宽依赖，因此，在宽依赖处断开后可以得到三个阶段，即阶段1、阶段2和阶段3。可以看出，在阶段2中，从map到union都是窄依赖，这两步操作可以形成一个流水线操作，比如，分区7通过map操作生成的分区9，可以不用等待分区8到分区9这个转换操作的计算结束，而是继续进行union操作，转换得到分区13，这样流水线执行大大提高了计算的效率。</p><h3 id="任务调度器"><a href="#任务调度器" class="headerlink" title="任务调度器"></a>任务调度器</h3><p>Spark的任务调度器包括DAGScheduler和TaskScheduler。</p><p>DAGScheduler把一个Spark作业转换成Stage的DAG（Directed Acyclic Graph有向无环图），根据RDD和Stage之间的关系找出开销最小的调度方法，然后把Stage以TaskSet的形式提交给TaskScheduler。</p><p>DAGScheduler决定了运行Task的理想位置，并把这些信息传递给下层的TaskScheduler。此外，DAGScheduler还处理由于Shuffle数据丢失 导致的失败，这有可能需要重新提交运行之前的Stage（非Shuffle数据丢失导致的Task失败由TaskScheduler处理）。 </p><p>TaskScheduler维护所有TaskSet，当Executor向Driver发送心跳时，TaskScheduler会根据其资源剩余情况分配 相应的Task。另外TaskScheduler还维护着所有Task的运行状态，重试失败的Task。</p><h3 id="RDD运行"><a href="#RDD运行" class="headerlink" title="RDD运行"></a>RDD运行</h3><p><img src="/2019/06/14/Spark从入门到放弃--3RDD和共享变量/4.jpg" alt=""></p><ul><li>创建RDD对象；</li><li>SparkContext负责计算RDD之间的依赖关系，构建DAG；</li><li>DAGScheduler负责把DAG图分解成多个阶段，每个阶段中包含了多个任务，每个任务会被任务调度器分发给各个工作节点（Worker Node）上的Executor去执行。</li></ul><p>Spark的第2抽象概念是共享变量。</p><h2 id="共享变量"><a href="#共享变量" class="headerlink" title="共享变量"></a>共享变量</h2><p>默认情况下，Spark在不同节点的task上并行运行函数时，它会将函数使用的每个变量的副本发送给每个任务。</p><p>当需要在tasks之间，或者task与driver之间共享某个变量时，共享变量便登场了。</p><p>Spark支持2种类型的共享变量:</p><ul><li>广播变量(broadcast variables)</li></ul><p>其可以在所有节点的内存中缓存某个Value。</p><p>广播变量允许开发人员在每个节点（Worker or Executor）缓存只读变量，而不是在Task之间传递这些变量。使用广播变量能够高效地在集群每个节点创建大数据集的副本。同时Spark还使用高效的广播算法分发这些变量，从而减少通信的开销。</p><p>Spark应用程序Job的执行由一系列调度Stage(阶段)构成，而这些调度Stage通过Shuffle进行分隔。Spark能够在每个调度Stage自动广播任务所需通用的数据，这些数据在广播时需进行序列化缓存，并在任务运行前进行反序列化。这就意味着当多个调度Stage的任务需要相同的数据，显示地创建广播变量才有用。</p><ul><li>计数器(accumulators)</li></ul><p>仅用于执行变量的累加操作，如计数或求和。</p><p>Accumulator只提供了累加的功能，但是却给我们提供了多个task对一个变量并行操作的功能。task只能对Accumulator进行累加操作，不能读取它的值。只有Driver程序可以读取Accumulator的值。</p><p>累加器只能由Spark内部进行更新，并保证每个任务在累加器的更新操作仅执行一次，也就是说重启任务也不应该更新。在转换操作中，用户必须意识到任务和作业的调度过程重新执行会造成累加器的多次更新。</p><p>累加器同样具有Spark懒加载的求值模型。如果它们在RDD的操作中进行更新，它们的值只在RDD进行行动操作时才进行更新。</p><p><strong>参考文献:</strong></p><ol><li><a href="http://spark.apache.org/docs/latest/rdd-programming-guide.html" target="_blank" rel="noopener">http://spark.apache.org/docs/latest/rdd-programming-guide.html</a></li><li><a href="http://dblab.xmu.edu.cn/blog/985-2/" target="_blank" rel="noopener">http://dblab.xmu.edu.cn/blog/985-2/</a></li><li><a href="https://www.cnblogs.com/1130136248wlxk/articles/6289717.html" target="_blank" rel="noopener">https://www.cnblogs.com/1130136248wlxk/articles/6289717.html</a></li><li><a href="https://blog.csdn.net/anbang713/article/details/81588829" target="_blank" rel="noopener">https://blog.csdn.net/anbang713/article/details/81588829</a></li></ol><p><img src="https://upload-images.jianshu.io/upload_images/10431632-86426e609c966a5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>欢迎您扫一扫上面的二维码，关注我的微信公众号！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为进行分布式环境下数据资源的描述，Spark引入了2类抽象概念：&lt;/p&gt;
&lt;p&gt;第1个抽象概念是RDD。&lt;/p&gt;
&lt;h2 id=&quot;RDD&quot;&gt;&lt;a href=&quot;#RDD&quot; class=&quot;headerlink&quot; title=&quot;RDD&quot;&gt;&lt;/a&gt;RDD&lt;/h2&gt;&lt;h3 id=&quot;基
      
    
    </summary>
    
      <category term="Spark" scheme="http://ruanshubin.top/categories/Spark/"/>
    
    
      <category term="Hadoop" scheme="http://ruanshubin.top/tags/Hadoop/"/>
    
      <category term="Spark" scheme="http://ruanshubin.top/tags/Spark/"/>
    
  </entry>
  
  <entry>
    <title>Spark从入门到放弃--2运行架构</title>
    <link href="http://ruanshubin.top/2019/06/14/Spark%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83--2%E8%BF%90%E8%A1%8C%E6%9E%B6%E6%9E%84/"/>
    <id>http://ruanshubin.top/2019/06/14/Spark从入门到放弃--2运行架构/</id>
    <published>2019-06-14T02:25:00.000Z</published>
    <updated>2019-09-16T01:37:16.317Z</updated>
    
    <content type="html"><![CDATA[<h2 id="术语表"><a href="#术语表" class="headerlink" title="术语表"></a>术语表</h2><p>讲解Spark运行架构之前，我们先科普一下Spark集群的相关术语:</p><p><img src="/2019/06/14/Spark从入门到放弃--2运行架构/1.jpg" alt=""></p><h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><p>Spark应用运行在集群中的独立进程集中，并通过主进程(Driver)中的SparkContext对象进行进程间的控制协调，其运行架构如下图所示:</p><p><img src="/2019/06/14/Spark从入门到放弃--2运行架构/2.jpg" alt=""></p><p>Cluster Manager(CM)主要负责应用的资源管理，在集群上运行Spark应用时，先由Driver的SparkContext连接CM申请计算资源，然后在集群的Worker节点上启动相应的Exector进程，Executor运行情况将随着心跳发送到资源管理器上。</p><p>具体执行任务时，先由SparkContext构建成DAG图，将DAG图分解成Stage，并把Taskset发送给Task Scheduler。Executor向SparkContext申请Task，Task Scheduler将Task发放给Executor运行同时SparkContext将应用程序代码发放给Executor。 </p><p>Task在Executor上运行，运行完毕释放所有资源。</p><p>SparkContext可以连接不同种类的CM，比如Spark的Standalone、Yarn及Mesos等。</p><p><img src="/2019/06/14/Spark从入门到放弃--2运行架构/3.jpg" alt=""></p><p>整个架构需要注意以下几点:</p><ol><li>不同应用间的Exector是互相独立的，其task也是运行在不同的线程中，该种模式的优点是应用在调度端(每个Driver调度自己的tasks)和执行端(不同应用的tasks运行在不同JVMs中)均是相互独立的。</li><li>Spark与底层Cluster Manager类型无关，只要它能获取相应资源，启动Executor进程，并且Executor进程间可以相互通信即可。</li><li>Executor上有一个BlockManager存储模块，类似于键值存储系统（把内存和磁盘共同作为存储设备），在处理迭代计算任务时，不需要把中间结果写入到HDFS等文件系统，而是直接放在这个存储系统上，后续有需要时就可以直接读取；在交互式查询场景下，也可以把表提前缓存到这个存储系统上，提高读写IO性能。</li><li>任务采用了数据本地性和推测执行等优化机制。数据本地性是尽量将计算移到数据所在的节点上进行，即“计算向数据靠拢”，因为移动计算比移动数据所占的网络资源要少得多。而且，Spark采用了延时调度机制，可以在更大的程度上实现执行过程优化。比如，拥有数据的节点当前正被其他的任务占用，那么，在这种情况下是否需要将数据移动到其他的空闲节点呢？答案是不一定。因为，如果经过预测发现当前节点结束当前任务的时间要比移动数据的时间还要少，那么，调度就会等待，直到当前节点可用。</li></ol><p><strong>参考文献:</strong></p><ol><li><a href="http://spark.apache.org/docs/latest/cluster-overview.html" target="_blank" rel="noopener">http://spark.apache.org/docs/latest/cluster-overview.html</a></li><li><a href="http://dblab.xmu.edu.cn/blog/972-2/" target="_blank" rel="noopener">http://dblab.xmu.edu.cn/blog/972-2/</a></li></ol><p><img src="https://upload-images.jianshu.io/upload_images/10431632-86426e609c966a5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>欢迎您扫一扫上面的二维码，关注我的微信公众号！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;术语表&quot;&gt;&lt;a href=&quot;#术语表&quot; class=&quot;headerlink&quot; title=&quot;术语表&quot;&gt;&lt;/a&gt;术语表&lt;/h2&gt;&lt;p&gt;讲解Spark运行架构之前，我们先科普一下Spark集群的相关术语:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/06/14/Sp
      
    
    </summary>
    
      <category term="Spark" scheme="http://ruanshubin.top/categories/Spark/"/>
    
    
      <category term="Hadoop" scheme="http://ruanshubin.top/tags/Hadoop/"/>
    
      <category term="Spark" scheme="http://ruanshubin.top/tags/Spark/"/>
    
  </entry>
  
  <entry>
    <title>Spark从入门到放弃--1概述</title>
    <link href="http://ruanshubin.top/2019/06/13/Spark%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83--1%E6%A6%82%E8%BF%B0/"/>
    <id>http://ruanshubin.top/2019/06/13/Spark从入门到放弃--1概述/</id>
    <published>2019-06-13T11:36:00.000Z</published>
    <updated>2019-09-16T01:37:16.309Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Spark"><a href="#什么是Spark" class="headerlink" title="什么是Spark"></a>什么是Spark</h2><p>先甩出官网链接: <a href="http://spark.apache.org/" target="_blank" rel="noopener">http://spark.apache.org/</a></p><p><img src="/2019/06/13/Spark从入门到放弃--1概述/1.jpg" alt=""></p><p>通俗来讲，Spark是一个大数据计算框架。</p><p>其具有以下特性:</p><ul><li>快速性</li></ul><p>Spark在批数据和流数据处理上均具有高效地性能，其快速性主要依赖于DAG任务执行器、计算优化和内存执行引擎。</p><p><img src="/2019/06/13/Spark从入门到放弃--1概述/2.jpg" alt=""></p><ul><li>易用性</li></ul><p>支持Java, Scala, Python, R, and SQL等语言，并提供了80多种常用算子，可以使你快速构建并行应用。</p><p><img src="/2019/06/13/Spark从入门到放弃--1概述/3.jpg" alt=""></p><ul><li>普适性</li></ul><p>Spark提供了丰富的组件，主要包括SQL、DataFrames、MLlib、GraphX及Spark Streaming，适用于多种场景下的计算任务。</p><p><img src="/2019/06/13/Spark从入门到放弃--1概述/4.jpg" alt=""></p><ul><li>兼容性</li></ul><p>Spark可运行在Hadoop(Yarn)、Apache Mesos、Kubernetes(K8s)、独立集群或者云服务器(集群)上，并且支持接入不同种类的数据源。</p><p><img src="/2019/06/13/Spark从入门到放弃--1概述/5.jpg" alt=""></p><h2 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h2><ul><li><p>Spark在2009年由Matei Zaharia在加州大学伯克利分校AMPLab开创。</p></li><li><p>2010年通过BSD许可协议开源发布。</p></li><li><p>2013年6月，该项目被捐赠给Apache软件基金会并切换许可协议至Apache2.0。</p></li><li><p>2014年2月，Spark成为Apache的顶级项目。</p></li><li><p>2014年11月，Databricks团队使用Spark刷新数据排序世界记录。</p></li><li><p>2014年5月底Spark1.0.0发布。</p></li><li><p>2014年9月Spark1.1.0发布。</p></li><li><p>2014年12月Spark1.2.0发布。</p></li><li><p>…</p></li><li><p>2016年1月4号Spark1.6.0发布。</p></li><li><p>…</p></li><li><p>2016年6月26号Spark2.0发布。</p></li><li><p>…</p></li><li><p>时至今日的2.4.3版本。</p></li></ul><p>Spark作为Hadoop生态中重要的一员，其发展速度堪称恐怖，不过其作为一个完整的技术栈，在技术和环境的双重刺激下，得到如此多的关注也是有依据的。核心在于内存计算模型代替Hadoop生态的MapReduce离线计算模型，用更加丰富Transformation和Action算子来替代map,reduce两种算子。</p><p>使用Spark的另外一个好处是，Spark的社区比较活跃，且框架一直处于不断优化中，开发过程中若出现问题，方便寻找解决方案。</p><p><img src="/2019/06/13/Spark从入门到放弃--1概述/6.jpg" alt=""></p><p>从Github上也可以看出，直至今日，Spark仍处于Commit高度活跃的状态。</p><h2 id="主要组件"><a href="#主要组件" class="headerlink" title="主要组件"></a>主要组件</h2><p><img src="/2019/06/13/Spark从入门到放弃--1概述/7.jpg" alt=""></p><ul><li>Spark Core</li></ul><p>包含Spark的基本功能；尤其是定义RDD的API、操作以及这两者上的动作。其他Spark的库都是构建在RDD和Spark Core之上的。</p><ul><li>Spark SQL</li></ul><p>提供通过Apache Hive的SQL变体Hive查询语言（HiveQL）与Spark进行交互的API。每个数据库表被当做一个RDD，Spark SQL查询被转换为Spark操作。</p><ul><li>Spark Streaming</li></ul><p>对实时数据流进行处理和控制。Spark Streaming允许程序能够像普通RDD一样处理实时数据。</p><ul><li>MLlib</li></ul><p>一个常用机器学习算法库，算法被实现为对RDD的Spark操作。这个库包含可扩展的学习算法，比如分类、回归等需要对大量数据集进行迭代的操作。</p><ul><li>GraphX</li></ul><p>控制图、并行图操作和计算的一组算法和工具的集合。GraphX扩展了RDD API，包含控制图、创建子图、访问路径上所有顶点的操作。</p><p><strong>参考文献:</strong></p><ol><li><a href="http://spark.apache.org/" target="_blank" rel="noopener">http://spark.apache.org/</a></li><li><a href="https://www.cnblogs.com/qingyunzong/p/8886338.html" target="_blank" rel="noopener">https://www.cnblogs.com/qingyunzong/p/8886338.html</a></li><li><a href="https://hacpai.com/article/1499870999066" target="_blank" rel="noopener">https://hacpai.com/article/1499870999066</a></li></ol><p><img src="https://upload-images.jianshu.io/upload_images/10431632-86426e609c966a5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>欢迎您扫一扫上面的二维码，关注我的微信公众号！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是Spark&quot;&gt;&lt;a href=&quot;#什么是Spark&quot; class=&quot;headerlink&quot; title=&quot;什么是Spark&quot;&gt;&lt;/a&gt;什么是Spark&lt;/h2&gt;&lt;p&gt;先甩出官网链接: &lt;a href=&quot;http://spark.apache.org/&quot; ta
      
    
    </summary>
    
      <category term="Spark" scheme="http://ruanshubin.top/categories/Spark/"/>
    
    
      <category term="Hadoop" scheme="http://ruanshubin.top/tags/Hadoop/"/>
    
      <category term="Spark" scheme="http://ruanshubin.top/tags/Spark/"/>
    
  </entry>
  
  <entry>
    <title>Spring-IOC的XML配置</title>
    <link href="http://ruanshubin.top/2019/06/05/Spring-IOC%E7%9A%84XML%E9%85%8D%E7%BD%AE/"/>
    <id>http://ruanshubin.top/2019/06/05/Spring-IOC的XML配置/</id>
    <published>2019-06-05T12:19:00.000Z</published>
    <updated>2019-09-16T01:37:16.329Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在Springboot编程实践中，我们偏向使用注解的方式进行Bean的注册和依赖注入等，但XML格式的容器信息管理方式仍是Spring提供的最为强大、支持最为全面的方式，本文对Spring-IOC的XML配置进行详细的讲解。</p><h2 id="和"><a href="#和" class="headerlink" title="和"></a><beans\>和<bean\></bean\></beans\></h2><p>BeanFactory和ApplicationContext的XML配置均采用统一的格式，在Spring2.0之前，这种格式由Spring提供的DTD规定，即在配置文件的头部，需要以下形式的DOCTYPE声明:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE beans PUBLIC &quot;-//SPRING//DTD BEAN//EN&quot;</span><br><span class="line">&quot;http://www.springframework.org/dtd/spring-beans.dtd&quot;&gt;</span><br><span class="line">&lt;beans&gt;</span><br><span class="line">   ...</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>从Spring 2.0版本之后，Spring在继续保持向前兼容的前提下，既可以继续使用DTD方式的 DOCTYPE<br>进行配置文件格式的限定，又引入了基于XML Schema的文档声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">        xmlns:util=&quot;http://www.springframework.org/schema/util&quot;</span><br><span class="line">        xmlns:jee=&quot;http://www.springframework.org/schema/jee&quot;</span><br><span class="line">        xmlns:lang=&quot;http://www.springframework.org/schema/lang&quot;</span><br><span class="line">        xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">        xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</span><br><span class="line">        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans-2.0.xsd</span><br><span class="line">        http://www.springframework.org/schema/util</span><br><span class="line">        http://www.springframework.org/schema/util/spring-util-2.0.xsd</span><br><span class="line">        http://www.springframework.org/schema/jee</span><br><span class="line">        http://www.springframework.org/schema/jee/spring-jee-2.0.xsd</span><br><span class="line">        http://www.springframework.org/schema/lang</span><br><span class="line">        http://www.springframework.org/schema/lang/spring-lang-2.0.xsd</span><br><span class="line">        http://www.springframework.org/schema/aop</span><br><span class="line">        http://www.springframework.org/schema/aop/spring-aop-2.0.xsd</span><br><span class="line">        http://www.springframework.org/schema/tx</span><br><span class="line">        http://www.springframework.org/schema/tx/spring-tx-2.0.xsd&quot;&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a><beans\></beans\></h3><p><beans\>是配置文件的顶层元素，其可以包含0或1个<description\>和多个<bean\>以及<import\>或者<alias\></alias\></import\></bean\></description\></beans\></p><p><beans\>可以配置所有<bean\>的全局行为，主要包括:</bean\></beans\></p><ul><li>default-lazy-init</li></ul><p>取值true或false，默认值false，用来标志是否对所有的<bean\>进行延迟初始化。</bean\></p><ul><li>default-autowire</li></ul><p>可以取值为no、byName、byType、constructor以及autodetect。默认值为 no ，如果使用自动绑定的话，用来标志全体bean使用哪一种默认绑定方式。</p><ul><li>default-dependency-check</li></ul><p>可以取值none、objects、simple以及all，默认值为none，即不做依赖检查。</p><ul><li>default-init-method</li></ul><p>如果所管辖的<bean\>按照某种规则，都有同样名称的初始化方法的话，可以在这里统一指定这个初始化方法名，而不用在每一个<bean\>上都重复单独指定。</bean\></bean\></p><ul><li>default-destroy-method</li></ul><p>与default-init-method相对应，如果所管辖的bean有按照某种规则使用了相同名称的对象销毁方法，可以通过这个属性统一指定。</p><h3 id="、和"><a href="#、和" class="headerlink" title="、和"></a><description\>、<import\>和<alias\></alias\></import\></description\></h3><ul><li><description\></description\></li></ul><p>配置文件的描述信息。</p><ul><li><import\></import\></li></ul><p>通常情况下，可以根据模块功能或者层次关系，将配置信息分门别类地放到多个配置文件中。在想加载主要配置文件，并将主要配置文件所依赖的配置文件同时加载时，可以在这个主要的配置文件中通过<import\>元素对其所依赖的配置文件进行引用。比如，如果A.xml中的<bean\>定义可能依赖B.xml中的某些<bean\>定义，那么就可以在A.xml中使用<import\>将B.xml引入到A.xml，以类似于<import resource="B.xml" \=""> 的形式。</import></import\></bean\></bean\></import\></p><ul><li><alias\></alias\></li></ul><p>可以通过<alias\>为某些<bean\>起一些“外号”（别名），通常情况下是为了减少输入。比如，假设有个<bean\> ，它的名称为dataSourceForMasterDatabase ，你可以为其添加一个<alias\> ，像这样<alias name="dataSourceForMasterDatabase" alias="masterDataSource" \=""> 。以后通过dataSourceForMasterDatabase或者 masterDataSource来引用这个<bean\>都可以。</bean\></alias></alias\></bean\></bean\></alias\></p><h3 id="-1"><a href="#-1" class="headerlink" title=""></a><bean\></bean\></h3><ul><li>id属性</li></ul><p>对象在容器里的标识，若未配置，则<bean\>的id取类名的小驼峰。</bean\></p><p>除了使用id，也可以使用name来进行标识，它与id的区别是， name可以使用id不能使用的一些字符，比如/。而且<br>还可以通过逗号、空格或者冒号分割指定多个name。name的作用跟使用<alias\>为id指定多个别名基本相同：</alias\></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;person&quot; name=&quot;/china/person,/england/person&quot;/ class=&quot;com.ruanshubin.springboot.entity.Person&quot;&gt;</span><br><span class="line">等同于:</span><br><span class="line">&lt;alias name=&quot;person&quot; alias=&quot;/china/person&quot;/&gt;</span><br><span class="line">&lt;alias name=&quot;person&quot; alias=&quot;/england/person&quot;/&gt;</span><br></pre></td></tr></table></figure><ul><li>class属性</li></ul><p>每个注册到容器的对象都需要通过<bean\>元素的class属性指定其类型。</bean\></p><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><p>为了演示依赖注入，我们新建3个实体类，分别为主机、显示器和电脑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class MainEngine &#123;</span><br><span class="line">    // 名称</span><br><span class="line">    private String name;</span><br><span class="line">    // 型号</span><br><span class="line">    private String type;</span><br><span class="line">    // 花费</span><br><span class="line">    private Integer cost;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">构造器及get/set方法</span><br><span class="line">toString方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Display &#123;</span><br><span class="line">    // 名称</span><br><span class="line">    private String name;</span><br><span class="line">    // 型号</span><br><span class="line">    private String type;</span><br><span class="line">    // 花费</span><br><span class="line">    private Integer cost;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">构造器及get/set方法</span><br><span class="line">toString方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Computer &#123;</span><br><span class="line">    // 名称</span><br><span class="line">    private String name;</span><br><span class="line">    // 主机</span><br><span class="line">    private MainEngine mainEngine;</span><br><span class="line">    // 显示器</span><br><span class="line">    private Display display;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">构造器及get/set方法</span><br><span class="line">toString方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造方法注入"><a href="#构造方法注入" class="headerlink" title="构造方法注入"></a>构造方法注入</h3><p>在resources目录下新建spring-beans.xml文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">        xmlns:util=&quot;http://www.springframework.org/schema/util&quot;</span><br><span class="line">        xmlns:jee=&quot;http://www.springframework.org/schema/jee&quot;</span><br><span class="line">        xmlns:lang=&quot;http://www.springframework.org/schema/lang&quot;</span><br><span class="line">        xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">        xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</span><br><span class="line">        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans-2.0.xsd</span><br><span class="line">        http://www.springframework.org/schema/util</span><br><span class="line">        http://www.springframework.org/schema/util/spring-util-2.0.xsd</span><br><span class="line">        http://www.springframework.org/schema/jee</span><br><span class="line">        http://www.springframework.org/schema/jee/spring-jee-2.0.xsd</span><br><span class="line">        http://www.springframework.org/schema/lang</span><br><span class="line">        http://www.springframework.org/schema/lang/spring-lang-2.0.xsd</span><br><span class="line">        http://www.springframework.org/schema/aop</span><br><span class="line">        http://www.springframework.org/schema/aop/spring-aop-2.0.xsd</span><br><span class="line">        http://www.springframework.org/schema/tx</span><br><span class="line">        http://www.springframework.org/schema/tx/spring-tx-2.0.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;display&quot; class=&quot;com.ruanshubin.springboot.ioc.entity.Display&quot;&gt;</span><br><span class="line">        &lt;constructor-arg&gt;</span><br><span class="line">            &lt;value&gt;惠普&lt;/value&gt;</span><br><span class="line">        &lt;/constructor-arg&gt;</span><br><span class="line">        &lt;constructor-arg&gt;</span><br><span class="line">            &lt;value&gt;V300&lt;/value&gt;</span><br><span class="line">        &lt;/constructor-arg&gt;</span><br><span class="line">        &lt;constructor-arg&gt;</span><br><span class="line">            &lt;value&gt;1000&lt;/value&gt;</span><br><span class="line">        &lt;/constructor-arg&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;mainEngine&quot; class=&quot;com.ruanshubin.springboot.ioc.entity.MainEngine&quot;&gt;</span><br><span class="line">        &lt;constructor-arg&gt;</span><br><span class="line">            &lt;value&gt;戴尔&lt;/value&gt;</span><br><span class="line">        &lt;/constructor-arg&gt;</span><br><span class="line">        &lt;constructor-arg&gt;</span><br><span class="line">            &lt;value&gt;T600&lt;/value&gt;</span><br><span class="line">        &lt;/constructor-arg&gt;</span><br><span class="line">        &lt;constructor-arg&gt;</span><br><span class="line">            &lt;value&gt;3600&lt;/value&gt;</span><br><span class="line">        &lt;/constructor-arg&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;computer&quot; class=&quot;com.ruanshubin.springboot.ioc.entity.Computer&quot;&gt;</span><br><span class="line">        &lt;constructor-arg&gt;</span><br><span class="line">            &lt;value&gt;组装机1&lt;/value&gt;</span><br><span class="line">        &lt;/constructor-arg&gt;</span><br><span class="line">        &lt;constructor-arg&gt;</span><br><span class="line">            &lt;ref bean=&quot;mainEngine&quot;&gt;&lt;/ref&gt;</span><br><span class="line">        &lt;/constructor-arg&gt;</span><br><span class="line">        &lt;constructor-arg&gt;</span><br><span class="line">            &lt;ref bean=&quot;display&quot;&gt;&lt;/ref&gt;</span><br><span class="line">        &lt;/constructor-arg&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>编写主函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class IocXmlTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        XmlBeanFactory beanFactory = new XmlBeanFactory(new ClassPathResource(&quot;spring-beans.xml&quot;));</span><br><span class="line">        Computer computer = (Computer) beanFactory.getBean(&quot;computer&quot;);</span><br><span class="line">        System.out.println(computer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Computer&#123;name=&apos;组装机1&apos;, mainEngine=MainEngine&#123;name=&apos;戴尔&apos;, type=&apos;T600&apos;, cost=3600&#125;, display=Display&#123;name=&apos;惠普&apos;, type=&apos;V300&apos;, cost=1000&#125;&#125;</span><br></pre></td></tr></table></figure><p>可以发现，如果注入的属性为基本数据类型(及其包装类)、String等，则使用<value\>进行注入，若为Java对象，则使用<ref bean="..." \="">的方式进行注入。</ref></value\></p><p>同时，上述<constructor-arg\>的顺序要与Java类中属性的顺序要严格一致，否则会出现问题，如将mainEngine的配置修改为:</constructor-arg\></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;mainEngine&quot; class=&quot;com.ruanshubin.springboot.ioc.entity.MainEngine&quot;&gt;</span><br><span class="line">&lt;constructor-arg&gt;</span><br><span class="line">&lt;value&gt;T600&lt;/value&gt;</span><br><span class="line">&lt;/constructor-arg&gt;</span><br><span class="line">&lt;constructor-arg&gt;</span><br><span class="line">&lt;value&gt;戴尔&lt;/value&gt;</span><br><span class="line">&lt;/constructor-arg&gt;</span><br><span class="line">&lt;constructor-arg&gt;</span><br><span class="line">&lt;value&gt;3600&lt;/value&gt;</span><br><span class="line">&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>重新运行主类，结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Computer&#123;name=&apos;组装机1&apos;, mainEngine=MainEngine&#123;name=&apos;T600&apos;, type=&apos;戴尔&apos;, cost=3600&#125;, display=Display&#123;name=&apos;惠普&apos;, type=&apos;V300&apos;, cost=1000&#125;&#125;</span><br></pre></td></tr></table></figure><p>可以发现，主机的名称和型号互换，造成异常。</p><p>此时，可以添加<strong>index标签</strong>，其表征了属性的顺序编号，从0开始。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;mainEngine&quot; class=&quot;com.ruanshubin.springboot.ioc.entity.MainEngine&quot;&gt;</span><br><span class="line">&lt;constructor-arg index=&quot;1&quot;&gt;</span><br><span class="line">&lt;value&gt;T600&lt;/value&gt;</span><br><span class="line">&lt;/constructor-arg&gt;</span><br><span class="line">&lt;constructor-arg index=&quot;0&quot;&gt;</span><br><span class="line">&lt;value&gt;戴尔&lt;/value&gt;</span><br><span class="line">&lt;/constructor-arg&gt;</span><br><span class="line">&lt;constructor-arg&gt;</span><br><span class="line">&lt;value&gt;3600&lt;/value&gt;</span><br><span class="line">&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>还有<strong>type标签</strong>，用于各属性类型不同时配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;mainEngine&quot; class=&quot;com.ruanshubin.springboot.ioc.entity.MainEngine&quot;&gt;</span><br><span class="line">&lt;!--不添加type标签会报错--&gt;</span><br><span class="line">&lt;constructor-arg type=&quot;Integer&quot;&gt;</span><br><span class="line">&lt;value&gt;3600&lt;/value&gt;</span><br><span class="line">&lt;/constructor-arg&gt;</span><br><span class="line">&lt;constructor-arg&gt;</span><br><span class="line">&lt;value&gt;戴尔&lt;/value&gt;</span><br><span class="line">&lt;/constructor-arg&gt;</span><br><span class="line">&lt;constructor-arg&gt;</span><br><span class="line">&lt;value&gt;T600&lt;/value&gt;</span><br><span class="line">&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>最强大的是<strong>name标签</strong>，不管<constructor-arg\>的顺序是否与实体类各属性的顺序是否一致，只要保证name一致即可安全注入，如将mainEngine的配置修改为:</constructor-arg\></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;mainEngine&quot; class=&quot;com.ruanshubin.springboot.ioc.entity.MainEngine&quot;&gt;</span><br><span class="line">&lt;constructor-arg name=&quot;cost&quot;&gt;</span><br><span class="line">&lt;value&gt;3600&lt;/value&gt;</span><br><span class="line">&lt;/constructor-arg&gt;</span><br><span class="line">&lt;constructor-arg name=&quot;type&quot;&gt;</span><br><span class="line">&lt;value&gt;T600&lt;/value&gt;</span><br><span class="line">&lt;/constructor-arg&gt;</span><br><span class="line">&lt;constructor-arg name=&quot;name&quot;&gt;</span><br><span class="line">&lt;value&gt;戴尔&lt;/value&gt;</span><br><span class="line">&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>虽然<constructor-arg\>的顺序与实体类的属性顺序完全相反，但是通过name一对一绑定，运行结果仍旧为:</constructor-arg\></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Computer&#123;name=&apos;组装机1&apos;, mainEngine=MainEngine&#123;name=&apos;戴尔&apos;, type=&apos;T600&apos;, cost=3600&#125;, display=Display&#123;name=&apos;惠普&apos;, type=&apos;V300&apos;, cost=1000&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="setter方法注入"><a href="#setter方法注入" class="headerlink" title="setter方法注入"></a>setter方法注入</h3><p>setter方法使用<property\>完成依赖注入，如:</property\></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;computer&quot; class=&quot;com.ruanshubin.springboot.ioc.entity.Computer&quot;&gt;</span><br><span class="line">&lt;property name=&quot;name&quot; value=&quot;组装机1&quot;/&gt;</span><br><span class="line">&lt;property name=&quot;mainEngine&quot; ref=&quot;mainEngine&quot;/&gt;</span><br><span class="line">&lt;property name=&quot;display&quot; ref=&quot;display&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>需要指出的是，除了value和ref标签，Spring还提供了bean、idref、value、null、list、set、map、props。</p><p>具体使用场景，本文不做过多介绍，大家可自行Google。</p><h3 id="自动注入autowire"><a href="#自动注入autowire" class="headerlink" title="自动注入autowire"></a>自动注入autowire</h3><p>除了可以通过配置明确指定bean之间的依赖关系，Spirng还提供了根据bean定义的某些特点将相互依赖的某些bean直接自动绑定的功能。通过<bean\> 的autowire属性，可以指定当前bean定义采用某种类型的自动绑定模式。这样，你就无需手工明确指定该bean定义相关的依赖关系，从而也可以免去一些手工输入的工作量。</bean\></p><p>Spring提供了5种自动绑定模式，即 no、byName、byType、constructor和autodetect。</p><ul><li>no</li></ul><p>默认配置，即不采取自动注入，仅依靠手工配置注入。</p><ul><li>byName</li></ul><p>按照类中声明的实例变量的名称，与XML配置文件中声明的bean定义的beanName的值进行匹配，相匹配的bean定义将被自动绑定到当前实例变量上。</p><p>如我们将上面的computer的注入配置修改为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;computer&quot; class=&quot;com.ruanshubin.springboot.ioc.entity.Computer&quot; autowire=&quot;byName&quot;&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>运行结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Computer&#123;name=&apos;null&apos;, mainEngine=MainEngine&#123;name=&apos;戴尔&apos;, type=&apos;T600&apos;, cost=3600&#125;, display=Display&#123;name=&apos;惠普&apos;, type=&apos;V300&apos;, cost=1000&#125;&#125;</span><br></pre></td></tr></table></figure><p>程序会自动寻找id为mainEngine、display的bean来完成注入，因为没有id为name的<bean\>，所以不能自动注入，该项为null。</bean\></p><p>可以修改配置，添加无法自动注入的属性:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;computer&quot; class=&quot;com.ruanshubin.springboot.ioc.entity.Computer&quot; autowire=&quot;byName&quot;&gt;</span><br><span class="line">&lt;property name=&quot;name&quot; value=&quot;组装机1&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>此时，再次运行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Computer&#123;name=&apos;组装机1&apos;, mainEngine=MainEngine&#123;name=&apos;戴尔&apos;, type=&apos;T600&apos;, cost=3600&#125;, display=Display&#123;name=&apos;惠普&apos;, type=&apos;V300&apos;, cost=1000&#125;&#125;</span><br></pre></td></tr></table></figure><ul><li>byType</li></ul><p>与byName类似，byType是按照类中声明的实例变量的Type，与XML配置文件中声明的bean的Type进行匹配，相匹配的bean定义将被自动绑定到当前实例变量上。</p><p>如我们将上面的computer的注入配置修改为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;computer&quot; class=&quot;com.ruanshubin.springboot.ioc.entity.Computer&quot; autowire=&quot;byType&quot;&gt;</span><br><span class="line">&lt;property name=&quot;name&quot; value=&quot;组装机1&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>运行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Computer&#123;name=&apos;组装机1&apos;, mainEngine=MainEngine&#123;name=&apos;戴尔&apos;, type=&apos;T600&apos;, cost=3600&#125;, display=Display&#123;name=&apos;惠普&apos;, type=&apos;V300&apos;, cost=1000&#125;&#125;</span><br></pre></td></tr></table></figure><p>此处有个问题，当某个实例变量的Type在Spring容器中存在两个<bean\>，会选择哪个进行注入呢?</bean\></p><p>假设在上述spring-beans.xml文件中添加如下配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;mainEngine1&quot; class=&quot;com.ruanshubin.springboot.ioc.entity.MainEngine&quot;&gt;</span><br><span class="line">&lt;constructor-arg name=&quot;cost&quot;&gt;</span><br><span class="line">&lt;value&gt;3000&lt;/value&gt;</span><br><span class="line">&lt;/constructor-arg&gt;</span><br><span class="line">&lt;constructor-arg name=&quot;type&quot;&gt;</span><br><span class="line">&lt;value&gt;X900&lt;/value&gt;</span><br><span class="line">&lt;/constructor-arg&gt;</span><br><span class="line">&lt;constructor-arg name=&quot;name&quot;&gt;</span><br><span class="line">&lt;value&gt;神州&lt;/value&gt;</span><br><span class="line">&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>此时，Spring容器里存在2个主机实例，我们仍旧通过byType进行自动注入。</p><p>运行主函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &apos;computer&apos; defined in class path resource [spring-beans.xml]: Unsatisfied dependency expressed through bean property &apos;mainEngine&apos;; nested exception is org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type &apos;com.ruanshubin.springboot.ioc.entity.MainEngine&apos; available: expected single matching bean but found 2: mainEngine,mainEngine1</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>很明显，Spring不会帮你做这个决策，当同一个Type存在多个实例时，程序直接会将错误抛出来，由你来做决策。</p><ul><li>constructor</li></ul><p>constructor类型则是针对构造方法参数的类型而进行的自动绑定，它同样是byType类型的绑定模式。不过，constructor是匹配构造方法的参数类型，而不是实例属性的类型。与byType模式类似，如果找到不止一个符合条件的bean定义，那么，容器会返回错误。</p><ul><li>autodetect</li></ul><p>是byType和constructor模式的结合体，如果对象拥有默认无参数的构造方法，容器会优先考虑byType的自动绑定模式。否则，会使用constructor模式。当然，如果通过构造方法注入绑定后还有其他属性没有绑定，容器也会使用byType对剩余的对象属性进行自动绑定。</p><h3 id="依赖检查及继承"><a href="#依赖检查及继承" class="headerlink" title="依赖检查及继承"></a>依赖检查及继承</h3><h4 id="依赖检查"><a href="#依赖检查" class="headerlink" title="依赖检查"></a>依赖检查</h4><p>检查依赖是否按照预期绑定完成，其由dependency-check标签进行约束，存在以下4种模式:</p><ul><li>none</li></ul><p>不做依赖检查</p><ul><li>simple</li></ul><p>容器会对简单属性类型以及相关的collection进行依赖检查，对象引用类型的依赖除外。</p><ul><li>object</li></ul><p>只对对象引用类型依赖进行检查。</p><ul><li>all</li></ul><p>simple和object的结合体。</p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>新建服务器类，继承自计算机类:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Server extends Computer&#123;</span><br><span class="line">    // 名称</span><br><span class="line">    private String name;</span><br><span class="line">    // 主机</span><br><span class="line">    private MainEngine mainEngine;</span><br><span class="line">    // 显示器</span><br><span class="line">    private Display display;</span><br><span class="line">    // GPU型号</span><br><span class="line">    private String gpuType;</span><br><span class="line"></span><br><span class="line">    public Server() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Server(String name, MainEngine mainEngine, Display display, String gpuType) &#123;</span><br><span class="line">        super(name, mainEngine, display);</span><br><span class="line">        this.gpuType = gpuType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">get/set方法</span><br><span class="line">toString方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在spring-beans.xml配置文件中增加如下内容:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;server&quot; parent=&quot;computer&quot; class=&quot;com.ruanshubin.springboot.ioc.entity.Server&quot;&gt;</span><br><span class="line">&lt;property name=&quot;gpuType&quot; value=&quot;TC800&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>修改启动类:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class IocXmlTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        XmlBeanFactory beanFactory = new XmlBeanFactory(new ClassPathResource(&quot;spring-beans.xml&quot;));</span><br><span class="line">        Server server = beanFactory.getBean(&quot;server&quot;, Server.class);</span><br><span class="line">        System.out.println(server);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Server&#123;name=&apos;组装机1&apos;, mainEngine=MainEngine&#123;name=&apos;戴尔&apos;, type=&apos;T600&apos;, cost=3600&#125;, display=Display&#123;name=&apos;惠普&apos;, type=&apos;V300&apos;, cost=1000&#125;, gpuType=&apos;TC800&apos;&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们通过<strong>parent标签</strong>完成了Bean继承的管理。</p><h2 id="Bean的scope"><a href="#Bean的scope" class="headerlink" title="Bean的scope"></a>Bean的scope</h2><p>Spring2.0前，Bean容器仅有2种作用域类型，即singleton和prototype，2.0后，又引入了3种web相关的scope类型，即request、session、global session。</p><h3 id="singleton"><a href="#singleton" class="headerlink" title="singleton"></a>singleton</h3><ul><li>对象实例</li></ul><p>容器中只存在一个共享实例。</p><ul><li>对象存活时间</li></ul><p>第一次请求被实例化到容器销毁或者退出。</p><h3 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h3><ul><li>对象实例</li></ul><p>容器中存在多个实例。</p><ul><li>对象存活时间</li></ul><p>每次请求即创建1个新的实例，对象实例返回给请求方之后，容器就不再拥有当前返回对象的引用，请求方需要自己负责当前返回对象的后继生命周期的管理工作，包括该对象的销毁。</p><ul><li>request</li></ul><p>Spring容器，即XmlWebApplicationContext会为每个HTTP请求创建一个全新的Request-Processor对象供当前请求使用，当请求结束后，该对象实例的生命周期即告结束。当同时有10个HTTP请求进来的时候，容器会分别针对这10个请求返回10个全新的RequestProcessor 对象实例，且它们之间互不干扰。</p><ul><li>session</li></ul><p>Spring容器会为每个独立的session创建属于它们自己的全新的UserPreferences对象实例。与request相比，除了拥有session scope的bean的实例具有比request scope的bean可能更长的存活时间，其他方面真是没什么差别。</p><ul><li>global session</li></ul><p>global session只有应用在基于portlet的Web应用程序中才有意义，它映射到portlet的global范围的session。如果在普通的基于servlet的Web应用中使用了这个类型的scope，容器会将其作为普通的session类型的scope对待。</p><ul><li>自定义scope</li></ul><p>在Spring 2.0之后的版本中，容器提供了对scope的扩展点，这样，你可以根据自己的需要或者应用的场景，来添加自定义的scope类型。需要说明的是，默认的singleton和prototype是硬编码到代码中的，而request、session和global session，包括自定义scope类型，则属于可扩展的scope行列，它们都实现了org.springframework.beans.factory.config.Scope接口。</p><p>具体如何进行自定义scope的设计开发，以后我们专门写篇文章介绍。</p><p>下面看一个有意思的东西:</p><p>去除掉MainEngine的toString()方法，并将mainEngine的scope设置为prototype。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> &lt;bean id=&quot;mainEngine&quot; class=&quot;com.ruanshubin.springboot.ioc.entity.MainEngine&quot; scope=&quot;prototype&quot;&gt;</span><br><span class="line">&lt;constructor-arg name=&quot;cost&quot;&gt;</span><br><span class="line">&lt;value&gt;3600&lt;/value&gt;</span><br><span class="line">&lt;/constructor-arg&gt;</span><br><span class="line">&lt;constructor-arg name=&quot;type&quot;&gt;</span><br><span class="line">&lt;value&gt;T600&lt;/value&gt;</span><br><span class="line">&lt;/constructor-arg&gt;</span><br><span class="line">&lt;constructor-arg name=&quot;name&quot;&gt;</span><br><span class="line">&lt;value&gt;戴尔&lt;/value&gt;</span><br><span class="line">&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>修改主函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class IocXmlTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        XmlBeanFactory beanFactory = new XmlBeanFactory(new ClassPathResource(&quot;spring-beans.xml&quot;));</span><br><span class="line">        Computer computer = (Computer) beanFactory.getBean(&quot;computer&quot;);</span><br><span class="line">        System.out.println(computer.getMainEngine());</span><br><span class="line">        System.out.println(computer.getMainEngine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.ruanshubin.springboot.ioc.entity.MainEngine@4dfa3a9d</span><br><span class="line">com.ruanshubin.springboot.ioc.entity.MainEngine@4dfa3a9d</span><br></pre></td></tr></table></figure><p>显然，2次获取的MainEngine实例是同一个。</p><p>那么，如何在每次获取MainEngine时，总返回新创建的实例呢，可以使用<lookup-method\>标签:</lookup-method\></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;computer&quot; class=&quot;com.ruanshubin.springboot.ioc.entity.Computer&quot;&gt;</span><br><span class="line">&lt;property name=&quot;name&quot; value=&quot;组装机1&quot;/&gt;</span><br><span class="line">&lt;property name=&quot;mainEngine&quot; ref=&quot;mainEngine&quot;/&gt;</span><br><span class="line">&lt;property name=&quot;display&quot; ref=&quot;display&quot;/&gt;</span><br><span class="line">&lt;lookup-method name=&quot;getMainEngine&quot; bean=&quot;mainEngine&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>再次运行主函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.ruanshubin.springboot.ioc.entity.MainEngine@480bdb19</span><br><span class="line">com.ruanshubin.springboot.ioc.entity.MainEngine@2a556333</span><br></pre></td></tr></table></figure><p>达到目的。</p><p>同时，可以对Computer的getMainEngine进行改造，使其每次从BeanFactory中取MainEngine得实例，操作方法是使Computer实现BeanFactoryAware接口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class Computer implements BeanFactoryAware &#123;</span><br><span class="line"></span><br><span class="line">    private BeanFactory beanFactory;</span><br><span class="line">    </span><br><span class="line">@Override</span><br><span class="line">    public void setBeanFactory(BeanFactory beanFactory) throws BeansException &#123;</span><br><span class="line">        this.beanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    // 名称</span><br><span class="line">    private String name;</span><br><span class="line">    // 主机</span><br><span class="line">    private MainEngine mainEngine;</span><br><span class="line">    // 显示器</span><br><span class="line">    private Display display;</span><br><span class="line"></span><br><span class="line">    public Computer() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Computer(String name, MainEngine mainEngine, Display display) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.mainEngine = mainEngine;</span><br><span class="line">        this.display = display;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public MainEngine getMainEngine() &#123;</span><br><span class="line">        return beanFactory.getBean(&quot;mainEngine&quot;, MainEngine.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMainEngine(MainEngine mainEngine) &#123;</span><br><span class="line">        this.mainEngine = mainEngine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Display getDisplay() &#123;</span><br><span class="line">        return display;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setDisplay(Display display) &#123;</span><br><span class="line">        this.display = display;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，去掉以下配置，运行上述主程序:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;lookup-method name=&quot;getMainEngine&quot; bean=&quot;mainEngine&quot;/&gt;</span><br></pre></td></tr></table></figure><p>运行结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.ruanshubin.springboot.ioc.entity.MainEngine@402a079c</span><br><span class="line">com.ruanshubin.springboot.ioc.entity.MainEngine@59ec2012</span><br></pre></td></tr></table></figure><p>仍然可达到目的。</p><p>当然，如果不想实现BeanFactoryAware接口，也可以采用ObjectFactoryCreatingFactoryBean方式。</p><p>ObjectFactoryCreatingFactoryBean是Spring提供的一个FactoryBean实现，它返回一个ObjectFactory实例。从ObjectFactoryCreatingFactoryBean返回的这个ObjectFactory实例可以为我们返回容器管理的相关对象。</p><p>首先，在spring-beans.xml里配置ObjectFactoryCreatingFactoryBean，并注入主机类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;objectFactory&quot; class=&quot;org.springframework.beans.factory.config.ObjectFactoryCreatingFactoryBean&quot;&gt;</span><br><span class="line">&lt;property name=&quot;targetBeanName&quot;&gt;</span><br><span class="line">&lt;idref bean=&quot;mainEngine&quot;/&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;computer&quot; class=&quot;com.ruanshubin.springboot.ioc.entity.Computer&quot;&gt;</span><br><span class="line">&lt;property name=&quot;name&quot; value=&quot;组装机1&quot;/&gt;     </span><br><span class="line">&lt;property name=&quot;display&quot; ref=&quot;display&quot;/&gt;</span><br><span class="line">&lt;property name=&quot;objectFactory&quot;&gt;</span><br><span class="line">&lt;ref bean=&quot;objectFactory&quot;/&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>同时修改Computer类:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class Computer&#123;</span><br><span class="line"></span><br><span class="line">    private ObjectFactory objectFactory;</span><br><span class="line"></span><br><span class="line">    public void setObjectFactory(ObjectFactory objectFactory) &#123;</span><br><span class="line">        this.objectFactory = objectFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 名称</span><br><span class="line">    private String name;</span><br><span class="line">    // 主机</span><br><span class="line">    private MainEngine mainEngine;</span><br><span class="line">    // 显示器</span><br><span class="line">    private Display display;</span><br><span class="line"></span><br><span class="line">    public Computer() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Computer(String name, MainEngine mainEngine, Display display) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.mainEngine = mainEngine;</span><br><span class="line">        this.display = display;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public MainEngine getMainEngine() &#123;</span><br><span class="line">        return (MainEngine) objectFactory.getObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMainEngine(MainEngine mainEngine) &#123;</span><br><span class="line">        this.mainEngine = mainEngine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Display getDisplay() &#123;</span><br><span class="line">        return display;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setDisplay(Display display) &#123;</span><br><span class="line">        this.display = display;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.ruanshubin.springboot.ioc.entity.MainEngine@5cb9f472</span><br><span class="line">com.ruanshubin.springboot.ioc.entity.MainEngine@56ef9176</span><br></pre></td></tr></table></figure><p>写着写着就写多了，更多Spring-IOC容器XML配置的东西，我们后面有机会再讲。</p><p><img src="https://upload-images.jianshu.io/upload_images/10431632-a592bb9d7a331a0a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="行走的思想者"></p><p>欢迎您扫一扫上面的二维码，关注我的微信公众号！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;在Springboot编程实践中，我们偏向使用注解的方式进行Bean的注册和依赖注入等，但XML格式的容器信息管理方式仍是Spring提供的
      
    
    </summary>
    
      <category term="Spring" scheme="http://ruanshubin.top/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://ruanshubin.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring容器之BeanFactory</title>
    <link href="http://ruanshubin.top/2019/06/04/Spring%E5%AE%B9%E5%99%A8%E4%B9%8BBeanFactory/"/>
    <id>http://ruanshubin.top/2019/06/04/Spring容器之BeanFactory/</id>
    <published>2019-06-04T13:08:00.000Z</published>
    <updated>2019-09-16T01:37:16.330Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Spring提供了两种容器类型:</p><ul><li>BeanFactory</li><li>ApplicationContext</li></ul><p>其中ApplicationContext间接继承自BeanFactory，两者最大的不同是容器初始化策略。</p><p><img src="https://upload-images.jianshu.io/upload_images/10431632-2f02b4786e216d53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>BeanFactory采用懒加载(lazy-load)策略，即当客户端需要访问容器内的某个对象时，才对该对象进行初始化以及依赖注入操作。所以该模式下，启动速度较快，适用于资源有限，对功能要求不是很严格的场景。</p><p>ApplicationContext所管理的对象，默认启动之后全部初始化并绑定完成，故启动速度较慢，但其除了拥有BeanFactory的所有支持，还提供事件发布、国际化信息支持等，所以适用于系统资源充足，并且要求更多功能的场景。</p><p><strong>本文首先讲解BeanFactory。</strong></p><h2 id="BeanFactory、BeanDefinitionRegistry和Bean的关系"><a href="#BeanFactory、BeanDefinitionRegistry和Bean的关系" class="headerlink" title="BeanFactory、BeanDefinitionRegistry和Bean的关系"></a>BeanFactory、BeanDefinitionRegistry和Bean的关系</h2><p>BeanFactory主要完成2项工作:</p><ul><li>业务对象的初始化及注册；</li><li>对象间依赖关系的绑定。</li></ul><p>看一下BeanFactory的源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public interface BeanFactory &#123;</span><br><span class="line">    String FACTORY_BEAN_PREFIX = &quot;&amp;&quot;;</span><br><span class="line"></span><br><span class="line">    Object getBean(String var1) throws BeansException;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; T getBean(String var1, @Nullable Class&lt;T&gt; var2) throws BeansException;</span><br><span class="line"></span><br><span class="line">    Object getBean(String var1, Object... var2) throws BeansException;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; T getBean(Class&lt;T&gt; var1) throws BeansException;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; T getBean(Class&lt;T&gt; var1, Object... var2) throws BeansException;</span><br><span class="line"></span><br><span class="line">    boolean containsBean(String var1);</span><br><span class="line"></span><br><span class="line">    boolean isSingleton(String var1) throws NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line">    boolean isPrototype(String var1) throws NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line">    boolean isTypeMatch(String var1, ResolvableType var2) throws NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line">    boolean isTypeMatch(String var1, @Nullable Class&lt;?&gt; var2) throws NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    Class&lt;?&gt; getType(String var1) throws NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line">    String[] getAliases(String var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，BeanFactory接口只定义了查询相关的方法，例如: 取得某个对象的方法（getBean）、查询某个对象是否存在于容器中的方法（containsBean），或者取得某个bean的状态或者类型的方法等。</p><p>而对象的注册管理及依赖绑定则交给BeanFactory的接口实现类来完成，如常见的DefaultListableBeanFactory。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class DefaultListableBeanFactory </span><br><span class="line">extends AbstractAutowireCapableBeanFactory </span><br><span class="line">implements ConfigurableListableBeanFactory, BeanDefinitionRegistry, Serializable &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DefaultListableBeanFactory还实现了BeanDefinitionRegistry接口，来完成Bean的注册管理。</p><p>简单阐释一下BeanFactory、BeanDefinitionRegistry和Bean的关系：</p><p>Bean是图书，BeanFactory相当于图书馆，而BeanDefinitionRegistry则相当于图书馆的书架。虽然还书和借书均是跟图书馆(BeanFactory)打交道，但是图书馆实际存储书的地方是书架(BeanDefinitionRegistry)。</p><p>每个Bean交给BeanFactory管理时，均会包装成BeanDefination接口的实例，BeanDefination实例负责保存Bean所有必要的信息，包括Class类型、是否是抽象类、构造方法参数及其他属性等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">public interface BeanDefinition extends AttributeAccessor, BeanMetadataElement &#123;</span><br><span class="line">    String SCOPE_SINGLETON = &quot;singleton&quot;;</span><br><span class="line">    String SCOPE_PROTOTYPE = &quot;prototype&quot;;</span><br><span class="line">    int ROLE_APPLICATION = 0;</span><br><span class="line">    int ROLE_SUPPORT = 1;</span><br><span class="line">    int ROLE_INFRASTRUCTURE = 2;</span><br><span class="line"></span><br><span class="line">    void setParentName(@Nullable String var1);</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    String getParentName();</span><br><span class="line"></span><br><span class="line">    void setBeanClassName(@Nullable String var1);</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    String getBeanClassName();</span><br><span class="line"></span><br><span class="line">    void setScope(@Nullable String var1);</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    String getScope();</span><br><span class="line"></span><br><span class="line">    void setLazyInit(boolean var1);</span><br><span class="line"></span><br><span class="line">    boolean isLazyInit();</span><br><span class="line"></span><br><span class="line">    void setDependsOn(@Nullable String... var1);</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    String[] getDependsOn();</span><br><span class="line"></span><br><span class="line">    void setAutowireCandidate(boolean var1);</span><br><span class="line"></span><br><span class="line">    boolean isAutowireCandidate();</span><br><span class="line"></span><br><span class="line">    void setPrimary(boolean var1);</span><br><span class="line"></span><br><span class="line">    boolean isPrimary();</span><br><span class="line"></span><br><span class="line">    void setFactoryBeanName(@Nullable String var1);</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    String getFactoryBeanName();</span><br><span class="line"></span><br><span class="line">    void setFactoryMethodName(@Nullable String var1);</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    String getFactoryMethodName();</span><br><span class="line"></span><br><span class="line">    ConstructorArgumentValues getConstructorArgumentValues();</span><br><span class="line"></span><br><span class="line">    default boolean hasConstructorArgumentValues() &#123;</span><br><span class="line">        return !this.getConstructorArgumentValues().isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MutablePropertyValues getPropertyValues();</span><br><span class="line"></span><br><span class="line">    default boolean hasPropertyValues() &#123;</span><br><span class="line">        return !this.getPropertyValues().isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boolean isSingleton();</span><br><span class="line"></span><br><span class="line">    boolean isPrototype();</span><br><span class="line"></span><br><span class="line">    boolean isAbstract();</span><br><span class="line"></span><br><span class="line">    int getRole();</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    String getDescription();</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    String getResourceDescription();</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    BeanDefinition getOriginatingBeanDefinition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RootBeanDefinition和ChildBeanDefinition是BeanDefinition的两个主要实现类。</p><p><img src="https://upload-images.jianshu.io/upload_images/10431632-75998e61a573ee13.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="BeanFactory的对象注册与依赖绑定方式"><a href="#BeanFactory的对象注册与依赖绑定方式" class="headerlink" title="BeanFactory的对象注册与依赖绑定方式"></a>BeanFactory的对象注册与依赖绑定方式</h2><p>假设我们有一家饭店，需要有蔬菜采购和厨师做菜，则Restaurant类定义如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Restaurant &#123;</span><br><span class="line">    // 厨师</span><br><span class="line">    private Chef chef;</span><br><span class="line">    // 蔬菜</span><br><span class="line">    private Vegetable vegetable;</span><br><span class="line"></span><br><span class="line">    构造方法...</span><br><span class="line">get/set方法...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>蔬菜存在多种，我们抽象出Vegetable接口，并存在购买行为。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Vegetable &#123;</span><br><span class="line">    public String buy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写2个Vegetable接口的实现类Tomato、Cabbage:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Tomato implements Vegetable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String buy() &#123;</span><br><span class="line">        System.out.println(&quot;采购员买来了番茄!&quot;);</span><br><span class="line">        return &quot;Tomato&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Cabbage implements Vegetable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String buy() &#123;</span><br><span class="line">        System.out.println(&quot;采购员买来了卷心菜!&quot;);</span><br><span class="line">        return &quot;Cabbage&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>厨师也可能有多种，抽象出Chef接口如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Chef &#123;</span><br><span class="line">    public void cook(String vegetableName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并编写2个Chef的实现类:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class ChineseChef implements Chef &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void cook(String vegetableName) &#123;</span><br><span class="line">        System.out.println(&quot;中国厨师正在做&quot; + vegetableName + &quot;!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ForeignChef implements Chef &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void cook(String vegetableName) &#123;</span><br><span class="line">        System.out.println(&quot;外国厨师正在做&quot; + vegetableName + &quot;!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设我们现在要开这样一家饭店，需要中国厨师和番茄，那么如何完成对象的注册管理和依赖绑定呢?</p><h3 id="直接编码形式"><a href="#直接编码形式" class="headerlink" title="直接编码形式"></a>直接编码形式</h3><p>所谓直接编码形式，即用Spring的底层容器类来进行Bean的注册和管理，虽然不常用，但却有助于我们了解Spring的IOC是如何运作的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        DefaultListableBeanFactory beanRegistry = new DefaultListableBeanFactory();</span><br><span class="line">        BeanFactory container = bindViaCode(beanRegistry);</span><br><span class="line">        // 测试Bean的装配</span><br><span class="line">        Restaurant chineseRestaurant = (Restaurant) container.getBean(&quot;chineseRestaurant&quot;);</span><br><span class="line">        Vegetable vegetable = chineseRestaurant.getVegetable();</span><br><span class="line">        String vegetableName = vegetable.buy();</span><br><span class="line">        Chef chef = chineseRestaurant.getChef();</span><br><span class="line">        chef.cook(vegetableName);</span><br><span class="line">        // 测试Bean的管理</span><br><span class="line">        Chef chef1 = (Chef) container.getBean(&quot;chineseChef&quot;);</span><br><span class="line">        chef1.cook(&quot;干锅花菜&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static BeanFactory bindViaCode(BeanDefinitionRegistry registry)&#123;</span><br><span class="line">        AbstractBeanDefinition restaurant = new RootBeanDefinition(Restaurant.class);</span><br><span class="line">        AbstractBeanDefinition chef = new RootBeanDefinition(ChineseChef.class);</span><br><span class="line">        AbstractBeanDefinition vegetable = new RootBeanDefinition(Tomato.class);</span><br><span class="line">        // 将Bean注册到容器中</span><br><span class="line">        registry.registerBeanDefinition(&quot;chineseRestaurant&quot;, restaurant);</span><br><span class="line">        registry.registerBeanDefinition(&quot;chineseChef&quot;, chef);</span><br><span class="line">        registry.registerBeanDefinition(&quot;tomato&quot;, vegetable);</span><br><span class="line">        // 1. 指定依赖关系(构造方法注入)</span><br><span class="line">        ConstructorArgumentValues argValues = new ConstructorArgumentValues();</span><br><span class="line">        argValues.addIndexedArgumentValue(0, chef);</span><br><span class="line">        argValues.addIndexedArgumentValue(1, vegetable);</span><br><span class="line">        restaurant.setConstructorArgumentValues(argValues);</span><br><span class="line">        // 2. 指定依赖关系(setter方法注入)</span><br><span class="line">        MutablePropertyValues propertyValues = new MutablePropertyValues();</span><br><span class="line">        propertyValues.addPropertyValue(new PropertyValue(&quot;chef&quot;, chef));</span><br><span class="line">        propertyValues.addPropertyValue(new PropertyValue(&quot;vegetable&quot;, vegetable));</span><br><span class="line">        restaurant.setPropertyValues(propertyValues);</span><br><span class="line">        // 绑定完成</span><br><span class="line">        return (BeanFactory) registry;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">采购员买来了番茄!</span><br><span class="line">中国厨师正在做Tomato!</span><br><span class="line">中国厨师正在做干锅花菜!</span><br></pre></td></tr></table></figure><h3 id="外部配置文件形式"><a href="#外部配置文件形式" class="headerlink" title="外部配置文件形式"></a>外部配置文件形式</h3><p>其实就是将Bean的依赖关系放在配置文件中，然后Spring解析配置文件，得到各对象的依赖关系，进而完成对象的注册和依赖管理。</p><p>整体的流程如下:</p><ol><li>BeanDefinitionReader实现类读取配置文件内容，并映射得到待管理Bean的BeanDefinition;</li><li>BeanDefinitionReader根据配置文件内容定义的依赖关系，通过BeanDefinition指定Bean之间的依赖关系;</li><li>将映射后的BeanDefinition注册到BeanDefinitionRegistry中。</li></ol><p>上述大部分的工作，如解析文件格式、装配BeanDefinition之类的工作，均由BeanDefinitionReader实现类来完成，BeanDefinitionRegistry仅是负责Bean的保管而已。</p><p>整个过程类似于如下代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BeanDefinitionRegistry beanRegistry = &lt;某个 BeanDefinitionRegistry 实现类，通常为DefaultListableBeanFactory&gt;;</span><br><span class="line">BeanDefinitionReader beanDefinitionReader = new BeanDefinitionReaderImpl(beanRegistry);</span><br><span class="line">beanDefinitionReader.loadBeanDefinitions(&quot;配置文件路径&quot;);</span><br><span class="line">// 现在我们就取得了一个可用的BeanDefinitionRegistry实例</span><br></pre></td></tr></table></figure><p>看一下BeanDefinitionReader：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public interface BeanDefinitionReader &#123;</span><br><span class="line">    BeanDefinitionRegistry getRegistry();</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    ResourceLoader getResourceLoader();</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    ClassLoader getBeanClassLoader();</span><br><span class="line"></span><br><span class="line">    BeanNameGenerator getBeanNameGenerator();</span><br><span class="line"></span><br><span class="line">    int loadBeanDefinitions(Resource var1) throws BeanDefinitionStoreException;</span><br><span class="line"></span><br><span class="line">    int loadBeanDefinitions(Resource... var1) throws BeanDefinitionStoreException;</span><br><span class="line"></span><br><span class="line">    int loadBeanDefinitions(String var1) throws BeanDefinitionStoreException;</span><br><span class="line"></span><br><span class="line">    int loadBeanDefinitions(String... var1) throws BeanDefinitionStoreException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，BeanDefinitionReader通过getRegistry()获取BeanDefinitionRegistry，getResourceLoader()加载配置文件资源用于解析Bean的注册和依赖关系，getBeanClassLoader()获取类加载器用于类的加载，loadBeanDefinitions(..)方法主要运用反射将待管理的Bean封装成BeanDefinition，最后注册到BeanDefinitionRegistry中。</p><p><img src="https://upload-images.jianshu.io/upload_images/10431632-0ba6413fc1f28afd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>由上图可以看出，Spring的IOC容器默认支持3种文件格式:</p><ul><li>Properties文件格式</li><li>XML文件格式</li><li>Groovy文件格式</li></ul><p>本文主要讨论前2种文件格式:</p><h4 id="Properties文件"><a href="#Properties文件" class="headerlink" title="Properties文件"></a>Properties文件</h4><p>首先在resources目录下创建beans.properties文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># bean的name.(class)=实现类的全路径</span><br><span class="line">chef.(class)=com.ruanshubin.springboot.ioc.service.impl.ChineseChef</span><br><span class="line">vegetable.(class)=com.ruanshubin.springboot.ioc.service.impl.Tomato</span><br><span class="line">restaurant.(class)=com.ruanshubin.springboot.ioc.domain.Restaurant</span><br><span class="line"># 通过构造方法注入</span><br><span class="line">restaurant.$0(ref)=chef</span><br><span class="line">restaurant.$1(ref)=vegetable</span><br><span class="line"># 通过setter方法注入</span><br><span class="line"># restaurant.setChef(ref)=chef</span><br><span class="line"># restaurant.setVegetable(ref)=vegetable</span><br></pre></td></tr></table></figure><p>然后编写主函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class FileTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        DefaultListableBeanFactory beanRegistry = new DefaultListableBeanFactory();</span><br><span class="line">        BeanFactory container = bindViaPropertiesFile(beanRegistry);</span><br><span class="line">        // 测试Bean的装配</span><br><span class="line">        Restaurant chineseRestaurant = (Restaurant) container.getBean(&quot;restaurant&quot;);</span><br><span class="line">        Vegetable vegetable = chineseRestaurant.getVegetable();</span><br><span class="line">        String vegetableName = vegetable.buy();</span><br><span class="line">        Chef chef = chineseRestaurant.getChef();</span><br><span class="line">        chef.cook(vegetableName);</span><br><span class="line">        // 测试Bean的管理</span><br><span class="line">        Chef chef1 = (Chef) container.getBean(&quot;chef&quot;);</span><br><span class="line">        chef1.cook(&quot;蒜蓉空心菜!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static BeanFactory bindViaPropertiesFile(BeanDefinitionRegistry registry)&#123;</span><br><span class="line">        PropertiesBeanDefinitionReader reader = new PropertiesBeanDefinitionReader(registry);</span><br><span class="line">        reader.loadBeanDefinitions(&quot;classpath:beans.properties&quot;);</span><br><span class="line">        return (BeanFactory) registry;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">采购员买来了番茄!</span><br><span class="line">中国厨师正在做Tomato!</span><br><span class="line">中国厨师正在做蒜蓉空心菜!</span><br></pre></td></tr></table></figure><h4 id="XML文件"><a href="#XML文件" class="headerlink" title="XML文件"></a>XML文件</h4><p>XML配置格式是Spring支持最完整，功能最强大的表达方式，主要得益于:</p><ul><li>XML良好的语意表达能力；</li><li>Spring框架从开始就自始至终保持XML配置加载的统一性。</li></ul><p>Spring 2.x之前，XML配置文件采用DTD（Document Type Definition）实现文档的格式约束。2.x之后，引入了基于XSD（XML Schema Definition）的约束方式。不过，原来的基于DTD的方式依然有效，因为从DTD转向XSD只是“形式”上的转变。</p><p>首先在resources目录下创建beans.xml文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE beans PUBLIC &quot;-//SPRING//DTD BEAN//EN&quot;</span><br><span class="line">        &quot;http://www.springframework.org/dtd/spring-beans.dtd&quot;&gt;</span><br><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;bean id=&quot;restaurant&quot; class=&quot;com.ruanshubin.springboot.ioc.domain.Restaurant&quot;&gt;</span><br><span class="line">        &lt;constructor-arg index=&quot;0&quot;&gt;</span><br><span class="line">            &lt;ref bean=&quot;chef&quot;/&gt;</span><br><span class="line">        &lt;/constructor-arg&gt;</span><br><span class="line">        &lt;constructor-arg index=&quot;1&quot;&gt;</span><br><span class="line">            &lt;ref bean=&quot;vegetable&quot;/&gt;</span><br><span class="line">        &lt;/constructor-arg&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;chef&quot; class=&quot;com.ruanshubin.springboot.ioc.service.impl.ForeignChef&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;vegetable&quot; class=&quot;com.ruanshubin.springboot.ioc.service.impl.Cabbage&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>主函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class FileTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        DefaultListableBeanFactory beanRegistry = new DefaultListableBeanFactory();</span><br><span class="line">        BeanFactory container = bindViaXmlFile(beanRegistry);</span><br><span class="line">        // 测试Bean的装配</span><br><span class="line">        Restaurant chineseRestaurant = (Restaurant) container.getBean(&quot;restaurant&quot;);</span><br><span class="line">        Vegetable vegetable = chineseRestaurant.getVegetable();</span><br><span class="line">        String vegetableName = vegetable.buy();</span><br><span class="line">        Chef chef = chineseRestaurant.getChef();</span><br><span class="line">        chef.cook(vegetableName);</span><br><span class="line">        // 测试Bean的管理</span><br><span class="line">        Chef chef1 = (Chef) container.getBean(&quot;chef&quot;);</span><br><span class="line">        chef1.cook(&quot;法式焗蜗牛&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static BeanFactory bindViaXmlFile(BeanDefinitionRegistry registry)&#123;</span><br><span class="line">        XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(registry);</span><br><span class="line">        reader.loadBeanDefinitions(&quot;classpath:beans.xml&quot;);</span><br><span class="line">        return (BeanFactory) registry;</span><br><span class="line">// 或者直接如下:</span><br><span class="line">        // return new XmlBeanFactory(new ClassPathResource(&quot;beans.xml&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">采购员买来了卷心菜!</span><br><span class="line">外国厨师正在做Cabbage!</span><br><span class="line">外国厨师正在做法式焗蜗牛!</span><br></pre></td></tr></table></figure><p>当然，如果你想使用其他格式的配置文件来进行Bean的注册和依赖管理，可以实现自定义的BeanDefinitionReader来达到自定义文件加载的目的。</p><h3 id="注解形式"><a href="#注解形式" class="headerlink" title="注解形式"></a>注解形式</h3><p>基于注解的方式，主要是通过@Autowired及@Component对相关类进行标记，然后通过AbstractApplicationContext借助classpath-scanning功能来完成Bean的注册和依赖管理。</p><p><img src="https://upload-images.jianshu.io/upload_images/10431632-029d5f6e090a5f82.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>首先为相关类添加注解:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class Restaurant &#123;</span><br><span class="line">    // 厨师</span><br><span class="line">    @Autowired</span><br><span class="line">    private Chef chef;</span><br><span class="line">    // 蔬菜</span><br><span class="line">    @Autowired</span><br><span class="line">    private Vegetable vegetable;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class Tomato implements Vegetable &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class ChineseChef implements Chef &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Autowired用于依赖注入，@Component用于Bean注册，接下来配置注解扫描。</p><p>在resources目录下新建spring.xml:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">        xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</span><br><span class="line">        http://www.springframework.org/schema/context</span><br><span class="line">        http://www.springframework.org/schema/context/spring-context-2.5.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;context:component-scan base-package=&quot;com.ruanshubin.springboot.ioc&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p><context:component-scan> 会到指定的包（package）下面扫描标注有@Component的类，如果找到，则将它们添加到容器进行管理，并根据它们所标注的@Autowired为这些类注入符合条件的依赖对象。</context:component-scan></p><p>主函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class AnnotationTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);</span><br><span class="line">        Restaurant chineseRestaurant = (Restaurant) ctx.getBean(&quot;restaurant&quot;);</span><br><span class="line">        Vegetable vegetable = chineseRestaurant.getVegetable();</span><br><span class="line">        String vegetableName = vegetable.buy();</span><br><span class="line">        Chef chef = chineseRestaurant.getChef();</span><br><span class="line">        chef.cook(vegetableName);</span><br><span class="line">        // 测试Bean的管理</span><br><span class="line">        Chef chef1 = (Chef) ctx.getBean(&quot;chineseChef&quot;);</span><br><span class="line">        chef1.cook(&quot;鸡蛋韭菜水饺&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">采购员买来了番茄!</span><br><span class="line">中国厨师正在做Tomato!</span><br><span class="line">中国厨师正在做鸡蛋韭菜水饺!</span><br></pre></td></tr></table></figure><p>我们再配置Bean时，只是在实体类上加了@Component注解，并没有指定Bean的id或name，ApplicationContext默认采用实体类的小驼峰作为id，如ChineseChef的id为chineseChef，Tomato的id为tomato。</p><p>同时，在配置Bean依赖时，@Autowired加在接口之上，如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private Chef chef;</span><br></pre></td></tr></table></figure><p>由于我们只在ChineseChef添加了@Component注解，所以Spring容器里只有1个Chef的实现类，此时，ApplicationContext直接将ChineseChef注入到Restaurant中。</p><p>假如Spring容器里有2个Chef的实现类.会出现什么情况呢?</p><p>只需要在ForeignChef上添加@Component即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class ForeignChef implements Chef &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新运行主函数，报错:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &apos;restaurant&apos;: Unsatisfied dependency expressed through field &apos;chef&apos;; nested exception is org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type &apos;com.ruanshubin.springboot.ioc.service.Chef&apos; available: expected single matching bean but found 2: chineseChef,foreignChef</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>错误信息很明显，说进行Restaurant依赖注入的时候，发现Chef接口有2个实现类:chineseChef、foreignChef，程序不知道该选择哪个进行注入。</p><p>解决上述错误的方式有很多，后面我们专门用1篇文章进行讲解。</p><p><strong>参考文献:</strong></p><ol><li>王福强. Spring揭秘[M]. 2009.</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/10431632-86426e609c966a5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>欢迎您扫一扫上面的二维码，关注我的微信公众号！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;Spring提供了两种容器类型:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BeanFactory&lt;/li&gt;
&lt;li&gt;ApplicationContext&lt;
      
    
    </summary>
    
      <category term="Spring" scheme="http://ruanshubin.top/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://ruanshubin.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程-valatile关键字</title>
    <link href="http://ruanshubin.top/2019/05/28/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-valatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://ruanshubin.top/2019/05/28/Java并发编程-valatile关键字/</id>
    <published>2019-05-28T09:16:00.000Z</published>
    <updated>2019-09-16T01:37:16.305Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>很久之前就想写volatile关键字，但是迟迟没有动笔，主要是volatile涉及到的东西有点多，讲不清楚倒还好，就怕反而把读者绕晕了，哈哈。</p><p>volatile关键字是为了保证内存可见性及有序性的，首先介绍并发编程中涉及到的3个问题:</p><h2 id="并发编程规则"><a href="#并发编程规则" class="headerlink" title="并发编程规则"></a>并发编程规则</h2><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>原子具有不可分割性，所谓原子性，指的是一个或多个操作，要么全部执行且执行过程不会被任何因素打断，要么就全部执行，其与事务的语义是一致的。</p><p>比如经典的转账问题:</p><p>小明给小强转账1000元，该操作分为2步:</p><ol><li>小明的账户减少1000元；</li><li>小强的账户增加1000元。</li></ol><p>如果上述操作是非原子的，假如步骤1执行成功，而步骤2则异常中断，此时就会造成小明平白无故丢失了1000元。</p><p>在Java中，主要通过synchronized关键字、Lock接口来实现多个操作的原子性。</p><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>所谓可见性，指的<strong>线程之间的可见性，一个线程修改的状态对另外的线程是可见的。</strong></p><p>在Java中valatile、synchronized和final实现了可见性。</p><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p><strong>即程序执行的顺序按照代码的先后顺序执行。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int i = 0;</span><br><span class="line">boolean flag = false;</span><br><span class="line">i =1; // 语句1</span><br><span class="line">flag = true; // 语句2</span><br></pre></td></tr></table></figure><p>程序本来就是按照代码顺序来执行的呀，为啥还要保证？一切因为<strong>指令重排序(Instruction Reorder)</strong>的存在。</p><p>处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。</p><p>也就是说，语句2可能会在语句1之前执行。</p><p>接着看下面的操作:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a = 6; // 语句1</span><br><span class="line">int b = 2; // 语句2</span><br><span class="line">a = a + 3; // 语句3</span><br><span class="line">b = a * a; // 语句4</span><br></pre></td></tr></table></figure><p>现在问题来了，语句4可能在语句3之前执行吗?</p><p>答案是不可能，因为指令重排序会分析语句间的<strong>数据依赖性</strong>，假设语句B依赖于语句A，即语句B需要使用语句A的结果，则不会发生指令重排序。</p><p>所以，单线程环境下，指令重排序只是为了提高运行速度，并不会影响运算结果，但多线程环境下呢，看以下语句:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//线程1:</span><br><span class="line">context = loadContext();   //语句1</span><br><span class="line">inited = true;             //语句2</span><br><span class="line"></span><br><span class="line">//线程2:</span><br><span class="line">while(!inited )&#123;</span><br><span class="line">  sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure><p>上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。</p><p>在Java中synchronized、Lock、volatile实现了有序性。</p><p>volatile关键字是与Java内存模型紧密相关的，所以我们先简单讲解一下Java的内存模型。</p><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p>众所周知，CPU在执行程序指令的过程中，势必涉及到数据的读取和存入，运行过程中的中间数据存储在<strong>物理内存</strong>中。</p><p>物理内存的数据存取速度和CPU的运行速度相比，基本等同于蜗牛和波音747，所以高速缓存出现了。</p><p>高速缓存的速度虽然还是比不上CPU，但是比物理内存(主内存)还是要快多了。</p><p>所以程序进行计算时，会将需要用到的数据先从主内存取到高速缓存中，然后CPU从高速缓存中取数据进行计算，计算的中间结果存入高速缓存，计算结束后将结果由高速缓存刷新到主内存。</p><p><img src="https://upload-images.jianshu.io/upload_images/10431632-7e53de60b44adc18.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>上述模式在单线程环境下没有问题，但是多线程下可能就会出问题，比如简单的i++操作:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i=0;</span><br><span class="line">i++;</span><br></pre></td></tr></table></figure><p>假设线程A和线程B分别执行了i++操作，理论上最终结果应该为2，但实际上也可能为1。</p><p>原因是i++操作实际上分为2步:</p><ol><li>将主内存中i的值取到高速缓存；</li><li>CPU从高速缓存取出i，完成+1操作后，存入高速缓存，并刷新到主内存。</li></ol><p>如果线程A和B同时执行了步骤1，此时线程A和B的高速缓存中的值均为0，完成+1操作后分别刷新到主内存中，最终结果为1，即出现了缓存一致性问题。</p><p>为解决缓存一致性问题，一般采取两种方式：</p><ul><li>在总线上加LOCK#锁；</li><li>缓存一致性协议。</li></ul><p>上述两种方式均是基于硬件指令实现的。</p><p>在早期的CPU当中，是通过在总线上加LOCK#锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i = i +1，如果在执行这段代码的过程中，在总线上发出了LCOK#锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。</p><p>但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。</p><p>所以就出现了缓存一致性协议。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</p><p><img src="https://upload-images.jianshu.io/upload_images/10431632-aecea6b78e03f74c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>Java内存模型具备一些先天的有序性，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为happens-before原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。</p><p>happens-before原则主要包括:</p><ul><li><p>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作。</p></li><li><p>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作。</p></li><li><p>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作。</p></li><li><p>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C。</p></li><li><p>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作。</p></li><li><p>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生。</p></li><li><p>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行。</p></li><li><p>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始。</p></li></ul><p>后4项原则是必然的，具体看一下前4项。</p><p><strong>程序次序规则保证了单线程环境下，指令重排序不会影响运行结果。</strong></p><p><strong>锁定规则也很显然，当某线程获取对象锁之前，必须先等待其他线程释放锁。</strong></p><p><strong>volatile变量规则指的是如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。</strong></p><p><strong>传递规则实际上就是体现happens-before原则具备传递性。</strong></p><p>介绍了并发编程规则及Java的内存模型，下面我们深入分析一下volatile关键字:</p><h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><h3 id="基本语义"><a href="#基本语义" class="headerlink" title="基本语义"></a>基本语义</h3><ul><li>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</li><li>禁止进行指令重排序。</li></ul><p>第1个语义不多讲，其与缓存一致性协议基本类似，下面看一下第2个语义：</p><p>还是沿用上面的例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//线程1:</span><br><span class="line">context = loadContext();   //语句1</span><br><span class="line">volatile inited = true;    //语句2</span><br><span class="line"></span><br><span class="line">//线程2:</span><br><span class="line">while(!inited )&#123;</span><br><span class="line">  sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure><p>inited由volatile修饰后，则语句1和语句2不会发生重排序，保证inited = true时，运行上下文context必定加载完毕，从而避免了上述多线程下的运行异常。</p><h3 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h3><p>下面这段话摘自《深入理解Java虚拟机》：</p><blockquote><p>观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令。</p></blockquote><p>lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：</p><ul><li><p>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</p></li><li><p>它会强制将对缓存的修改操作立即写入主存；</p></li><li><p>如果是写操作，它会导致其他CPU中对应的缓存行无效。</p></li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>状态变量</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//线程1:</span><br><span class="line">context = loadContext();   //语句1</span><br><span class="line">volatile inited = true;    //语句2</span><br><span class="line"></span><br><span class="line">//线程2:</span><br><span class="line">while(!inited )&#123;</span><br><span class="line">  sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure><ul><li>单例模式的双重校验</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private Singleton() &#123; &#125;</span><br><span class="line">    private volatile static Singleton instance;</span><br><span class="line">    public Singleton getInstance()&#123;</span><br><span class="line">        if(instance==null)&#123;</span><br><span class="line">            synchronized (Singleton.class)&#123;</span><br><span class="line">                if(instance==null)&#123;</span><br><span class="line">                    instance = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之所以instance需要使用volatile修饰，是因为下述语句可能会发生指令重排序:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instance = new Singleton();</span><br></pre></td></tr></table></figure><p>上述操作分为2步:</p><ol><li>初始化对象；</li><li>将对象指针赋给instance。</li></ol><p>假设步骤1、2发生了重排序，即步骤2在步骤1之前执行，当其他读取线程进行单例读取时，此时步骤2已执行完成，读取线程判断instance非null，故进行读取，但此时步骤1可能还未完成，即对象还未初始化完成，从而导致读取线程发生异常。</p><p>instance添加volatile关键字后，步骤1和2禁止指令重排序，从而避免了上述问题。</p><ul><li>ConcurrentHashMap</li></ul><p>volatile关键字在ConcurrentHashMap中的应用，可以参见我的另外一篇文章:</p><p><a href="https://www.jianshu.com/p/7be6ef36c4dd" target="_blank" rel="noopener">ConcurrentHashMap揭秘-JDK1.7</a></p><p><strong>参考文献：</strong></p><ol><li><a href="https://www.cnblogs.com/zhengbin/p/5654805.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhengbin/p/5654805.html</a></li><li><a href="https://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3920373.html</a></li><li><a href="https://blog.csdn.net/u013412772/article/details/80109727" target="_blank" rel="noopener">https://blog.csdn.net/u013412772/article/details/80109727</a></li></ol><p><img src="https://upload-images.jianshu.io/upload_images/10431632-86426e609c966a5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>欢迎您扫一扫上面的二维码，关注我的微信公众号！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;很久之前就想写volatile关键字，但是迟迟没有动笔，主要是volatile涉及到的东西有点多，讲不清楚倒还好，就怕反而把读者绕晕了，哈哈
      
    
    </summary>
    
      <category term="并发编程" scheme="http://ruanshubin.top/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://ruanshubin.top/tags/Java/"/>
    
      <category term="并发" scheme="http://ruanshubin.top/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap揭秘-JDK1.7</title>
    <link href="http://ruanshubin.top/2019/05/28/ConcurrentHashMap%E6%8F%AD%E7%A7%98-JDK1.7/"/>
    <id>http://ruanshubin.top/2019/05/28/ConcurrentHashMap揭秘-JDK1.7/</id>
    <published>2019-05-28T06:54:00.000Z</published>
    <updated>2019-09-16T01:37:16.302Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>HashMap是非线程安全的，而HashTable是线程安全的，但是HashTable实现同步的方法比较暴力，即在所有方法体上添加synchronized关键字，相当于所有读写线程均去读取一把锁，效率比较低下。</p><p>另外一种同步Map的方法是使用Collections工具类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.synchronized（new HashMap()</span><br></pre></td></tr></table></figure><p>该种方法与HashTable实现方式类似，也是通过锁住整表来实现同步的。</p><p>而ConcurrentHashMap则避免了上述两种Map同步方式锁住全表的问题。</p><p>众所周知，HashMap是根据散列值分段存储的，同步Map在同步的时候锁住了所有的段，而ConcurrentHashMap加锁的时候根据散列值锁住了散列值锁对应的那段，因此提高了并发性能。ConcurrentHashMap也增加了对常用复合操作的支持，比如”若没有则添加”：putIfAbsent()，替换：replace()。这2个操作都是原子操作。</p><p>ConcurrentHashMap可以做到读取数据不加锁，并且其内部的结构可以让其在进行写操作的时候能够将锁的粒度保持地尽量地小，不用对整个ConcurrentHashMap加锁。</p><p>再次声明，本文介绍的ConcurrentHashMap是JDK1.7版本的，JDK1.8对ConcurrentHashMap做了较多改进，后面会专门写一篇文章介绍。</p><h2 id="ConcurrentHashMap的内部结构"><a href="#ConcurrentHashMap的内部结构" class="headerlink" title="ConcurrentHashMap的内部结构"></a>ConcurrentHashMap的内部结构</h2><p><img src="https://upload-images.jianshu.io/upload_images/10431632-22d949292e64772b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>可以看到，ConcurrentHashMap内部采用了一种叫Segment的数据结构，很明显它就是一个数组table(哈希桶)，数据的元素就是大家熟悉的HashEntry(哈希链)。</p><p>简单来讲，就是ConcurrentHashMap比HashMap多了一次hash过程，第1次hash定位到Segment，第2次hash定位到HashEntry，然后链表搜索找到指定节点。</p><p>该种实现方式的缺点是hash过程比普通的HashMap要长，但是优点也很明显，在进行写操作时，只需锁住写元素所在的Segment即可，其他Segment无需加锁，提高了并发读写的效率。</p><h3 id="Segment"><a href="#Segment" class="headerlink" title="Segment"></a>Segment</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable &#123;</span><br><span class="line">    transient volatile int count;</span><br><span class="line">    transient int modCount;</span><br><span class="line">    transient int threshold;</span><br><span class="line">    transient volatile HashEntry&lt;K,V&gt;[] table;</span><br><span class="line">    final float loadFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，Segment继承了ReentrantLock并实现了序列化接口，说明Segment的锁是可重入的。</p><ul><li>count: Segment中元素的数量，由volatile修饰，支持内存可见性；</li><li>modCount: 对table的大小造成影响的操作的数量（比如put或者remove操作）;</li><li>threshold：扩容阈值;</li><li>table：链表数组，数组中的每一个元素代表了一个链表的头部;</li><li>loadFactor: 负载因子。</li></ul><p>可以发现，Segment的数据结构与普通的HashMap基本类似，只是通过继承ReentrantLock可实现加锁操作。</p><h3 id="HashEntry"><a href="#HashEntry" class="headerlink" title="HashEntry"></a>HashEntry</h3><p>Segment中的元素是以HashEntry的形式存放在链表数组中的，其结构与普通HashMap的HashEntry基本一致，不同的是Segment的HashEntry，其value由volatile修饰，以支持内存可见性，即写操作对其他读线程即时可见。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static final class HashEntry&lt;K,V&gt; &#123;</span><br><span class="line">    final K key;</span><br><span class="line">    final int hash;</span><br><span class="line">    volatile V value;</span><br><span class="line">    final HashEntry&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看完数据结构，接着看初始化过程：</p><h2 id="ConcurrentHashMap的初始化"><a href="#ConcurrentHashMap的初始化" class="headerlink" title="ConcurrentHashMap的初始化"></a>ConcurrentHashMap的初始化</h2><p>直接跟源码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">// initialCapacity: 初始容量</span><br><span class="line">// loadFactor: 负载因子</span><br><span class="line">// concurrencyLevel： ConcurrentHashMap内部的Segment的数量</span><br><span class="line"></span><br><span class="line">public ConcurrentHashMap(int initialCapacity,</span><br><span class="line">                         float loadFactor, int concurrencyLevel) &#123;</span><br><span class="line">    if (!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line"></span><br><span class="line">// 若concurrencyLevel大于MAX_SEGMENTS，则concurrencyLevel=MAX_SEGMENTS</span><br><span class="line">    if (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">        concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">  </span><br><span class="line">    // 求解concurrencyLevel与2的几次方最近(天花板方向)</span><br><span class="line">// 如concurrencyLevel=5 则天花板方向上离2^3=8最近，则sshift=3，ssize=8</span><br><span class="line">    int sshift = 0;</span><br><span class="line">    int ssize = 1;</span><br><span class="line">    while (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">        ++sshift;</span><br><span class="line">        ssize &lt;&lt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">// segmentShift和segmentMask主要用于元素的hash</span><br><span class="line">    segmentShift = 32 - sshift;</span><br><span class="line">    segmentMask = ssize - 1;</span><br><span class="line">// 可以看到，实际segment的数量为ssize</span><br><span class="line">    this.segments = Segment.newArray(ssize);</span><br><span class="line">  </span><br><span class="line">    if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    int c = initialCapacity / ssize;</span><br><span class="line">// 若initialCapacity / ssize不整除，则将c=c+1</span><br><span class="line">    if (c * ssize &lt; initialCapacity)</span><br><span class="line">        ++c;</span><br><span class="line">    int cap = 1;</span><br><span class="line">// cap为每个segment的初始容量，其值为离c天花板方向最近的2^n</span><br><span class="line">// 例：c为5，cap则为2^3=8；c为12，cap则为2^4=16</span><br><span class="line">    while (cap &lt; c)</span><br><span class="line">        cap &lt;&lt;= 1;</span><br><span class="line">// 创建Segment</span><br><span class="line">    for (int i = 0; i &lt; this.segments.length; ++i)</span><br><span class="line">        this.segments[i] = new Segment&lt;K,V&gt;(cap, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，concurrencyLevel一经指定，便不能再次改变，原因也很简单，简化元素增多时的rehash过程，若Segment的数量也随元素的增加而进行扩容，则需要进行两次rehash，需要处理全部元素，效率较低。</p><p>随着元素的增加，ConcurrentHashMap不会增加Segment的数量，而只会增加Segment中链表数组的容量大小，这样的好处是扩容过程不需要对整个ConcurrentHashMap做rehash，而只需要对Segment里面的元素做一次rehash就可以了。</p><h2 id="ConcurrentHashMap的get操作"><a href="#ConcurrentHashMap的get操作" class="headerlink" title="ConcurrentHashMap的get操作"></a>ConcurrentHashMap的get操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">// 首先计算key的hash值</span><br><span class="line">    int hash = hash(key.hashCode());</span><br><span class="line">// segmentFor(hash): 定位到key在哪个segment</span><br><span class="line">// 调用segment的get(key, hash)获取到指定key的value</span><br><span class="line">    return segmentFor(hash).get(key, hash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着跟进segmentFor(hash):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final Segment&lt;K,V&gt; segmentFor(int hash) &#123;</span><br><span class="line">    return segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新回顾一下，ConcurrentHashMap初始化时，确定的2个参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">segmentShift = 32 - sshift;</span><br><span class="line">segmentMask = ssize - 1;</span><br></pre></td></tr></table></figure><p>其中，ssize = 2^sshift，ssize即为Segment的数量。</p><p>我们知道：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 通过位运算简化求余操作</span><br><span class="line">hash % (2^n) = hash &amp; (2^n -1 )</span><br></pre></td></tr></table></figure><p>可以看出，ConcurrentHashMap的第1次hash没有直接采用key的hash值来进行求余操作，而是采用hash值的高sshift位来进行求余操作的。</p><p>而hash值的高sshift位为:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash &gt;&gt;&gt; (32-sshift) = hash &gt;&gt;&gt; segmentShift</span><br></pre></td></tr></table></figure><p>至此，第1次hash操作就完成了。</p><p>下面，我们继续看Segment的get(key, hash)方法，即第2次hash过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">V get(Object key, int hash) &#123;</span><br><span class="line">    if (count != 0) &#123; // read-volatile</span><br><span class="line">// 取得链表的头部，就是第2次hash过程</span><br><span class="line">        HashEntry&lt;K,V&gt; e = getFirst(hash);</span><br><span class="line">// 链表搜索，直到hash与key均相等时，返回节点的value</span><br><span class="line">        while (e != null) &#123;</span><br><span class="line">            if (e.hash == hash &amp;&amp; key.equals(e.key)) &#123;</span><br><span class="line">                V v = e.value;</span><br><span class="line">                if (v != null)</span><br><span class="line">                    return v;</span><br><span class="line">                return readValueUnderLock(e); // recheck</span><br><span class="line">            &#125;</span><br><span class="line">            e = e.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先对count做了非零判断，前边讲解Segment的数据结构时，指出count是volatile修饰的，put、remove等操作会更新count的值，所以当竞争发生的时候，volatile的语义可以保证写操作在读操作之前，也就保证了写操作对后续的读操作都是可见的，这样后面get的后续操作就可以拿到完整的元素内容。</p><p>getFirst(hash)完成了第2次hash过程，跟进去：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HashEntry&lt;K,V&gt; getFirst(int hash) &#123;</span><br><span class="line">// 获取Segment的数组结构</span><br><span class="line">    HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">// 第2次hash过程，确定key位于哪一个HashEntry</span><br><span class="line">    return tab[hash &amp; (tab.length - 1)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，第2次hash与第1次hash基本类似，只不过直接用的hash值与Segment的数组大小进行求余，而没有采取hash值高n位的方式。</p><h2 id="ConcurrentHashMap的put操作"><a href="#ConcurrentHashMap的put操作" class="headerlink" title="ConcurrentHashMap的put操作"></a>ConcurrentHashMap的put操作</h2><p>put操作也涉及2次hash定位过程，但是比get操作多了是否扩容、rehash等过程。</p><p>put操作的第1次hash与get类似，不再赘述，主要看如何将元素put到Segment中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">V put(K key, int hash, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">// 加锁</span><br><span class="line">    lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        int c = count;</span><br><span class="line">// 对c进行+1操作，获取新的数组容量</span><br><span class="line">// 如果新的数组容量高于阈值，则先进行扩容操作</span><br><span class="line">        if (c++ &gt; threshold) // ensure capacity</span><br><span class="line">            rehash();</span><br><span class="line">// 获取Segment的数组table</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">// 确定在数组中的位置index，即第2次hash过程</span><br><span class="line">        int index = hash &amp; (tab.length - 1);</span><br><span class="line">// 获取index位置的头结点</span><br><span class="line">        HashEntry&lt;K,V&gt; first = tab[index];</span><br><span class="line">        HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">// 沿链表遍历，直到找到与元素key或者hash值相同的节点</span><br><span class="line">        while (e != null &amp;&amp; (e.hash != hash || !key.equals(e.key)))</span><br><span class="line">            e = e.next;</span><br><span class="line">  </span><br><span class="line">        V oldValue;</span><br><span class="line">// 若key或者hash值相同的节点存在，则进行更新操作</span><br><span class="line">        if (e != null) &#123;</span><br><span class="line">// value也是volatile修饰的，所以内存即时可见</span><br><span class="line">            oldValue = e.value;</span><br><span class="line">            if (!onlyIfAbsent)</span><br><span class="line">                e.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">// 若key或者hash值相同的节点不存在，则新建节点，追加到当前链表的头部(头插法)</span><br><span class="line">        else &#123;</span><br><span class="line">            oldValue = null;</span><br><span class="line">// 更新modCount的值，记录对table的大小造成影响的操作的数量</span><br><span class="line">            ++modCount;</span><br><span class="line">            tab[index] = new HashEntry&lt;K,V&gt;(key, hash, first, value);</span><br><span class="line">// 更新count的值，内存即时可见</span><br><span class="line">            count = c; // write-volatile</span><br><span class="line">        &#125;</span><br><span class="line">// 返回旧值</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">// 释放锁，与synchronize关键字不同，Lock必须显示释放</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，Segment的put过程与普通的HashMap基本类似。</p><h2 id="ConcurrentHashMap的remove操作"><a href="#ConcurrentHashMap的remove操作" class="headerlink" title="ConcurrentHashMap的remove操作"></a>ConcurrentHashMap的remove操作</h2><p>与put操作基本类似，首先根据hash值的高sshift位与Segment的数量ssize求余定位到具体的Segment，然后在Segment上执行具体的remove操作。</p><p>下面我们看一下Segment如何实现remove操作的。</p><p>话不多说，直接怼源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">V remove(Object key, int hash, Object value) &#123;</span><br><span class="line">// 加锁，除了读取操作，其他操作均需要加锁</span><br><span class="line">    lock();</span><br><span class="line">    try &#123;</span><br><span class="line">// 计算新的Segment元素数量</span><br><span class="line">        int c = count - 1;</span><br><span class="line">// 获取Segment的数组table</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">// 第2次hash，确定在table的哪个位置</span><br><span class="line">        int index = hash &amp; (tab.length - 1);</span><br><span class="line">        HashEntry&lt;K,V&gt; first = tab[index];</span><br><span class="line">        HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">// 沿链表遍历，直到找到与元素key或者hash值相同的节点</span><br><span class="line">        while (e != null &amp;&amp; (e.hash != hash || !key.equals(e.key)))</span><br><span class="line">            e = e.next;</span><br><span class="line">  </span><br><span class="line">        V oldValue = null;</span><br><span class="line">        if (e != null) &#123;</span><br><span class="line">            V v = e.value;</span><br><span class="line">            if (value == null || value.equals(v)) &#123;</span><br><span class="line">                oldValue = v;</span><br><span class="line">                // 更新modCount值</span><br><span class="line">                ++modCount;</span><br><span class="line">                HashEntry&lt;K,V&gt; newFirst = e.next;</span><br><span class="line">// 将待删除元素的前面的元素全部复制一遍，然后头插到链表上去</span><br><span class="line">                for (HashEntry&lt;K,V&gt; p = first; p != e; p = p.next)</span><br><span class="line">                    newFirst = new HashEntry&lt;K,V&gt;(p.key, p.hash,</span><br><span class="line">                                                  newFirst, p.value);</span><br><span class="line">                tab[index] = newFirst;</span><br><span class="line">// 更新新的Segment元素数量，内存即时可见</span><br><span class="line">                count = c; // write-volatile</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">// 返回旧值</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">// 释放锁</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于，HashEntry中的next是final的，一经赋值以后就不可修改，在定位到待删除元素的位置以后，程序就将待删除元素前面的那一些元素全部复制一遍，然后再一个一个重新接到链表上去。</p><p>如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 原有链表：</span><br><span class="line">1--&gt;2--&gt;3--&gt;4--&gt;5</span><br><span class="line">// 删除节点3，新的链表为：</span><br><span class="line">2--&gt;1--&gt;4--&gt;5</span><br></pre></td></tr></table></figure><p>至此，JDK1.7版本的ConcurrentHashMap的基础方法介绍完毕，其他方法的实现方式，读者可自行阅读源码获取，再次不做过多阐述。</p><p><strong>参考文献:</strong></p><ol><li><a href="https://www.cnblogs.com/dolphin0520/p/3932905.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3932905.html</a></li><li><a href="http://ifeve.com/ConcurrentHashMap/" target="_blank" rel="noopener">http://ifeve.com/ConcurrentHashMap/</a></li><li><a href="https://www.iteye.com/topic/344876" target="_blank" rel="noopener">https://www.iteye.com/topic/344876</a></li></ol><p><img src="https://upload-images.jianshu.io/upload_images/10431632-86426e609c966a5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>欢迎您扫一扫上面的二维码，关注我的微信公众号！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;HashMap是非线程安全的，而HashTable是线程安全的，但是HashTable实现同步的方法比较暴力，即在所有方法体上添加synch
      
    
    </summary>
    
      <category term="并发编程" scheme="http://ruanshubin.top/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://ruanshubin.top/tags/Java/"/>
    
      <category term="并发" scheme="http://ruanshubin.top/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java的锁机制--ReadWriteLock接口</title>
    <link href="http://ruanshubin.top/2019/05/20/Java%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6--ReadWriteLock%E6%8E%A5%E5%8F%A3/"/>
    <id>http://ruanshubin.top/2019/05/20/Java的锁机制--ReadWriteLock接口/</id>
    <published>2019-05-20T09:25:00.000Z</published>
    <updated>2019-09-16T01:37:16.307Z</updated>
    
    <content type="html"><![CDATA[<p>ReentrantLock是排他锁，排他锁在同一时刻仅有一个线程可以进行访问，实际上独占锁是一种相对比较保守的锁策略，独占锁模式下的读/读、读/写、写/写操作都不能同时发生，这在一定程度上降低了吞吐量。然而读操作之间不存在数据竞争问题，如果读/读操作能够以共享锁的方式进行，那会进一步提升性能。</p><p>为解决读写冲突问题，Doug Lea设计了ReadWriteLock接口，该接口只定义了两个方法:</p><p><img src="https://upload-images.jianshu.io/upload_images/10431632-0432ede55354b8a5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>readLock()用来获取读锁，writeLock()用来获取写锁，将共享资源的读/写操作分开进行管理，类似于数据库中的S锁(共享锁)和X锁(独占锁)，其遵循如下原则：</p><ul><li>共享资源只允许加一种锁，或读锁，或写锁，不能同时加；</li><li>共享资源可以被多个线程同时加读锁，而写锁只允许加一把；</li><li>当共享资源被读锁占用时，写线程只能等待；同样的，当共享资源被写锁占用时，读线程只能等待。</li></ul><p>所以，读/写、写/写是互斥的，而读/读是互不影响的，大大提升了读操作的效率。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>J.U.C中，ReentrantReadWriteLock唯一实现了ReadWriteLock接口。</p><p>首先，通过一个简单示例来说明ReentrantReadWriteLock的用法。</p><p>假如有多个线程要同时进行读操作的话，首先看synchronized达到的效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class SynchronsizedRead &#123;</span><br><span class="line"></span><br><span class="line">    public synchronized void get(Thread thread) throws InterruptedException &#123;</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        for(int i=0; i&lt;10; i++)&#123;</span><br><span class="line">            System.out.println(thread.getName() + &quot;正在进行读操作...&quot;);</span><br><span class="line">            Thread.sleep(100);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(thread.getName() + &quot;读操作完毕&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        final SynchronsizedRead synchronsizedread = new SynchronsizedRead();</span><br><span class="line"></span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    synchronsizedread.get(Thread.currentThread());</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    synchronsizedread.get(Thread.currentThread());</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Thread-0正在进行读操作...</span><br><span class="line">Thread-0正在进行读操作...</span><br><span class="line">Thread-0正在进行读操作...</span><br><span class="line">Thread-0正在进行读操作...</span><br><span class="line">Thread-0正在进行读操作...</span><br><span class="line">Thread-0正在进行读操作...</span><br><span class="line">Thread-0正在进行读操作...</span><br><span class="line">Thread-0正在进行读操作...</span><br><span class="line">Thread-0正在进行读操作...</span><br><span class="line">Thread-0正在进行读操作...</span><br><span class="line">Thread-0读操作完毕</span><br><span class="line">Thread-1正在进行读操作...</span><br><span class="line">Thread-1正在进行读操作...</span><br><span class="line">Thread-1正在进行读操作...</span><br><span class="line">Thread-1正在进行读操作...</span><br><span class="line">Thread-1正在进行读操作...</span><br><span class="line">Thread-1正在进行读操作...</span><br><span class="line">Thread-1正在进行读操作...</span><br><span class="line">Thread-1正在进行读操作...</span><br><span class="line">Thread-1正在进行读操作...</span><br><span class="line">Thread-1正在进行读操作...</span><br><span class="line">Thread-1读操作完毕</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>可以看到，当持有锁的线程在读取数据的时候，其他读线程只能等待。</p><p>接着用ReentrantReadWriteLock来实现上述业务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class LockRead &#123;</span><br><span class="line"></span><br><span class="line">    private ReentrantReadWriteLock reentrantReadWriteLock = new ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    public void get(Thread thread) throws InterruptedException &#123;</span><br><span class="line">        reentrantReadWriteLock.readLock().lock();</span><br><span class="line">        try&#123;</span><br><span class="line">            long start = System.currentTimeMillis();</span><br><span class="line">            for(int i=0; i&lt;10; i++)&#123;</span><br><span class="line">                System.out.println(thread.getName() + &quot;正在进行读操作...&quot;);</span><br><span class="line">                Thread.sleep(100);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(thread.getName() + &quot;读操作完毕&quot;);</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            reentrantReadWriteLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        final LockRead lockRead = new LockRead();</span><br><span class="line"></span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    lockRead.get(Thread.currentThread());</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    lockRead.get(Thread.currentThread());</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Thread-0正在进行读操作...</span><br><span class="line">Thread-1正在进行读操作...</span><br><span class="line">Thread-0正在进行读操作...</span><br><span class="line">Thread-1正在进行读操作...</span><br><span class="line">Thread-0正在进行读操作...</span><br><span class="line">Thread-1正在进行读操作...</span><br><span class="line">Thread-0正在进行读操作...</span><br><span class="line">Thread-1正在进行读操作...</span><br><span class="line">Thread-0正在进行读操作...</span><br><span class="line">Thread-1正在进行读操作...</span><br><span class="line">Thread-0正在进行读操作...</span><br><span class="line">Thread-1正在进行读操作...</span><br><span class="line">Thread-0正在进行读操作...</span><br><span class="line">Thread-1正在进行读操作...</span><br><span class="line">Thread-0正在进行读操作...</span><br><span class="line">Thread-0正在进行读操作...</span><br><span class="line">Thread-1正在进行读操作...</span><br><span class="line">Thread-0正在进行读操作...</span><br><span class="line">Thread-0读操作完毕</span><br><span class="line">Thread-1正在进行读操作...</span><br><span class="line">Thread-1正在进行读操作...</span><br><span class="line">Thread-1读操作完毕</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>可以看到，ReentrantReadWriteLock模式下，可以实现多线程下同时读取数据，从而大大提升了读操作的效率。</p><h2 id="源码跟读"><a href="#源码跟读" class="headerlink" title="源码跟读"></a>源码跟读</h2><p>ReentrantReadWriteLock和ReentrantLock类似的公平锁和非公平锁（默认构造方法是非公平锁），Sync类是一个继承于AQS的抽象类。Sync有FairSync公平锁和NonfairSync非公平锁两个子类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public ReentrantReadWriteLock() &#123;</span><br><span class="line">this(false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ReentrantReadWriteLock(boolean fair) &#123;</span><br><span class="line">sync = fair ? new FairSync() : new NonfairSync();</span><br><span class="line">readerLock = new ReadLock(this);</span><br><span class="line">writerLock = new WriteLock(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReentrantReadWriteLock中包含了下面三个对象：sync对象，读锁readerLock和写锁writerLock。</p><p>读锁：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public static class ReadLock implements Lock, java.io.Serializable &#123;</span><br><span class="line">private static final long serialVersionUID = -5992448646407690164L;</span><br><span class="line">private final Sync sync;</span><br><span class="line"></span><br><span class="line">protected ReadLock(ReentrantReadWriteLock lock) &#123;</span><br><span class="line">sync = lock.sync;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void lock() &#123;</span><br><span class="line">// 调用sync的acquireShared(1)方法实现共享锁的释放</span><br><span class="line">sync.acquireShared(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取锁(可中断)</span><br><span class="line">public void lockInterruptibly() throws InterruptedException &#123;</span><br><span class="line">sync.acquireSharedInterruptibly(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取锁</span><br><span class="line">public boolean tryLock() &#123;</span><br><span class="line">return sync.tryReadLock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean tryLock(long timeout, TimeUnit unit)</span><br><span class="line">throws InterruptedException &#123;</span><br><span class="line">return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 释放锁</span><br><span class="line">public void unlock() &#123;</span><br><span class="line">sync.releaseShared(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Condition newCondition() &#123;</span><br><span class="line">throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String toString() &#123;</span><br><span class="line">int r = sync.getReadLockCount();</span><br><span class="line">return super.toString() +</span><br><span class="line">&quot;[Read locks = &quot; + r + &quot;]&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写锁：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public static class WriteLock implements Lock, java.io.Serializable &#123;</span><br><span class="line">private static final long serialVersionUID = -4992448646407690164L;</span><br><span class="line">private final Sync sync;</span><br><span class="line"></span><br><span class="line">protected WriteLock(ReentrantReadWriteLock lock) &#123;</span><br><span class="line">sync = lock.sync;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void lock() &#123;</span><br><span class="line">sync.acquire(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void lockInterruptibly() throws InterruptedException &#123;</span><br><span class="line">sync.acquireInterruptibly(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean tryLock( ) &#123;</span><br><span class="line">return sync.tryWriteLock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean tryLock(long timeout, TimeUnit unit)</span><br><span class="line">throws InterruptedException &#123;</span><br><span class="line">return sync.tryAcquireNanos(1, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void unlock() &#123;</span><br><span class="line">sync.release(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Condition newCondition() &#123;</span><br><span class="line">return sync.newCondition();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String toString() &#123;</span><br><span class="line">Thread o = sync.getOwner();</span><br><span class="line">return super.toString() + ((o == null) ?</span><br><span class="line">   &quot;[Unlocked]&quot; :</span><br><span class="line">   &quot;[Locked by thread &quot; + o.getName() + &quot;]&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean isHeldByCurrentThread() &#123;</span><br><span class="line">return sync.isHeldExclusively();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getHoldCount() &#123;</span><br><span class="line">return sync.getWriteHoldCount();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，读/写锁均包含了Sync对象，首先查看Sync的构造变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 读锁同步状态占用的位数</span><br><span class="line">static final int SHARED_SHIFT   = 16;</span><br><span class="line">// 每次增加读锁同步状态，就相当于增加SHARED_UNIT</span><br><span class="line">static final int SHARED_UNIT    = (1 &lt;&lt; SHARED_SHIFT);</span><br><span class="line">// 读锁或写锁的最大请求数量（包含重入）</span><br><span class="line">static final int MAX_COUNT      = (1 &lt;&lt; SHARED_SHIFT) - 1;</span><br><span class="line">// 低16位的MASK，用来计算写锁的同步状态</span><br><span class="line">static final int EXCLUSIVE_MASK = (1 &lt;&lt; SHARED_SHIFT) - 1;</span><br><span class="line"></span><br><span class="line">// 返回共享锁数</span><br><span class="line">static int sharedCount(int c)    &#123; return c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line">// 返回独占锁数</span><br><span class="line">static int exclusiveCount(int c) &#123; return c &amp; EXCLUSIVE_MASK; &#125;</span><br></pre></td></tr></table></figure><p>在ReentrantLock自定义同步器的实现中，同步状态表示锁被一个线程重复获取的次数，而读写锁的自定义同步器需要在同步状态（一个整形变量）上维护多个读线程和一个写线程的状态，那就需要按位切割使用这个状态变量，读写锁将变量切分成两部分，高16位表示读，低16位表示写，划分方式如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/10431632-71588a184131b4b7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>当前同步状态表示一个线程已经获取了写锁，且重进入了3次，同时也连续获取了2次读锁。同步状态是通过位运算进行更新的，假设当前同步状态是S，写状态等于S &amp; EXCLUSIVE_MASK，即S &amp; 0x0000FFFF，读状态等于S &gt;&gt;&gt; 16.当写状态加1时，等于S+1，当读状态加1时，等于S+SHARED_UNIT，即S+(1 &lt;&lt; 16)，也就是S + 0x00010000。</p><p>即读锁和写锁的状态获取和设置如下：</p><ul><li>读锁状态的获取：S &gt;&gt; 16</li><li>读锁状态的增加：S + (1 &lt;&lt; 16)</li><li>写锁状态的获取：S &amp; 0x0000FFFF</li><li>写锁状态的增加：S + 1</li></ul><p>Sync类内部存在两个内部类，分别为HoldCounter和ThreadLocalHoldCounter，其中HoldCounter主要与读锁配套使用，其中，HoldCounter源码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 计数器</span><br><span class="line">static final class HoldCounter &#123;</span><br><span class="line">    // 计数</span><br><span class="line">    int count = 0;</span><br><span class="line">    // Use id, not reference, to avoid garbage retention</span><br><span class="line">    // 获取当前线程的TID属性的值</span><br><span class="line">    final long tid = getThreadId(Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：HoldCounter主要有两个属性，count和tid，其中count表示某个读线程重入的次数，tid表示该线程的tid字段的值，该字段可以用来唯一标识一个线程。ThreadLocalHoldCounter的源码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 本地线程计数器</span><br><span class="line">static final class ThreadLocalHoldCounter</span><br><span class="line">    extends ThreadLocal&lt;HoldCounter&gt; &#123;</span><br><span class="line">    // 重写初始化方法，在没有进行set的情况下，获取的都是该HoldCounter值</span><br><span class="line">    public HoldCounter initialValue() &#123;</span><br><span class="line">        return new HoldCounter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：ThreadLocalHoldCounter重写了ThreadLocal的initialValue方法，ThreadLocal类可以将线程与对象相关联。在没有进行set的情况下，get到的均是initialValue方法里面生成的那个HolderCounter对象。</p><p>Sync类继承自AQS，实现了锁的获取和释放方法。</p><h3 id="写锁的获取及释放"><a href="#写锁的获取及释放" class="headerlink" title="写锁的获取及释放"></a>写锁的获取及释放</h3><p>WriteLock类中的lock和unlock方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void lock() &#123;</span><br><span class="line">    sync.acquire(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void unlock() &#123;</span><br><span class="line">    sync.release(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到就是调用的独占式同步状态的获取与释放，因此真实的实现就是Sync的tryAcquire和tryRelease。</p><p>跟进tryAcquire：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">    //当前线程</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    //获取状态</span><br><span class="line">    int c = getState();</span><br><span class="line">    //写线程数量（即获取独占锁的重入数）</span><br><span class="line">    int w = exclusiveCount(c);</span><br><span class="line">    </span><br><span class="line">    //当前同步状态state != 0，说明已经有其他线程获取了读锁或写锁</span><br><span class="line">    if (c != 0) &#123;</span><br><span class="line">        // 当前state不为0，此时：如果写锁状态为0说明读锁此时被占用返回false；</span><br><span class="line">        // 如果写锁状态不为0且写锁没有被当前线程持有返回false</span><br><span class="line">        if (w == 0 || current != getExclusiveOwnerThread())</span><br><span class="line">            return false;</span><br><span class="line">        </span><br><span class="line">        //判断同一线程获取写锁是否超过最大次数（65535），支持可重入</span><br><span class="line">        if (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        //更新状态</span><br><span class="line">        //此时当前线程已持有写锁，现在是重入，所以只需要修改锁的数量即可。</span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //到这里说明此时c=0,读锁和写锁都没有被获取</span><br><span class="line">    //writerShouldBlock表示是否阻塞</span><br><span class="line">    if (writerShouldBlock() ||</span><br><span class="line">        !compareAndSetState(c, c + acquires))</span><br><span class="line">        return false;</span><br><span class="line">    </span><br><span class="line">    //设置锁为当前线程所有</span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本流程如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/10431632-ff5ad3647beb9209.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>跟进tryRelease:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">    //若锁的持有者不是当前线程，抛出异常</span><br><span class="line">    if (!isHeldExclusively())</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    //写锁的新线程数</span><br><span class="line">    int nextc = getState() - releases;</span><br><span class="line">    //如果独占模式重入数为0了，说明独占模式被释放</span><br><span class="line">    boolean free = exclusiveCount(nextc) == 0;</span><br><span class="line">    if (free)</span><br><span class="line">        //若写锁的新线程数为0，则将锁的持有者设置为null</span><br><span class="line">        setExclusiveOwnerThread(null);</span><br><span class="line">    //设置写锁的新线程数</span><br><span class="line">    //不管独占模式是否被释放，更新独占重入数</span><br><span class="line">    setState(nextc);</span><br><span class="line">    return free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写锁的释放过程还是相对而言比较简单的：首先查看当前线程是否为写锁的持有者，如果不是抛出异常。然后检查释放后写锁的线程数是否为0，如果为0则表示写锁空闲了，释放锁资源将锁的持有线程设置为null，否则释放仅仅只是一次重入锁而已，并不能将写锁的线程清空。</p><p><img src="https://upload-images.jianshu.io/upload_images/10431632-3d7700da67dc5e1e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="读锁的获取与释放"><a href="#读锁的获取与释放" class="headerlink" title="读锁的获取与释放"></a>读锁的获取与释放</h3><p>类似于写锁，读锁的lock和unlock的实际实现对应Sync的tryAcquireShared和tryReleaseShared方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">protected final int tryAcquireShared(int unused) &#123;</span><br><span class="line">    // 获取当前线程</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    // 获取状态</span><br><span class="line">    int c = getState();</span><br><span class="line">    </span><br><span class="line">    //如果写锁线程数 != 0 ，且独占锁不是当前线程则返回失败，因为存在锁降级</span><br><span class="line">    if (exclusiveCount(c) != 0 &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() != current)</span><br><span class="line">        return -1;</span><br><span class="line">    // 读锁数量</span><br><span class="line">    int r = sharedCount(c);</span><br><span class="line">    /*</span><br><span class="line">     * readerShouldBlock():读锁是否需要等待（公平锁原则）</span><br><span class="line">     * r &lt; MAX_COUNT：持有线程小于最大数（65535）</span><br><span class="line">     * compareAndSetState(c, c + SHARED_UNIT)：设置读取锁状态</span><br><span class="line">     */</span><br><span class="line">     // 读线程是否应该被阻塞、并且小于最大值、并且比较设置成功</span><br><span class="line">    if (!readerShouldBlock() &amp;&amp;</span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">        //r == 0，表示第一个读锁线程，第一个读锁firstRead是不会加入到readHolds中</span><br><span class="line">        if (r == 0) &#123; // 读锁数量为0</span><br><span class="line">            // 设置第一个读线程</span><br><span class="line">            firstReader = current;</span><br><span class="line">            // 读线程占用的资源数为1</span><br><span class="line">            firstReaderHoldCount = 1;</span><br><span class="line">        &#125; else if (firstReader == current) &#123; // 当前线程为第一个读线程，表示第一个读锁线程重入</span><br><span class="line">            // 占用资源数加1</span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; else &#123; // 读锁数量不为0并且不为当前线程</span><br><span class="line">            // 获取计数器</span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            // 计数器为空或者计数器的tid不为当前正在运行的线程的tid</span><br><span class="line">            if (rh == null || rh.tid != getThreadId(current)) </span><br><span class="line">                // 获取当前线程对应的计数器</span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            else if (rh.count == 0) // 计数为0</span><br><span class="line">                //加入到readHolds中</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            //计数+1</span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中sharedCount方法表示占有读锁的线程数量，源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static int sharedCount(int c)    &#123; return c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br></pre></td></tr></table></figure><p>说明：直接将state右移16位，就可以得到读锁的线程数量，因为state的高16位表示读锁，对应的第十六位表示写锁数量。</p><p>读锁获取锁的过程比写锁稍微复杂些，首先判断写锁是否为0并且当前线程不占有独占锁，直接返回；否则，判断读线程是否需要被阻塞并且读锁数量是否小于最大值并且比较设置状态成功，若当前没有读锁，则设置第一个读线程firstReader和firstReaderHoldCount；若当前线程线程为第一个读线程，则增加firstReaderHoldCount；否则，将设置当前线程对应的HoldCounter对象的值。流程图如下:</p><p><img src="https://upload-images.jianshu.io/upload_images/10431632-166cef32f9ccc9e2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>读锁的释放，tryReleaseShared方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryReleaseShared(int unused) &#123;</span><br><span class="line">    // 获取当前线程</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    if (firstReader == current) &#123; // 当前线程为第一个读线程</span><br><span class="line">        // assert firstReaderHoldCount &gt; 0;</span><br><span class="line">        if (firstReaderHoldCount == 1) // 读线程占用的资源数为1</span><br><span class="line">            firstReader = null;</span><br><span class="line">        else // 减少占用的资源</span><br><span class="line">            firstReaderHoldCount--;</span><br><span class="line">    &#125; else &#123; // 当前线程不为第一个读线程</span><br><span class="line">        // 获取缓存的计数器</span><br><span class="line">        HoldCounter rh = cachedHoldCounter;</span><br><span class="line">        if (rh == null || rh.tid != getThreadId(current)) // 计数器为空或者计数器的tid不为当前正在运行的线程的tid</span><br><span class="line">            // 获取当前线程对应的计数器</span><br><span class="line">            rh = readHolds.get();</span><br><span class="line">        // 获取计数</span><br><span class="line">        int count = rh.count;</span><br><span class="line">        if (count &lt;= 1) &#123; // 计数小于等于1</span><br><span class="line">            // 移除</span><br><span class="line">            readHolds.remove();</span><br><span class="line">            if (count &lt;= 0) // 计数小于等于0，抛出异常</span><br><span class="line">                throw unmatchedUnlockException();</span><br><span class="line">        &#125;</span><br><span class="line">        // 减少计数</span><br><span class="line">        --rh.count;</span><br><span class="line">    &#125;</span><br><span class="line">    for (;;) &#123; // 无限循环</span><br><span class="line">        // 获取状态</span><br><span class="line">        int c = getState();</span><br><span class="line">        // 获取状态</span><br><span class="line">        int nextc = c - SHARED_UNIT;</span><br><span class="line">        if (compareAndSetState(c, nextc)) // 比较并进行设置</span><br><span class="line">            // Releasing the read lock has no effect on readers,</span><br><span class="line">            // but it may allow waiting writers to proceed if</span><br><span class="line">            // both read and write locks are now free.</span><br><span class="line">            return nextc == 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：此方法表示读锁线程释放锁。首先判断当前线程是否为第一个读线程firstReader，若是，则判断第一个读线程占有的资源数firstReaderHoldCount是否为1，若是，则设置第一个读线程firstReader为空，否则，将第一个读线程占有的资源数firstReaderHoldCount减1；若当前线程不是第一个读线程，那么首先会获取缓存计数器（上一个读锁线程对应的计数器 ），若计数器为空或者tid不等于当前线程的tid值，则获取当前线程的计数器，如果计数器的计数count小于等于1，则移除当前线程对应的计数器，如果计数器的计数count小于等于0，则抛出异常，之后再减少计数即可。无论何种情况，都会进入无限循环，该循环可以确保成功设置状态state。其流程图如下:</p><p><img src="https://upload-images.jianshu.io/upload_images/10431632-b9cbba5c5f4d89d2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在读锁的获取、释放过程中，总是会有一个对象存在着，同时该对象在获取线程获取读锁是+1，释放读锁时-1，该对象就是HoldCounter。</p><p>要明白HoldCounter就要先明白读锁。前面提过读锁的内在实现机制就是共享锁，对于共享锁其实我们可以稍微的认为它不是一个锁的概念，它更加像一个计数器的概念。一次共享锁操作就相当于一次计数器的操作，获取共享锁计数器+1，释放共享锁计数器-1。只有当线程获取共享锁后才能对共享锁进行释放、重入操作。所以HoldCounter的作用就是当前线程持有共享锁的数量，这个数量必须要与线程绑定在一起，否则操作其他线程锁就会抛出异常。</p><p>先看读锁获取锁的部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if (r == 0) &#123;//r == 0，表示第一个读锁线程，第一个读锁firstRead是不会加入到readHolds中</span><br><span class="line">    firstReader = current;</span><br><span class="line">    firstReaderHoldCount = 1;</span><br><span class="line">&#125; else if (firstReader == current) &#123;//第一个读锁线程重入</span><br><span class="line">    firstReaderHoldCount++;    </span><br><span class="line">&#125; else &#123;    //非firstReader计数</span><br><span class="line">    HoldCounter rh = cachedHoldCounter;//readHoldCounter缓存</span><br><span class="line">    //rh == null 或者 rh.tid != current.getId()，需要获取rh</span><br><span class="line">    if (rh == null || rh.tid != current.getId())    </span><br><span class="line">        cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">    else if (rh.count == 0)</span><br><span class="line">        readHolds.set(rh);  //加入到readHolds中</span><br><span class="line">    rh.count++; //计数+1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里为什么要搞一个firstRead、firstReaderHoldCount呢？而不是直接使用else那段代码？这是为了一个效率问题，firstReader是不会放入到readHolds中的，如果读锁仅有一个的情况下就会避免查找readHolds。可能就看这个代码还不是很理解HoldCounter。我们先看firstReader、firstReaderHoldCount的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private transient Thread firstReader = null;</span><br><span class="line">private transient int firstReaderHoldCount;</span><br></pre></td></tr></table></figure><p>这两个变量比较简单，一个表示线程，当然该线程是一个特殊的线程，一个是firstReader的重入计数。</p><p>故而，HoldCounter应该就是绑定线程上的一个计数器，而ThradLocalHoldCounter则是线程绑定的ThreadLocal。从上面我们可以看到ThreadLocal将HoldCounter绑定到当前线程上，同时HoldCounter也持有线程Id，这样在释放锁的时候才能知道ReadWriteLock里面缓存的上一个读取线程（cachedHoldCounter）是否是当前线程。这样做的好处是可以减少ThreadLocal.get()的次数，因为这也是一个耗时操作。需要说明的是这样HoldCounter绑定线程id而不绑定线程对象的原因是避免HoldCounter和ThreadLocal互相绑定而GC难以释放它们（尽管GC能够智能的发现这种引用而回收它们，但是这需要一定的代价），所以其实这样做只是为了帮助GC快速回收对象而已。</p><p><strong>参考文献：</strong></p><ul><li><a href="https://www.cnblogs.com/dolphin0520/p/3923737.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3923737.html</a></li><li><a href="https://www.cnblogs.com/shixm/p/5490026.html" target="_blank" rel="noopener">https://www.cnblogs.com/shixm/p/5490026.html</a></li><li><a href="https://www.cnblogs.com/xiaoxi/p/9140541.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaoxi/p/9140541.html</a></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/10431632-86426e609c966a5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>欢迎您扫一扫上面的二维码，关注我的微信公众号！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ReentrantLock是排他锁，排他锁在同一时刻仅有一个线程可以进行访问，实际上独占锁是一种相对比较保守的锁策略，独占锁模式下的读/读、读/写、写/写操作都不能同时发生，这在一定程度上降低了吞吐量。然而读操作之间不存在数据竞争问题，如果读/读操作能够以共享锁的方式进行，
      
    
    </summary>
    
      <category term="并发编程" scheme="http://ruanshubin.top/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://ruanshubin.top/tags/Java/"/>
    
      <category term="并发" scheme="http://ruanshubin.top/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java的锁机制--Lock接口</title>
    <link href="http://ruanshubin.top/2019/05/20/Java%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6--Lock%E6%8E%A5%E5%8F%A3/"/>
    <id>http://ruanshubin.top/2019/05/20/Java的锁机制--Lock接口/</id>
    <published>2019-05-20T09:22:00.000Z</published>
    <updated>2019-09-16T01:37:16.306Z</updated>
    
    <content type="html"><![CDATA[<p>synchronized关键字虽然可以解决大部分多线程锁的问题，但是仍旧存在下述问题：</p><ul><li>假如持有锁的某线程因等待长时IO或者其他原因阻塞，其他等待的线程无法响应中断，只能不断等待；</li><li>多线程下只有读操作是不会发生冲突的，但synchronized关键字对读和写操作均一视同仁，所以当一个线程进行读取操作时，其他线程只能不断等待；</li><li>使用synchronized关键字无法确认线程是否成功获取到锁。</li></ul><p>针对上述问题，Doug Lea李大爷实现了一套更加灵活的Java锁机制，即J.U.C的locks包。</p><p>下面，我们打开locks包，看看有啥好东西吧。</p><p><img src="https://upload-images.jianshu.io/upload_images/10431632-eff3739e6d1d00b2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>首先看一下Lock接口：</p><h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><p>Lock有下述6个方法，主要分为三大类:</p><ul><li>获取锁的方法，分别为lock()、lockInterruptibly()、tryLock()、tryLock(long, TimeUnit);</li><li>释放锁的方法，unlock();</li><li>线程协作相关的方法，newCondition()。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/10431632-5a57192f3877575f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>synchronsized关键字不需要用户手动释放锁，当synchronized修饰的方法或代码块执行完毕后，系统会自动让线程释放对锁的占用。</p><p>与synchronsized关键字不同的是，Lock必须由用户手动执行加锁/释放锁操作，当持有锁的线程发生异常时，该线程不会自动释放锁，可能会导致死锁，故Lock必须在try{}catch{}块中进行，并且将释放锁的操作放在finally块中进行，以保证锁一定被被释放，防止死锁的发生。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 初始化锁对象</span><br><span class="line">Lock lock = ...;</span><br><span class="line">// 加锁操作</span><br><span class="line">lock.lock();</span><br><span class="line">try&#123;</span><br><span class="line">// 执行相应任务</span><br><span class="line">doSomething();</span><br><span class="line">&#125;catch(Exception e)&#123;</span><br><span class="line">// 处理异常</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">// 释放锁</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与lock()不同的是，tryLock()是由返回值的，获取到锁则返回true，否则返回false，tryLock(long, TimeUnit)为其重载方法，表示获取不到锁之后会等待一定时间，如果在时间期限内获取到锁，则返回true，否则返回false。</p><p>lockInterruptibly()方法，当线程获取不到锁，在等待的过程中是可以响应中断的。</p><p>不过需要注意的是，通过lockInterruptibly()方法获取到锁的线程，在运行过程中是不能响应中断的，仅是做一个中断标记，待释放锁之后再响应中断。</p><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>J.U.C包中Lock接口的实现类主要有5个：</p><p><img src="https://upload-images.jianshu.io/upload_images/10431632-bf5fa8548d2a6c03.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>除了ReentrantLock外，其他均为其他类的内部类，ReentrantLock除了实现了Lock的接口方法外，还提供了更多的方法：</p><p><img src="https://upload-images.jianshu.io/upload_images/10431632-124771b8a5830432.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="lock"><a href="#lock" class="headerlink" title="lock()"></a>lock()</h3><p>首先看ReentrantLock如何实现Lock接口的lock()方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void lock() &#123;</span><br><span class="line">sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用的是抽象内部类Sync的lock()方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abstract static class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">abstract void lock();</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>既然Sync的lock()方法声明为abstract，则必定有Sync的子类来实现该方法。</p><p>ReentrantLock的内部类FairSync、NonfairSync最终实现了lock()方法。</p><p><img src="https://upload-images.jianshu.io/upload_images/10431632-b2dd549357f3838e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>顾名思义，FairSync、NonfairSync分别实现了公平锁和非公平锁，ReentrantLock默认构建的是非公平锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public ReentrantLock() &#123;</span><br><span class="line">sync = new NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ReentrantLock(boolean fair) &#123;</span><br><span class="line">// 若fair为true则构建公平锁</span><br><span class="line">sync = fair ? new FairSync() : new NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>公平锁即尽量以请求锁的顺序来获取锁。比如同时有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该锁。</p><p>非公平锁即无法保证锁的获取是按照请求锁的顺序进行的。这样就可能导致某个或者一些线程永远获取不到锁。</p><p>在Java中，synchronized就是非公平锁，它无法保证等待的线程获取锁的顺序。</p><p>下面以NonfairSync为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static final class NonfairSync extends Sync &#123;</span><br><span class="line">private static final long serialVersionUID = 7316153563782823691L;</span><br><span class="line"></span><br><span class="line">final void lock() &#123;</span><br><span class="line">if (compareAndSetState(0, 1))</span><br><span class="line">setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">else</span><br><span class="line">// 调用AQS的acquire()模板方法</span><br><span class="line">acquire(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">return nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，NonfairSync调用AQS的acquire(1)方法来实现获取锁操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AQS把acquireQueued()、addWaiter()等相关同步逻辑的方法均实现好了，但是tryAcquire()还需要子类来实现。</p><p>ReenTrantLock的内部抽象类Sync实现了AQS非公平的tryAcquire(int)方法，即nonfairTryAcquire(int)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">final Thread current = Thread.currentThread();</span><br><span class="line">int c = getState();</span><br><span class="line">if (c == 0) &#123;</span><br><span class="line">if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">setExclusiveOwnerThread(current);</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">int nextc = c + acquires;</span><br><span class="line">if (nextc &lt; 0) // overflow</span><br><span class="line">throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">setState(nextc);</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>神奇的是，公平版的tryAcquire(int)方法实现却又不在Sync中，Doug Lea将其放在Sync的子类FairSync中实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">final Thread current = Thread.currentThread();</span><br><span class="line">int c = getState();</span><br><span class="line">if (c == 0) &#123;</span><br><span class="line">if (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">compareAndSetState(0, acquires)) &#123;</span><br><span class="line">setExclusiveOwnerThread(current);</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">int nextc = c + acquires;</span><br><span class="line">if (nextc &lt; 0)</span><br><span class="line">throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">setState(nextc);</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，公平模式和非公平模式下的代码高度相似，只不过是在c == 0的情况下多了一次!hasQueuedPredecessors()过程(hasQueuedPredecessors是AQS的方法)。</p><p>其实，类似这样的绕来绕去，Doug Lea在AQS独占和共享模式下响应线程中断的相关代码里也玩过一次，至于为啥，小菜鸟不敢妄猜大佬的想法(主要是怕猜错了，以后被打脸，哈哈)。</p><p>最后，总结一下ReenTrantLock的lock()方法：</p><ul><li>ReenTrantLock的lock()方法是通过其内部抽象类Sync的lock()方法来实现的；</li><li>Sync没有直接实现lock()方法，由其方法实现由ReentrantLock的内部类FairSync、NonfairSync来完成;</li><li>Sync继承自AQS，而FairSync、NonfairSync又继承了Sync，故Sync、FairSync、NonfairSync均是AQS的子类；</li><li>FairSync、NonfairSync的lock()方法是调用AQS的acquire(1)来实现的，AQS的acquire(int)方法又涉及到tryAcquire(int)方法，但是AQS没有实现tryAcquire(int)方法，是由其子类来实现的。</li></ul><h3 id="unlock"><a href="#unlock" class="headerlink" title="unlock()"></a>unlock()</h3><p>接着看ReenTrantLock的unlock()方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void unlock() &#123;</span><br><span class="line">sync.release(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用的是内部抽象类Sync的release(1)方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">if (tryRelease(arg)) &#123;</span><br><span class="line">Node h = head;</span><br><span class="line">if (h != null &amp;&amp; h.waitStatus != 0)</span><br><span class="line">unparkSuccessor(h);</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要涉及到tryRelease(int)和unparkSuccessor(Node)方法，AQS直接实现了unparkSuccessor(Node)方法，但只声明了tryRelease(int)方法，说明实现是交给Sync来完成的，果不其然，在Sync中找到了该方法，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">int c = getState() - releases;</span><br><span class="line">if (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">throw new IllegalMonitorStateException();</span><br><span class="line">boolean free = false;</span><br><span class="line">if (c == 0) &#123;</span><br><span class="line">free = true;</span><br><span class="line">setExclusiveOwnerThread(null);</span><br><span class="line">&#125;</span><br><span class="line">setState(c);</span><br><span class="line">return free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，ReenTrantLock的unlock()与lock()一样，均是基于AQS来实现的。</p><p>同时，通过lock()和unlock()的相关实现代码，我们发现ReentrantLock与synchronized一样，是可重入锁。</p><h3 id="tryLock"><a href="#tryLock" class="headerlink" title="tryLock()"></a>tryLock()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean tryLock() &#123;</span><br><span class="line">return sync.nonfairTryAcquire(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，tryLock()调用的是Sync的nonfairTryAcquire(int)方法，本质上只使用了AQS的tryAcquire(int)方法，回顾lock()，其依赖的是AQS的acquire(int)方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于，tryLock()只走了tryAcquire()这一步，直接尝试获取锁，获取到则返回true，否则返回false；而lock()方法若第一步没有获取锁，则需要继续执行addWaiter、acquireQueued、selfInterrupt等方法。</p><h3 id="tryLock-long-TimeUnit"><a href="#tryLock-long-TimeUnit" class="headerlink" title="tryLock(long, TimeUnit)"></a>tryLock(long, TimeUnit)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public boolean tryLock(long timeout, TimeUnit unit)</span><br><span class="line">            throws InterruptedException &#123;</span><br><span class="line">return sync.tryAcquireNanos(1, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，tryLock(long, TimeUnit)调用的是内部抽象类Sync的tryAcquireNanos方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final boolean tryAcquireNanos(int arg, long nanosTimeout)</span><br><span class="line">throws InterruptedException &#123;</span><br><span class="line">if (Thread.interrupted())</span><br><span class="line">throw new InterruptedException();</span><br><span class="line">return tryAcquire(arg) ||</span><br><span class="line">doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终执行的是AQS的doAcquireNanos方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private boolean doAcquireNanos(int arg, long nanosTimeout)</span><br><span class="line">throws InterruptedException &#123;</span><br><span class="line">if (nanosTimeout &lt;= 0L)</span><br><span class="line">return false;</span><br><span class="line">final long deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">final Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">boolean failed = true;</span><br><span class="line">try &#123;</span><br><span class="line">for (;;) &#123;</span><br><span class="line">final Node p = node.predecessor();</span><br><span class="line">if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">setHead(node);</span><br><span class="line">p.next = null; // help GC</span><br><span class="line">failed = false;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">if (nanosTimeout &lt;= 0L)</span><br><span class="line">return false;</span><br><span class="line">if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">LockSupport.parkNanos(this, nanosTimeout);</span><br><span class="line">if (Thread.interrupted())</span><br><span class="line">throw new InterruptedException();</span><br><span class="line">&#125;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">if (failed)</span><br><span class="line">cancelAcquire(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lockInterruptibly"><a href="#lockInterruptibly" class="headerlink" title="lockInterruptibly()"></a>lockInterruptibly()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void lockInterruptibly() throws InterruptedException &#123;</span><br><span class="line">sync.acquireInterruptibly(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用的仍旧是内部抽象类Sync的方法，acquireInterruptibly(int)方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final void acquireInterruptibly(int arg)</span><br><span class="line">throws InterruptedException &#123;</span><br><span class="line">if (Thread.interrupted())</span><br><span class="line">throw new InterruptedException();</span><br><span class="line">if (!tryAcquire(arg))</span><br><span class="line">doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终调用的是AQS的doAcquireInterruptibly(int)方法。</p><p>至于newCondition()方法的实现，我会在讲解线程协作的时候具体讲解，此处不再赘述。</p><p>至此，我们就把ReentrantLock如何实现Lock()接口讲解完毕了，可以发现，其各个方法的实现均强依赖AQS，所以，各位小伙伴想将ReentrantLock彻底征服，一定要将AQS吃透呀，哈哈。</p><p>跟完了源码，下面分享一下如何使用Lock。</p><h2 id="如何使用Lock"><a href="#如何使用Lock" class="headerlink" title="如何使用Lock"></a>如何使用Lock</h2><p>对引言中的程序通过Lock来进行改造：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public class CountWithLock &#123;</span><br><span class="line"></span><br><span class="line">    private volatile static int count = 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        CountDownLatch countDownLatch = new CountDownLatch(2);</span><br><span class="line"></span><br><span class="line">        Lock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">        // 启动线程A</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                for(int i=0; i&lt;100000; i++)&#123;</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    try&#123;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;catch (Exception e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;finally &#123;</span><br><span class="line">                        lock.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        // 启动线程B</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                for(int i=0; i&lt;100000; i++)&#123;</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    try&#123;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;catch (Exception e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;finally &#123;</span><br><span class="line">                        lock.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        // main线程等待线程A和B计算完毕</span><br><span class="line">        countDownLatch.await();</span><br><span class="line"></span><br><span class="line">        // main线程打印结果</span><br><span class="line">        System.out.println(&quot;count: &quot; + CountWithLock.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多次运行该程序，其结果均是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">count: 200000</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>接着测试一下lockInterruptibly()：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public class LockInterruptTest &#123;</span><br><span class="line"></span><br><span class="line">    // 线程工具，用于中断等待的线程</span><br><span class="line">    static class ThreadUtil extends Thread&#123;</span><br><span class="line"></span><br><span class="line">        private Thread thread;</span><br><span class="line"></span><br><span class="line">        public ThreadUtil(Thread thread) &#123;</span><br><span class="line">            this.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            // 3秒后中断传入的线程</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(3000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            thread.interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        // 创建Lock</span><br><span class="line">        final Lock lock = new ReentrantLock();</span><br><span class="line">        lock.lock();</span><br><span class="line">        // 主线程休眠1秒，保证主线程在子线程之前获取到锁</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        System.out.println(&quot;主线程获取到锁&quot;);</span><br><span class="line">        // 创建子线程</span><br><span class="line">        Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                long start = System.currentTimeMillis();</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; 启动&quot;);</span><br><span class="line">                    lock.lockInterruptibly();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; interrupted&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                long end = System.currentTimeMillis();</span><br><span class="line">                long use_time = (end - start) / 1000;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot; 等待了&quot; + use_time + &quot;秒&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        // 3秒后中断等待的子线程t1</span><br><span class="line">        new ThreadUtil(t1).start();</span><br><span class="line">        System.out.println(&quot;主线程即将进行1000秒的IO操作&quot;);</span><br><span class="line">        Thread.sleep(1000000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">主线程获取到锁</span><br><span class="line">主线程即将进行1000秒的IO操作</span><br><span class="line">Thread-0 启动</span><br><span class="line">Thread-0 interrupted</span><br><span class="line">Thread-0 等待了3秒</span><br></pre></td></tr></table></figure><p>可以看出，lockInterruptibly()方法可以使等待获取锁的线程响应中断，避免长时等待。</p><p>上述程序如果采用lock()方法，则等待线程是不会响应中断的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public class LockInterruptTest &#123;</span><br><span class="line"></span><br><span class="line">    // 线程工具，用于中断等待的线程</span><br><span class="line">    static class ThreadUtil extends Thread&#123;</span><br><span class="line"></span><br><span class="line">        private Thread thread;</span><br><span class="line"></span><br><span class="line">        public ThreadUtil(Thread thread) &#123;</span><br><span class="line">            this.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            // 3秒后中断传入的线程</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(3000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            thread.interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        // 创建Lock</span><br><span class="line">        final Lock lock = new ReentrantLock();</span><br><span class="line">        lock.lock();</span><br><span class="line">        // 主线程休眠1秒，保证主线程在子线程之前获取到锁</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        System.out.println(&quot;主线程获取到锁&quot;);</span><br><span class="line">        // 创建子线程</span><br><span class="line">        Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                long start = System.currentTimeMillis();</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; 启动&quot;);                </span><br><span class="line">                    lock.lock();</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; interrupted&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                long end = System.currentTimeMillis();</span><br><span class="line">                long use_time = (end - start) / 1000;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot; 等待了&quot; + use_time + &quot;秒&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        // 3秒后中断等待的子线程t1</span><br><span class="line">        new ThreadUtil(t1).start();</span><br><span class="line">        System.out.println(&quot;主线程即将进行1000秒的IO操作&quot;);</span><br><span class="line">        Thread.sleep(1000000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等待3秒之后，结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">主线程获取到锁</span><br><span class="line">主线程即将进行1000秒的IO操作</span><br><span class="line">Thread-0 启动</span><br></pre></td></tr></table></figure><p>说明等待获取锁的线程是不会响应中断。</p><p><strong>参考文献：</strong></p><ul><li><a href="https://www.cnblogs.com/dolphin0520/p/3923737.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3923737.html</a></li><li><a href="https://www.cnblogs.com/shixm/p/5490026.html" target="_blank" rel="noopener">https://www.cnblogs.com/shixm/p/5490026.html</a></li><li><a href="https://www.cnblogs.com/xiaoxi/p/9140541.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaoxi/p/9140541.html</a></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/10431632-86426e609c966a5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>欢迎您扫一扫上面的二维码，关注我的微信公众号！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;synchronized关键字虽然可以解决大部分多线程锁的问题，但是仍旧存在下述问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;假如持有锁的某线程因等待长时IO或者其他原因阻塞，其他等待的线程无法响应中断，只能不断等待；&lt;/li&gt;
&lt;li&gt;多线程下只有读操作是不会发生冲突的，但synch
      
    
    </summary>
    
      <category term="并发编程" scheme="http://ruanshubin.top/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://ruanshubin.top/tags/Java/"/>
    
      <category term="并发" scheme="http://ruanshubin.top/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java的锁机制--synchronsized关键字</title>
    <link href="http://ruanshubin.top/2019/05/20/Java%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6--synchronsized%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://ruanshubin.top/2019/05/20/Java的锁机制--synchronsized关键字/</id>
    <published>2019-05-20T09:20:00.000Z</published>
    <updated>2019-09-16T01:37:16.307Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>高并发环境下，多线程可能需要同时访问一个资源，并交替执行非原子性的操作，很容易出现最终结果与期望值相违背的情况，或者直接引发程序错误。</p><p>举个简单示例，存在一个初始静态变量count=0，两个线程分别对count进行100000次加1操作，期望的结果是200000，实际是这样的吗？写个程序跑下看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class CountWithoutSyn &#123;</span><br><span class="line"></span><br><span class="line">    private volatile static int count = 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        CountDownLatch countDownLatch = new CountDownLatch(2);</span><br><span class="line"></span><br><span class="line">        // 启动线程A</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                for(int i=0; i&lt;100000; i++)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        // 启动线程B</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                for(int i=0; i&lt;100000; i++)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        // main线程等待线程A和B计算完毕</span><br><span class="line">        countDownLatch.await();</span><br><span class="line"></span><br><span class="line">        // main线程打印结果</span><br><span class="line">        System.out.println(&quot;count: &quot; + CountWithoutSyn.count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多次运行上述程序，会发现最终结果可能出现不是200000的情况，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">count: 150218</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>之所以出现这种情况的原因是，count++不是一个原子性的操作，所谓原子性，说的就是操作不可分割。</p><p>count++分为3个步骤：</p><ul><li>从内存读取count的值；</li><li>对count值执行+1操作；</li><li>将count的值写回内存；</li></ul><p>比如当前count累加到了101，此时，线程A和B同时拿到了count的值为101，线程A对count加1后将102写回内存，同时线程B也对count加1后将102写回内存，而实际结果应该为103，所以丢失了1次更新。</p><p>故高并发环境下，多线程同时对共享变量执行非原子的操作，很容易出现丢失更新的问题。</p><p>解决办法很简单，将整个非原子的操作加锁，从而变成原子性的操作就可以了。</p><p>Java加锁的方式主要有2种，synchronnized关键字和Lock接口。</p><p>下面分别阐述这两种方式，本文先讲解synchronnized。</p><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>在Java中，每一个对象都有一个锁标记(monitor)，也称之为监视器，多线程同时访问某个对象时，线程只有获取了该对象的锁才能访问。</p><p>该锁属于典型的互斥锁，即一旦一个线程获取到锁之后，其他线程只能等待。</p><p>synchronize关键字可以标记方法或者代码块，当某个线程调用该对象的synchronize方法或者访问synchronize代码块时，该线程便获得了该对象的锁，其他线程暂时无法访问这个方法，只有等待这个方法执行完毕或者代码块执行完毕，该线程才会释放该对象的锁，其他线程才能执行这个方法或者代码块。</p><p>对引言中的程序通过synchronized来进行改造：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class CountWithSyn &#123;</span><br><span class="line">    </span><br><span class="line">    private volatile static int count = 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        CountDownLatch countDownLatch = new CountDownLatch(2);</span><br><span class="line"></span><br><span class="line">        Object lock = new Object();</span><br><span class="line"></span><br><span class="line">        // 启动线程A</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                synchronized (lock)&#123;</span><br><span class="line">                    for(int i=0; i&lt;100000; i++)&#123;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        // 启动线程B</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                synchronized (lock)&#123;</span><br><span class="line">                    for(int i=0; i&lt;100000; i++)&#123;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        // main线程等待线程A和B计算完毕</span><br><span class="line">        countDownLatch.await();</span><br><span class="line"></span><br><span class="line">        // main线程打印结果</span><br><span class="line">        System.out.println(&quot;count: &quot; + CountWithSyn.count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多次运行该程序，其结果均是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">count: 200000</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>synchronized代码块使用起来比synchronized方法要灵活得多。因为也许一个方法中只有一部分代码只需要同步，如果此时对整个方法用synchronized进行同步，会影响程序执行效率。而使用synchronized代码块就可以避免这个问题，synchronized代码块可以实现只对需要同步的地方进行同步。</p><p>因为上述程序的非原子操作仅是count++，所以synchronized仅修饰count++即可实现线程安全。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class CountWithSyn &#123;</span><br><span class="line"></span><br><span class="line">    private volatile static int count = 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        CountDownLatch countDownLatch = new CountDownLatch(2);</span><br><span class="line"></span><br><span class="line">        Object lock = new Object();</span><br><span class="line"></span><br><span class="line">        // 启动线程A</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                for(int i=0; i&lt;100000; i++)&#123;</span><br><span class="line">                    synchronized (lock)&#123;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        // 启动线程B</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                for(int i=0; i&lt;100000; i++)&#123;</span><br><span class="line">                    synchronized (lock)&#123;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        // main线程等待线程A和B计算完毕</span><br><span class="line">        countDownLatch.await();</span><br><span class="line"></span><br><span class="line">        // main线程打印结果</span><br><span class="line">        System.out.println(&quot;count: &quot; + CountWithSyn.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是：</p><ol><li><p>当一个线程正在访问一个对象的synchronized方法，那么其他线程不能访问该对象的其他synchronized方法。这个原因很简单，因为一个对象只有一把锁，当一个线程获取了该对象的锁之后，其他线程无法获取该对象的锁，所以无法访问该对象的其他synchronized方法。</p></li><li><p>当一个线程正在访问一个对象的synchronized方法，那么其他线程能访问该对象的非synchronized方法。这个原因很简单，访问非synchronized方法不需要获得该对象的锁，假如一个方法没用synchronized关键字修饰，说明它不会使用到临界资源，那么其他线程是可以访问这个方法的，</p></li><li><p>如果一个线程A需要访问对象object1的synchronized方法fun1，另外一个线程B需要访问对象object2的synchronized方法fun1，即使object1和object2是同一类型），也不会产生线程安全问题，因为他们访问的是不同的对象，所以不存在互斥问题。</p></li></ol><p>那么，synchronized关键字底层是如何实现的呢？反编译它的字节码看一下，如下述代码的字节码为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class SynCode &#123;</span><br><span class="line"></span><br><span class="line">    private Object lock = new Object();</span><br><span class="line"></span><br><span class="line">    public void method1()&#123;</span><br><span class="line">        synchronized (lock)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void method2()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void method3()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/10431632-836186f863fff22c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>从反编译获得的字节码可以看出，synchronized代码块实际上多了monitorenter和monitorexit两条指令。monitorenter指令执行时会让对象的锁计数加1，而monitorexit指令执行时会让对象的锁计数减1，其实这个与操作系统里面的PV操作很像，操作系统里面的PV操作就是用来控制多个线程对临界资源的访问。</p><p>对于synchronized方法，执行中的线程识别该方法的method_info结构是否有ACC_SYNCHRONIZED标记设置，然后它自动获取对象的锁，调用方法，最后释放锁。如果有异常发生，线程自动释放锁。</p><p><strong>对于synchronized方法或者synchronized代码块，当出现异常时，JVM会自动释放当前线程占用的锁，因此不会由于异常导致出现死锁现象。</strong></p><p><strong>参考文献：</strong></p><ul><li><a href="https://www.cnblogs.com/dolphin0520/p/3923737.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3923737.html</a></li><li><a href="https://www.cnblogs.com/shixm/p/5490026.html" target="_blank" rel="noopener">https://www.cnblogs.com/shixm/p/5490026.html</a></li><li><a href="https://www.cnblogs.com/xiaoxi/p/9140541.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaoxi/p/9140541.html</a></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/10431632-86426e609c966a5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>欢迎您扫一扫上面的二维码，关注我的微信公众号！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;高并发环境下，多线程可能需要同时访问一个资源，并交替执行非原子性的操作，很容易出现最终结果与期望值相违背的情况，或者直接引发程序错误。&lt;/p
      
    
    </summary>
    
      <category term="并发编程" scheme="http://ruanshubin.top/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://ruanshubin.top/tags/Java/"/>
    
      <category term="并发" scheme="http://ruanshubin.top/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>浅谈线程间的协作机制</title>
    <link href="http://ruanshubin.top/2019/05/07/%E6%B5%85%E8%B0%88%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E5%8D%8F%E4%BD%9C%E6%9C%BA%E5%88%B6/"/>
    <id>http://ruanshubin.top/2019/05/07/浅谈线程间的协作机制/</id>
    <published>2019-05-07T09:08:00.000Z</published>
    <updated>2019-09-16T01:37:16.335Z</updated>
    
    <content type="html"><![CDATA[<p><strong>注意：如无特殊说明，本文源码分析基于的Java JDK版本均为1.8。</strong></p><h2 id="等待-通知机制"><a href="#等待-通知机制" class="headerlink" title="等待/通知机制"></a>等待/通知机制</h2><p>假设这样的情景，只要线程A修改了某值value，则线程B则对新的value值进行某些操作，比较容易想到的方法是，线程B不断循环访问value，一旦感知到变化，则执行相应逻辑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 线程A</span><br><span class="line">set value = newValue</span><br><span class="line"></span><br><span class="line">// 线程B</span><br><span class="line">for(;;)&#123;</span><br><span class="line">while(newValue != oldValue)&#123;</span><br><span class="line">doSomething(newValue);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果value值发生变化的频率较低，则线程B不断自旋获取value的值，过多的无效尝试极大地浪费系统处理资源。</p><p>改进的方法是，每一段时间(如1s)去访问一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 线程A</span><br><span class="line">set value = newValue</span><br><span class="line"></span><br><span class="line">// 线程B</span><br><span class="line">for(;;)&#123;</span><br><span class="line">while(newValue != oldValue)&#123;</span><br><span class="line">doSomething(newValue);</span><br><span class="line">&#125;</span><br><span class="line">try &#123;</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改进后，较少了较多的无效尝试，降低了对处理器资源的浪费，但是休眠时间的大小难以确定：</p><ol><li>休眠时间太大，不能在休眠期间及时感知数据的变化，实时性较差；</li><li>休眠时间过小，实时性提高的同时，增加了无效尝试的次数，造成了系统处理资源的浪费。</li></ol><p>考虑到上述监听机制上述的困境，线程间协作采用的是等待/通知机制。</p><p>原理就是，当线程A完成对数据的修改之后，会通过一定的机制通知线程B来获取新的数据值来进行相关业务处理，线程B处理完之后挂起等待后续线程A的通知。</p><p>等待/通知机制是所有Java对象均具备的，因为相关方法是定义在所有对象的超类java.lang.Object上的。</p><p>相关方法描述如下：</p><div class="table-container"><table><thead><tr><th>方法名称</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td>notify()</td><td style="text-align:center">通知一个在对象上等待的线程，使其从wait()返回，而返回的前提是该线程获取到对象的锁</td></tr><tr><td>notifyAll()</td><td style="text-align:center">通知所有等待在该对象上的线程</td></tr><tr><td>wait()</td><td style="text-align:center">调用wait()方法后，会释放对象的锁，并进入WAITING状态</td></tr><tr><td>wait(long)</td><td style="text-align:center">超时等待一段时间，如果没有通知就超时返回</td></tr><tr><td>wait(long, int)</td><td style="text-align:center">超时时间更细粒度的控制，可以达到毫秒</td></tr></tbody></table></div><h2 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait()/notify()"></a>wait()/notify()</h2><h3 id="入门实例"><a href="#入门实例" class="headerlink" title="入门实例"></a>入门实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class WaitAndNotifyDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Object lock = new Object();</span><br><span class="line"></span><br><span class="line">        // 线程A</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;线程A等待获取锁&quot;);</span><br><span class="line">                synchronized (lock) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        System.out.println(&quot;线程A获取锁&quot;);</span><br><span class="line">                        Thread.sleep(3000);</span><br><span class="line">                        System.out.println(&quot;线程A将要运行wait()进入等待&quot;);</span><br><span class="line">                        lock.wait();</span><br><span class="line">                        System.out.println(&quot;线程A等待结束&quot;);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        // 线程B</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;线程B等待获取锁&quot;);</span><br><span class="line">                synchronized (lock) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        System.out.println(&quot;线程B获取锁&quot;);</span><br><span class="line">                        Thread.sleep(3000);</span><br><span class="line">                        System.out.println(&quot;线程B将要运行notify()唤醒其他wait状态的线程&quot;);</span><br><span class="line">                        lock.notify();</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">线程A等待获取锁</span><br><span class="line">线程A获取锁</span><br><span class="line">线程B等待获取锁</span><br><span class="line">线程A将要运行wait()进入等待</span><br><span class="line">线程B获取锁</span><br><span class="line">线程B将要运行notify()唤醒其他wait状态的线程</span><br><span class="line">线程A等待结束</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>需要注意的是：Thread的sleep()方法仅是让出CPU时间片，让其他线程有机会执行，但是sleep()方法不会释放其持有的对象锁，仅当调用对象的wait()方法才会释放对象锁。</p><h3 id="wait-方法"><a href="#wait-方法" class="headerlink" title="wait()方法"></a>wait()方法</h3><p>进入到Object的wait()方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final void wait() throws InterruptedException &#123;</span><br><span class="line">wait(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，其底层调用的是Object的重载方法wait(long):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public final native void wait(long timeout) throws InterruptedException;</span><br></pre></td></tr></table></figure><p>重载方法wait(long)是native方法，方法实现可通过OpenJDK来查看(Object.c)来找到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static JNINativeMethod methods[] = &#123;</span><br><span class="line">    &#123;&quot;hashCode&quot;,    &quot;()I&quot;,                    (void *)&amp;JVM_IHashCode&#125;,</span><br><span class="line">    &#123;&quot;wait&quot;,        &quot;(J)V&quot;,                   (void *)&amp;JVM_MonitorWait&#125;,</span><br><span class="line">    &#123;&quot;notify&quot;,      &quot;()V&quot;,                    (void *)&amp;JVM_MonitorNotify&#125;,</span><br><span class="line">    &#123;&quot;notifyAll&quot;,   &quot;()V&quot;,                    (void *)&amp;JVM_MonitorNotifyAll&#125;,</span><br><span class="line">    &#123;&quot;clone&quot;,       &quot;()Ljava/lang/Object;&quot;,   (void *)&amp;JVM_Clone&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中，JVM_MonitorWait和JVM_MonitorNotify分别对应于wait()和notify()方法，JVM_MonitorWait方法声明是在jvm.h中，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT void JNICALL</span><br><span class="line">JVM_MonitorWait(JNIEnv *env, jobject obj, jlong ms);</span><br></pre></td></tr></table></figure><p>方法实现为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">JVM_ENTRY(void, JVM_MonitorWait(JNIEnv* env, jobject handle, jlong ms))</span><br><span class="line">  JVMWrapper(&quot;JVM_MonitorWait&quot;);</span><br><span class="line">  Handle obj(THREAD, JNIHandles::resolve_non_null(handle));</span><br><span class="line">  assert(obj-&gt;is_instance() || obj-&gt;is_array(), &quot;JVM_MonitorWait must apply to an object&quot;);</span><br><span class="line">  JavaThreadInObjectWaitState jtiows(thread, ms != 0);</span><br><span class="line">  if (JvmtiExport::should_post_monitor_wait()) &#123;</span><br><span class="line">    JvmtiExport::post_monitor_wait((JavaThread *)THREAD, (oop)obj(), ms);</span><br><span class="line">  &#125;</span><br><span class="line">  ObjectSynchronizer::wait(obj, ms, CHECK);</span><br><span class="line">JVM_END</span><br></pre></td></tr></table></figure><p>JVM_MonitorWait方法最终调用了ObjectSynchronizer的wait方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void ObjectSynchronizer::wait(Handle obj, jlong millis, TRAPS) &#123;</span><br><span class="line">  if (UseBiasedLocking) &#123;</span><br><span class="line">    BiasedLocking::revoke_and_rebias(obj, false, THREAD);</span><br><span class="line">    assert(!obj-&gt;mark()-&gt;has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  if (millis &lt; 0) &#123;</span><br><span class="line">    TEVENT (wait - throw IAX) ;</span><br><span class="line">    THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;timeout value is negative&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  ObjectMonitor* monitor = ObjectSynchronizer::inflate(THREAD, obj());</span><br><span class="line">  DTRACE_MONITOR_WAIT_PROBE(monitor, obj(), THREAD, millis);</span><br><span class="line">  monitor-&gt;wait(millis, true, THREAD);</span><br><span class="line"> </span><br><span class="line">  /* This dummy call is in place to get around dtrace bug 6254741.  Once</span><br><span class="line">     that&apos;s fixed we can uncomment the following line and remove the call */</span><br><span class="line">  // DTRACE_MONITOR_PROBE(waited, monitor, obj(), THREAD);</span><br><span class="line">  dtrace_waited_probe(monitor, obj, THREAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终，是通过调用ObjectMonitor的wait()方法来实现等待的，其主要代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">void ObjectMonitor::wait(jlong millis, bool interruptible, TRAPS) &#123;</span><br><span class="line">   ...</span><br><span class="line">   // create a node to be put into the queue</span><br><span class="line">   // Critically, after we reset() the event but prior to park(), we must check</span><br><span class="line">   // for a pending interrupt.</span><br><span class="line">   ObjectWaiter node(Self);</span><br><span class="line">   node.TState = ObjectWaiter::TS_WAIT ;</span><br><span class="line">   Self-&gt;_ParkEvent-&gt;reset() ;</span><br><span class="line">   OrderAccess::fence();          // ST into Event; membar ; LD interrupted-flag</span><br><span class="line"> </span><br><span class="line">   // Enter the waiting queue, which is a circular doubly linked list in this case</span><br><span class="line">   // but it could be a priority queue or any data structure.</span><br><span class="line">   // _WaitSetLock protects the wait queue.  Normally the wait queue is accessed only</span><br><span class="line">   // by the the owner of the monitor *except* in the case where park()</span><br><span class="line">   // returns because of a timeout of interrupt.  Contention is exceptionally rare</span><br><span class="line">   // so we use a simple spin-lock instead of a heavier-weight blocking lock.</span><br><span class="line"> </span><br><span class="line">   Thread::SpinAcquire (&amp;_WaitSetLock, &quot;WaitSet - add&quot;) ;</span><br><span class="line">   AddWaiter (&amp;node) ;</span><br><span class="line">   Thread::SpinRelease (&amp;_WaitSetLock) ;</span><br><span class="line"> </span><br><span class="line">   if ((SyncFlags &amp; 4) == 0) &#123;</span><br><span class="line">      _Responsible = NULL ;</span><br><span class="line">   &#125;</span><br><span class="line">   intptr_t save = _recursions; // record the old recursion count</span><br><span class="line">   _waiters++;                  // increment the number of waiters</span><br><span class="line">   _recursions = 0;             // set the recursion level to be 1</span><br><span class="line">   exit (Self) ;                    // exit the monitor</span><br><span class="line">   guarantee (_owner != Self, &quot;invariant&quot;) ;</span><br><span class="line">   ...</span><br><span class="line"> </span><br><span class="line">   if (node._notified != 0 &amp;&amp; _succ == Self) &#123;</span><br><span class="line">      node._event-&gt;unpark();</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   // The thread is on the WaitSet list - now park() it.</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个调用链路可以总结如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.wait()--&gt;Object.wait(long)--&gt;JVM_MonitorWait--&gt;ObjectSynchronizer::wait--&gt;ObjectMonitor::wait</span><br></pre></td></tr></table></figure><p>说明对象的Object最终调用的是底层native方法ObjectMonitor::wait，下面介绍一下ObjectMonitor::wait的基本步骤：</p><ul><li>将调用wait()方法的线程封装为ObjectWaiter类的对象node；</li></ul><p>ObjectWriter类声明为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class ObjectWaiter : public StackObj &#123;</span><br><span class="line"> public:</span><br><span class="line">  enum TStates &#123; TS_UNDEF, TS_READY, TS_RUN, TS_WAIT, TS_ENTER, TS_CXQ &#125; ;</span><br><span class="line">  enum Sorted  &#123; PREPEND, APPEND, SORTED &#125; ;</span><br><span class="line">  ObjectWaiter * volatile _next;</span><br><span class="line">  ObjectWaiter * volatile _prev;</span><br><span class="line">  Thread*       _thread;</span><br><span class="line">  ParkEvent *   _event;</span><br><span class="line">  volatile int  _notified ;</span><br><span class="line">  volatile TStates TState ;</span><br><span class="line">  Sorted        _Sorted ;           // List placement disposition</span><br><span class="line">  bool          _active ;           // Contention monitoring is enabled</span><br><span class="line"> public:</span><br><span class="line">  ObjectWaiter(Thread* thread);</span><br><span class="line"> </span><br><span class="line">  void wait_reenter_begin(ObjectMonitor *mon);</span><br><span class="line">  void wait_reenter_end(ObjectMonitor *mon);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看出，ObjectWaiter是双向链表结构，保存了当前线程_thread及当前的状态TState等数据，每个等待锁的线程都会被封装成ObjectWaiter对象。</p><ul><li>通过ObjectMonitor::AddWaiter方法将node添加到_WaitSet列表中;</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">inline void ObjectMonitor::AddWaiter(ObjectWaiter* node) &#123;</span><br><span class="line">  assert(node != NULL, &quot;should not dequeue NULL node&quot;);</span><br><span class="line">  assert(node-&gt;_prev == NULL, &quot;node already in list&quot;);</span><br><span class="line">  assert(node-&gt;_next == NULL, &quot;node already in list&quot;);</span><br><span class="line">  // put node at end of queue (circular doubly linked list)</span><br><span class="line">  if (_WaitSet == NULL) &#123;</span><br><span class="line">    _WaitSet = node;</span><br><span class="line">    node-&gt;_prev = node;</span><br><span class="line">    node-&gt;_next = node;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    ObjectWaiter* head = _WaitSet ;</span><br><span class="line">    ObjectWaiter* tail = head-&gt;_prev;</span><br><span class="line">    assert(tail-&gt;_next == head, &quot;invariant check&quot;);</span><br><span class="line">    tail-&gt;_next = node;</span><br><span class="line">    head-&gt;_prev = node;</span><br><span class="line">    node-&gt;_next = head;</span><br><span class="line">    node-&gt;_prev = tail;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用此方法前后需要获取和释放_WaitSet列表的_WaitSetLock锁。从注释中可以看到，_WaitSet列表其实是一个双向循环链表。</p><ul><li>通过ObjectMonitor::exit方法释放当前的ObjectMonitor对象，这样其它竞争线程就可以获取该ObjectMonitor对象;</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">void ATTR ObjectMonitor::exit(TRAPS) &#123;</span><br><span class="line">   Thread * Self = THREAD ;</span><br><span class="line">   if (THREAD != _owner) &#123;</span><br><span class="line">     if (THREAD-&gt;is_lock_owned((address) _owner)) &#123;</span><br><span class="line">       // Transmute _owner from a BasicLock pointer to a Thread address.</span><br><span class="line">       // We don&apos;t need to hold _mutex for this transition.</span><br><span class="line">       // Non-null to Non-null is safe as long as all readers can</span><br><span class="line">       // tolerate either flavor.</span><br><span class="line">       assert (_recursions == 0, &quot;invariant&quot;) ;</span><br><span class="line">       _owner = THREAD ;</span><br><span class="line">       _recursions = 0 ;</span><br><span class="line">       OwnerIsThread = 1 ;</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">       // NOTE: we need to handle unbalanced monitor enter/exit</span><br><span class="line">       // in native code by throwing an exception.</span><br><span class="line">       // TODO: Throw an IllegalMonitorStateException ?</span><br><span class="line">       TEVENT (Exit - Throw IMSX) ;</span><br><span class="line">       assert(false, &quot;Non-balanced monitor enter/exit!&quot;);</span><br><span class="line">       if (false) &#123;</span><br><span class="line">          THROW(vmSymbols::java_lang_IllegalMonitorStateException());</span><br><span class="line">       &#125;</span><br><span class="line">       return;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最终通过底层的park()方法挂起当前线程。</li></ul><h3 id="notify-方法"><a href="#notify-方法" class="headerlink" title="notify()方法"></a>notify()方法</h3><p>与wait()方法类似，最终也是调用的底层native方法:ObjectMonitor::notify(TRAPS)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">void ObjectMonitor::notify(TRAPS) &#123;</span><br><span class="line">  CHECK_OWNER();</span><br><span class="line">  if (_WaitSet == NULL) &#123;</span><br><span class="line">     TEVENT (Empty-Notify) ;</span><br><span class="line">     return ;</span><br><span class="line">  &#125;</span><br><span class="line">  DTRACE_MONITOR_PROBE(notify, this, object(), THREAD);</span><br><span class="line"> </span><br><span class="line">  int Policy = Knob_MoveNotifyee ;</span><br><span class="line"> </span><br><span class="line">  Thread::SpinAcquire (&amp;_WaitSetLock, &quot;WaitSet - notify&quot;) ;</span><br><span class="line">  ObjectWaiter * iterator = DequeueWaiter() ;</span><br><span class="line">  if (iterator != NULL) &#123;</span><br><span class="line">     TEVENT (Notify1 - Transfer) ;</span><br><span class="line">     guarantee (iterator-&gt;TState == ObjectWaiter::TS_WAIT, &quot;invariant&quot;) ;</span><br><span class="line">     guarantee (iterator-&gt;_notified == 0, &quot;invariant&quot;) ;</span><br><span class="line">     if (Policy != 4) &#123;</span><br><span class="line">        iterator-&gt;TState = ObjectWaiter::TS_ENTER ;</span><br><span class="line">     &#125;</span><br><span class="line">     iterator-&gt;_notified = 1 ;</span><br><span class="line"> </span><br><span class="line">     ObjectWaiter * List = _EntryList ;</span><br><span class="line">     if (List != NULL) &#123;</span><br><span class="line">        assert (List-&gt;_prev == NULL, &quot;invariant&quot;) ;</span><br><span class="line">        assert (List-&gt;TState == ObjectWaiter::TS_ENTER, &quot;invariant&quot;) ;</span><br><span class="line">        assert (List != iterator, &quot;invariant&quot;) ;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     if (Policy == 0) &#123;       // prepend to EntryList</span><br><span class="line">         </span><br><span class="line">     &#125; else if (Policy == 1) &#123;      // append to EntryList</span><br><span class="line">         </span><br><span class="line">     &#125; else if (Policy == 2) &#123;      // prepend to cxq</span><br><span class="line">         </span><br><span class="line">     &#125;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ObjectMonitor::notify(TRAPS)方法的基本步骤为：</p><ul><li><p>若_WaitSet为NULL，即没有需要唤醒的线程，则直接退出；</p></li><li><p>通过ObjectMonitor::DequeueWaiter方法，获取_WaitSet列表中的第一个ObjectWaiter节点；</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">inline ObjectWaiter* ObjectMonitor::DequeueWaiter() &#123;</span><br><span class="line">  // dequeue the very first waiter</span><br><span class="line">  ObjectWaiter* waiter = _WaitSet;</span><br><span class="line">  if (waiter) &#123;</span><br><span class="line">    DequeueSpecificWaiter(waiter);</span><br><span class="line">  &#125;</span><br><span class="line">  return waiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>根据不同的策略，将取出来的ObjectWaiter节点，加入到_EntryList或则通过Atomic::cmpxchg_ptr指令进行自旋操作cxq。</li></ul><h3 id="notifyAll-方法"><a href="#notifyAll-方法" class="headerlink" title="notifyAll()方法"></a>notifyAll()方法</h3><p>lock.notifyAll()方法最终通过ObjectMonitor的void notifyAll(TRAPS)实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">void ObjectMonitor::notifyAll(TRAPS) &#123;</span><br><span class="line">  ...</span><br><span class="line"> </span><br><span class="line">  for (;;) &#123;</span><br><span class="line">     iterator = DequeueWaiter () ;</span><br><span class="line">     if (iterator == NULL) break ;</span><br><span class="line">     TEVENT (NotifyAll - Transfer1) ;</span><br><span class="line">     ++Tally ;</span><br><span class="line"> </span><br><span class="line">     ...</span><br><span class="line"> </span><br><span class="line">     ObjectWaiter * List = _EntryList ;</span><br><span class="line">     if (List != NULL) &#123;</span><br><span class="line">        assert (List-&gt;_prev == NULL, &quot;invariant&quot;) ;</span><br><span class="line">        assert (List-&gt;TState == ObjectWaiter::TS_ENTER, &quot;invariant&quot;) ;</span><br><span class="line">        assert (List != iterator, &quot;invariant&quot;) ;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     if (Policy == 0) &#123;       // prepend to EntryList</span><br><span class="line">         </span><br><span class="line">     &#125; else if (Policy == 1) &#123;      // append to EntryList</span><br><span class="line">         </span><br><span class="line">     &#125; else if (Policy == 2) &#123;      // prepend to cxq</span><br><span class="line">         </span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法和notify()方法比较类似，不同的是，notifyAll()通过for循环取出_WaitSet的ObjectWaiter节点，并根据不同策略，加入到_EntryList或则进行自旋操作。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li>wait()方法会释放所占有的ObjectMonitor对象；</li><li>notify()和notifyAll()并不会释放所占有的ObjectMonitor对象，只是将相应的等待线程从_WaitSet转移到_EntryList中，然后等待竞争锁；</li><li>真正释放ObjectMonitor对象的时机是，退出同步代码块或同步方法时，即执行monitorexit指令时；</li><li>一旦释放ObjectMonitor对象后，_EntityList中ObjectWaiter节点所保存的线程即可以参与竞争ObjectMonitor对象了；</li><li>wait()/notify()基本就是C/C++版的AQS(啥是AQS，可参见我的<a href="https://www.jianshu.com/p/0f876ead2846" target="_blank" rel="noopener">另外一篇文章</a>)。</li></ol><h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p>Condition出现在JDK1.5中的J.U.C包中，由Doug Lea李大爷操刀设计并开发完成。</p><p>Condition是个接口，其方法有：</p><p><img src="https://upload-images.jianshu.io/upload_images/10431632-ac67fb575dd3eab8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>await()方法对应于Object的wait();</li><li>signal()方法对应于Object的notify();</li><li>signalAll()方法对应于Object的notifyAll();</li></ul><p>像Object的wait()/notify()方法必须在Synchronized中调用类似，Condition的await()/siganl()方法必须在Lock中调用。</p><p>Condition接口的实现类是AQS中的ConditionObject。</p><p><img src="https://upload-images.jianshu.io/upload_images/10431632-505d7e5f0bcf1884.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>跟进ConditionObject的源码，查看await()的实现方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public final void await() throws InterruptedException &#123;</span><br><span class="line">if (Thread.interrupted())</span><br><span class="line">throw new InterruptedException();</span><br><span class="line">Node node = addConditionWaiter();</span><br><span class="line">int savedState = fullyRelease(node);</span><br><span class="line">int interruptMode = 0;</span><br><span class="line">while (!isOnSyncQueue(node)) &#123;</span><br><span class="line">LockSupport.park(this);</span><br><span class="line">if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">interruptMode = REINTERRUPT;</span><br><span class="line">if (node.nextWaiter != null) // clean up if cancelled</span><br><span class="line">unlinkCancelledWaiters();</span><br><span class="line">if (interruptMode != 0)</span><br><span class="line">reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，其与ObjectMonitor::wait流程基本类似，都是将当前线程封装成node节点，然后添加到等待队列，最后挂起当前线程。</p><p>只不过是ConditionObject实现了Java版的wait()流程，如<strong>Object的wait()方法是通过native的park()方法挂起当前线程的，而ConditionObject则使用的则是LockSupport工具类的park()方法。</strong></p><h3 id="构建Condition对象"><a href="#构建Condition对象" class="headerlink" title="构建Condition对象"></a>构建Condition对象</h3><p>可以通过Lock接口创建Condition对象，Lock接口中定义了newCondition()方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Condition newCondition();</span><br></pre></td></tr></table></figure><p>获取方式如下所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = new ReentrantLock();</span><br><span class="line">Condition c1 = lock.newCondition();</span><br><span class="line">Condition c2 = lock.newCondition();</span><br></pre></td></tr></table></figure><p>ReentrantLock唯一实现了Lock接口，看一下ReentrantLock的对newCondition()的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Condition newCondition() &#123;</span><br><span class="line">return sync.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现调用的是内部类的sync的newCondition()方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final ConditionObject newCondition() &#123;</span><br><span class="line">return new ConditionObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，最终创建的就是AQS中的ConditionObject，由其实现Condition接口的各个方法。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>下面，我们通过Condition的await()/signal()来完成一个小Demo:</p><p>首先定义一个服务MyService:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public class MyService &#123;</span><br><span class="line"></span><br><span class="line">    // 实例化一个ReentrantLock对象</span><br><span class="line">    private ReentrantLock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    // 为线程A注册一个Condition</span><br><span class="line">    public Condition conditionA = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    // 为线程B注册一个Condition</span><br><span class="line">    public Condition conditionB = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    public void awitA()&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;进入了awitA方法&quot;);</span><br><span class="line">            long timeBefore = System.currentTimeMillis();</span><br><span class="line">            // 执行condition等待</span><br><span class="line">            conditionA.await();</span><br><span class="line">            long timeAfter = System.currentTimeMillis();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;等待了：&quot; + (timeAfter-timeBefore)/1000 + &quot; s&quot;);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void awitB()&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;进入了awitB方法&quot;);</span><br><span class="line">            long timeBefore = System.currentTimeMillis();</span><br><span class="line">            // 执行condition等待</span><br><span class="line">            conditionB.await();</span><br><span class="line">            long timeAfter = System.currentTimeMillis();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;等待了：&quot; + (timeAfter-timeBefore)/1000 + &quot; s&quot;);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void signallA()&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(&quot;启动唤醒程序&quot;);</span><br><span class="line">            // 唤醒所有注册conditionA的线程</span><br><span class="line">            conditionA.signalAll();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void signallB()&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(&quot;启动唤醒程序&quot;);</span><br><span class="line">            // 唤醒所有注册conditionB的线程</span><br><span class="line">            conditionB.signalAll();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后构建两个线程，均持有MyService对象：</p><p>线程A:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class MyServiceThreadA implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">    private MyService service;</span><br><span class="line"></span><br><span class="line">    public MyServiceThreadA(MyService service) &#123;</span><br><span class="line">        this.service = service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        service.awitA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程B:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class MyServiceThreadB implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">    private MyService service;</span><br><span class="line"></span><br><span class="line">    public MyServiceThreadB(MyService service) &#123;</span><br><span class="line">        this.service = service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        service.awitB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class ApplicationCondition &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        MyService service = new MyService();</span><br><span class="line">        Runnable runnableA = new MyServiceThreadA(service);</span><br><span class="line">        Runnable runnableB = new MyServiceThreadB(service);</span><br><span class="line"></span><br><span class="line">        new Thread(runnableA, &quot;a&quot;).start();</span><br><span class="line">        new Thread(runnableB, &quot;b&quot;).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(2000);</span><br><span class="line">        // 唤醒所有持有ConditionA的线程</span><br><span class="line">        service.signallA();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(2000);</span><br><span class="line">        // 唤醒所有持有ConditionB的线程</span><br><span class="line">        service.signallB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a进入了awitA方法</span><br><span class="line">b进入了awitB方法</span><br><span class="line">启动唤醒程序</span><br><span class="line">a等待了：2 s</span><br><span class="line">启动唤醒程序</span><br><span class="line">b等待了：4 s</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>可以看到，在实现线程协作时，Condition具有更大的灵活性，比如现在有3个线程A、B、C，线程A更新了某数据，需要通知线程B去拿新数据做搞事情，而C线程继续休眠，此种情况采用Object的wait()/notify()是难以实现的，因为notify()唤醒的线程是难以控制和指定的，而Condition却可以轻松完成这一切。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了线程协作的两种方式，分别为Object的wait()/notify()和Condition的await()/signal()。</p><p>两种方式在原理上基本类似，均实现了等待/通知机制，相比使用Object的wait()、notify()，使用Condition的await()、signal()这种方式实现线程间协作更加安全和高效。因此通常来说比较推荐使用Condition，如阻塞队列实际上使用了Condition来模拟线程间协作。</p><p><strong>参考文献:</strong></p><ul><li><a href="https://www.cnblogs.com/dolphin0520/p/3920385.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3920385.html</a></li><li><a href="http://www.importnew.com/30150.html" target="_blank" rel="noopener">http://www.importnew.com/30150.html</a></li><li><a href="https://blog.csdn.net/qq_38293564/article/details/80432875" target="_blank" rel="noopener">https://blog.csdn.net/qq_38293564/article/details/80432875</a></li><li><a href="https://www.cnblogs.com/superfj/p/7543927.html" target="_blank" rel="noopener">https://www.cnblogs.com/superfj/p/7543927.html</a></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/10431632-86426e609c966a5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>欢迎您扫一扫上面的二维码，关注我的微信公众号！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;注意：如无特殊说明，本文源码分析基于的Java JDK版本均为1.8。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;等待-通知机制&quot;&gt;&lt;a href=&quot;#等待-通知机制&quot; class=&quot;headerlink&quot; title=&quot;等待/通知机制&quot;&gt;&lt;/a&gt;等待/通知
      
    
    </summary>
    
      <category term="并发编程" scheme="http://ruanshubin.top/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://ruanshubin.top/tags/Java/"/>
    
      <category term="并发" scheme="http://ruanshubin.top/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Java并发中的AQS</title>
    <link href="http://ruanshubin.top/2019/05/05/%E6%B5%85%E8%B0%88Java%E5%B9%B6%E5%8F%91%E4%B8%AD%E7%9A%84AQS/"/>
    <id>http://ruanshubin.top/2019/05/05/浅谈Java并发中的AQS/</id>
    <published>2019-05-05T10:52:00.000Z</published>
    <updated>2019-09-16T01:37:16.334Z</updated>
    
    <content type="html"><![CDATA[<p>所谓AQS，指的是AbstractQueuedSynchronizer，它提供了一种实现阻塞锁和一系列依赖FIFO等待队列的同步器的框架，ReentrantLock、Semaphore、CountDownLatch、CyclicBarrier等并发类均是基于AQS来实现的，具体用法是通过继承AQS实现其模板方法，然后将子类作为同步组件的内部类。</p><p>了解一个框架最好的方式是读源码，说干就干。</p><p>AQS是JDK1.5之后才出现的，由大名鼎鼎的Doug Lea李大爷来操刀设计并开发实现，全部源代码(加注释)2315行，整体难度中等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* @since 1.5</span><br><span class="line">* @author Doug Lea</span><br></pre></td></tr></table></figure><h2 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h2><p>在阅读源码前，首先阐述AQS的基本思想及其相关概念。</p><p>AQS基本框架如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/10431632-7d2aa48b9b217bbe.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>AQS维护了一个volatile语义(支持多线程下的可见性)的共享资源变量state和一个FIFO线程等待队列(多线程竞争state被阻塞时会进入此队列)。</p><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>首先说一下共享资源变量state，它是int数据类型的，其访问方式有3种：</p><ul><li>getState()</li><li>setState(int newState)</li><li>compareAndSetState(int expect, int update)</li></ul><p>上述3种方式均是原子操作，其中compareAndSetState()的实现依赖于Unsafe的compareAndSwapInt()方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private volatile int state;</span><br><span class="line"></span><br><span class="line">// 具有内存读可见性语义</span><br><span class="line">protected final int getState() &#123;</span><br><span class="line">return state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具有内存写可见性语义</span><br><span class="line">protected final void setState(int newState) &#123;</span><br><span class="line">state = newState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具有内存读/写可见性语义</span><br><span class="line">protected final boolean compareAndSetState(int expect, int update) &#123;</span><br><span class="line">// See below for intrinsics setup to support this</span><br><span class="line">return unsafe.compareAndSwapInt(this, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>资源的共享方式分为2种：</p><ul><li>独占式(Exclusive)</li></ul><p>只有单个线程能够成功获取资源并执行，如ReentrantLock。</p><ul><li>共享式(Shared)</li></ul><p>多个线程可成功获取资源并执行，如Semaphore/CountDownLatch等。</p><p>AQS将大部分的同步逻辑均已经实现好，继承的自定义同步器只需要实现state的获取(acquire)和释放(release)的逻辑代码就可以，主要包括下面方法：</p><ul><li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li><li>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。</li><li>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li><li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li><li>isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。</li></ul><p>AQS需要子类复写的方法均没有声明为abstract，目的是避免子类需要强制性覆写多个方法，因为一般自定义同步器要么是独占方法，要么是共享方法，只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。</p><p>当然，AQS也支持子类同时实现独占和共享两种模式，如ReentrantReadWriteLock。</p><h3 id="CLH队列-FIFO"><a href="#CLH队列-FIFO" class="headerlink" title="CLH队列(FIFO)"></a>CLH队列(FIFO)</h3><p>AQS是通过内部类Node来实现FIFO队列的，源代码解析如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">static final class Node &#123;</span><br><span class="line"></span><br><span class="line">// 表明节点在共享模式下等待的标记</span><br><span class="line">static final Node SHARED = new Node();</span><br><span class="line">// 表明节点在独占模式下等待的标记</span><br><span class="line">static final Node EXCLUSIVE = null;</span><br><span class="line"></span><br><span class="line">// 表征等待线程已取消的</span><br><span class="line">static final int CANCELLED =  1;</span><br><span class="line">// 表征需要唤醒后续线程</span><br><span class="line">static final int SIGNAL    = -1;</span><br><span class="line">// 表征线程正在等待触发条件(condition)</span><br><span class="line">static final int CONDITION = -2;</span><br><span class="line">// 表征下一个acquireShared应无条件传播</span><br><span class="line">static final int PROPAGATE = -3;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *   SIGNAL: 当前节点释放state或者取消后，将通知后续节点竞争state。</span><br><span class="line"> *   CANCELLED: 线程因timeout和interrupt而放弃竞争state，当前节点将与state彻底拜拜</span><br><span class="line"> *   CONDITION: 表征当前节点处于条件队列中，它将不能用作同步队列节点，直到其waitStatus被重置为0</span><br><span class="line"> *   PROPAGATE: 表征下一个acquireShared应无条件传播</span><br><span class="line"> *   0: None of the above</span><br><span class="line"> */</span><br><span class="line">volatile int waitStatus;</span><br><span class="line"></span><br><span class="line">// 前继节点</span><br><span class="line">volatile Node prev;</span><br><span class="line">// 后继节点</span><br><span class="line">volatile Node next;</span><br><span class="line">// 持有的线程</span><br><span class="line">volatile Thread thread;</span><br><span class="line">// 链接下一个等待条件触发的节点</span><br><span class="line">Node nextWaiter;</span><br><span class="line"></span><br><span class="line">// 返回节点是否处于Shared状态下</span><br><span class="line">final boolean isShared() &#123;</span><br><span class="line">return nextWaiter == SHARED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 返回前继节点</span><br><span class="line">final Node predecessor() throws NullPointerException &#123;</span><br><span class="line">Node p = prev;</span><br><span class="line">if (p == null)</span><br><span class="line">throw new NullPointerException();</span><br><span class="line">else</span><br><span class="line">return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Shared模式下的Node构造函数</span><br><span class="line">Node() &#123;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 用于addWaiter</span><br><span class="line">Node(Thread thread, Node mode) &#123;  </span><br><span class="line">this.nextWaiter = mode;</span><br><span class="line">this.thread = thread;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 用于Condition</span><br><span class="line">Node(Thread thread, int waitStatus) &#123;</span><br><span class="line">this.waitStatus = waitStatus;</span><br><span class="line">this.thread = thread;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，waitStatus非负的时候，表征不可用，正数代表处于等待状态，所以waitStatus只需要检查其正负符号即可，不用太多关注特定值。</p><h2 id="获取资源-独占模式"><a href="#获取资源-独占模式" class="headerlink" title="获取资源(独占模式)"></a>获取资源(独占模式)</h2><h3 id="acquire-int"><a href="#acquire-int" class="headerlink" title="acquire(int)"></a>acquire(int)</h3><p>首先讲解独占模式(Exclusive)下的获取/释放资源过程，其入口方法为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tryAcquire(arg)为线程获取资源的方法函数，在AQS中定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected boolean tryAcquire(int arg) &#123;</span><br><span class="line">throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，该方法是空方法，且由protected修饰，说明该方法需要由子类即自定义同步器来实现。</p><p>acquire()方法至少执行一次tryAcquire(arg)，若返回true，则acquire直接返回，否则进入acquireQueued(addWaiter(Node.EXCLUSIVE), arg)方法。</p><p>acquireQueued方法分为3个步骤：</p><ol><li>addWriter()将当前线程加入到等待队列的尾部，并标记为独占模式；</li><li>acquireQueued()使线程在等待队列中获取资源，直到获取到资源返回，若整个等待过程被中断过，则返回True，否则返回False。</li><li>如果线程在等待过程中被中断过，则先标记上，待获取到资源后再进行自我中断selfInterrupt()，将中断响应掉。</li></ol><p>下面具体看看过程中涉及到的各函数：</p><h3 id="tryAcquire-int"><a href="#tryAcquire-int" class="headerlink" title="tryAcquire(int)"></a>tryAcquire(int)</h3><p>tryAcquire尝试以独占的模式获取资源，如果获取成功则返回True，否则直接返回False，默认实现是抛出UnsupportedOperationException，具体实现由自定义扩展了AQS的同步器来完成。</p><h3 id="addWaiter-Node"><a href="#addWaiter-Node" class="headerlink" title="addWaiter(Node)"></a>addWaiter(Node)</h3><p>addWaiter为当前线程以指定模式创建节点，并将其添加到等待队列的尾部，其源码为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private Node addWaiter(Node mode) &#123;</span><br><span class="line">Node node = new Node(Thread.currentThread(), mode);</span><br><span class="line">// 尝试将节点快速插入等待队列，若失败则执行常规插入(enq方法)</span><br><span class="line">Node pred = tail;</span><br><span class="line">if (pred != null) &#123;</span><br><span class="line">node.prev = pred;</span><br><span class="line">if (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">pred.next = node;</span><br><span class="line">return node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 常规插入</span><br><span class="line">enq(node);</span><br><span class="line">return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看enq(node)方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private Node enq(final Node node) &#123;</span><br><span class="line">for (;;) &#123;</span><br><span class="line">Node t = tail;</span><br><span class="line">if (t == null) &#123; // Must initialize</span><br><span class="line">if (compareAndSetHead(new Node()))</span><br><span class="line">tail = head;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">node.prev = t;</span><br><span class="line">if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">t.next = node;</span><br><span class="line">return t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，常规插入与快速插入相比，有2点不同：</p><ol><li>常规插入是自旋过程(for(;;))，能够保证节点插入成功；</li><li>比快速插入多包含了1种情况，即当前等待队列为空时，需要初始化队列，即将待插入节点设置为头结点，同时为尾节点(因为只有一个嘛)。</li></ol><p>常规插入与快速插入均依赖于CAS，其实现依赖于unsafe类，具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private final boolean compareAndSetHead(Node update) &#123;</span><br><span class="line">return unsafe.compareAndSwapObject(this, headOffset, null, update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private final boolean compareAndSetTail(Node expect, Node update) &#123;</span><br><span class="line">return unsafe.compareAndSwapObject(this, tailOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>unsafe中的cas操作均是native方法，由计算机CPU的cmpxchg指令来保证其原子性。</p><p>接着看acquireQueued()方法：</p><h3 id="acquireQueued-Node-int"><a href="#acquireQueued-Node-int" class="headerlink" title="acquireQueued(Node, int)"></a>acquireQueued(Node, int)</h3><p>相关说明已在代码中注释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">// 标识是否获取资源失败</span><br><span class="line">boolean failed = true;</span><br><span class="line">try &#123;</span><br><span class="line">// 标识当前线程是否被中断过</span><br><span class="line">boolean interrupted = false;</span><br><span class="line">// 自旋操作</span><br><span class="line">for (;;) &#123;</span><br><span class="line">// 获取当前节点的前继节点</span><br><span class="line">final Node p = node.predecessor();</span><br><span class="line">// 如果前继节点为头结点，说明排队马上排到自己了，可以尝试获取资源，若获取资源成功，则执行下述操作</span><br><span class="line">if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">// 将当前节点设置为头结点</span><br><span class="line">setHead(node);</span><br><span class="line">// 说明前继节点已经释放掉资源了，将其next置空，以方便虚拟机回收掉该前继节点</span><br><span class="line">p.next = null; // help GC</span><br><span class="line">// 标识获取资源成功</span><br><span class="line">failed = false;</span><br><span class="line">// 返回中断标记</span><br><span class="line">return interrupted;</span><br><span class="line">&#125;</span><br><span class="line">// 若前继节点不是头结点，或者获取资源失败，</span><br><span class="line">// 则需要通过shouldParkAfterFailedAcquire函数</span><br><span class="line">// 判断是否需要阻塞该节点持有的线程</span><br><span class="line">// 若shouldParkAfterFailedAcquire函数返回true，</span><br><span class="line">// 则继续执行parkAndCheckInterrupt()函数，</span><br><span class="line">// 将该线程阻塞并检查是否可以被中断，若返回true，则将interrupted标志置于true</span><br><span class="line">if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">parkAndCheckInterrupt())</span><br><span class="line">interrupted = true;</span><br><span class="line">&#125;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">// 最终获取资源失败，则当前节点放弃获取资源</span><br><span class="line">if (failed)</span><br><span class="line">cancelAcquire(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体看一下shouldParkAfterFailedAcquire函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// shouldParkAfterFailedAcquire是通过前继节点的waitStatus值来判断是否阻塞当前节点的线程的</span><br><span class="line">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span><br><span class="line">// 获取前继节点的waitStatus值ws</span><br><span class="line">int ws = pred.waitStatus;</span><br><span class="line">// 如果ws的值为Node.SIGNAL(-1)，则直接返回true</span><br><span class="line">// 说明前继节点完成资源的释放或者中断后，会通知当前节点的，回家等通知就好了，不用自旋频繁地来打听消息</span><br><span class="line">if (ws == Node.SIGNAL)</span><br><span class="line">return true;</span><br><span class="line">// 如果前继节点的ws值大于0,即为1,说明前继节点处于放弃状态(Cancelled)</span><br><span class="line">// 那就继续往前遍历，直到当前节点的前继节点的ws值为0或负数</span><br><span class="line">// 此处代码很关键，节点往前移动就是通过这里来实现的，直到节点的前继节点满足</span><br><span class="line">// if (p == head &amp;&amp; tryAcquire(arg))条件，acquireQueued方法才能够跳出自旋过程</span><br><span class="line">if (ws &gt; 0) &#123;</span><br><span class="line">do &#123;</span><br><span class="line">node.prev = pred = pred.prev;</span><br><span class="line">&#125; while (pred.waitStatus &gt; 0);</span><br><span class="line">pred.next = node;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">// 将前继节点的ws值设置为Node.SIGNAL，以保证下次自旋时，shouldParkAfterFailedAcquire直接返回true</span><br><span class="line">compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>parkAndCheckInterrupt()函数则简单很多，主要调用LockSupport类的park()方法阻塞当前线程，并返回线程是否被中断过。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private final boolean parkAndCheckInterrupt() &#123;</span><br><span class="line">LockSupport.park(this);</span><br><span class="line">return Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，独占模式下，线程获取资源acquire的代码就跟完了，总结一下过程：</p><ol><li>首先线程通过tryAcquire(arg)尝试获取共享资源，若获取成功则直接返回，若不成功，则将该线程以独占模式添加到等待队列尾部，tryAcquire(arg)由继承AQS的自定义同步器来具体实现；</li><li>当前线程加入等待队列后，会通过acquireQueued方法基于CAS自旋不断尝试获取资源，直至获取到资源；</li><li>若在自旋过程中，线程被中断过，acquireQueued方法会标记此次中断，并返回true。</li><li>若acquireQueued方法获取到资源后，返回true，则执行线程自我中断操作selfInterrupt()。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static void selfInterrupt() &#123;</span><br><span class="line">Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="释放资源-独占模式"><a href="#释放资源-独占模式" class="headerlink" title="释放资源(独占模式)"></a>释放资源(独占模式)</h2><p>讲完获取资源，对应的讲一下AQS的释放资源过程，其入口函数为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">if (tryRelease(arg)) &#123;</span><br><span class="line">// 获取到等待队列的头结点h</span><br><span class="line">Node h = head;</span><br><span class="line">// 若头结点不为空且其ws值非0，则唤醒h的后继节点</span><br><span class="line">if (h != null &amp;&amp; h.waitStatus != 0)</span><br><span class="line">unparkSuccessor(h);</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑并不复杂，通过tryRelease(arg)来释放资源，和tryAcquire类似，<strong>tryRelease也是有继承AQS的自定义同步器来具体实现</strong>。</p><h3 id="tryRelease-int"><a href="#tryRelease-int" class="headerlink" title="tryRelease(int)"></a>tryRelease(int)</h3><p>该方法尝试释放指定量的资源。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected boolean tryRelease(int arg) &#123;</span><br><span class="line">throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="unparkSuccessor-Node"><a href="#unparkSuccessor-Node" class="headerlink" title="unparkSuccessor(Node)"></a>unparkSuccessor(Node)</h3><p>该方法主要用于唤醒等待队列中的下一个阻塞线程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private void unparkSuccessor(Node node) &#123;</span><br><span class="line">// 获取当前节点的ws值</span><br><span class="line">int ws = node.waitStatus;</span><br><span class="line">// 将当前节点的ws值置0</span><br><span class="line">if (ws &lt; 0)</span><br><span class="line">compareAndSetWaitStatus(node, ws, 0);</span><br><span class="line"></span><br><span class="line">Node s = node.next;</span><br><span class="line">// 若后继节点为null或者其ws值大于0(放弃状态)，则从等待队列的尾节点从后往前搜索，</span><br><span class="line">// 搜索到等待队列中最靠前的ws值非正且非null的节点</span><br><span class="line">if (s == null || s.waitStatus &gt; 0) &#123;</span><br><span class="line">s = null;</span><br><span class="line">for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)</span><br><span class="line">if (t.waitStatus &lt;= 0)</span><br><span class="line">s = t;</span><br><span class="line">&#125;</span><br><span class="line">// 如果后继节点非null，则唤醒该后继节点持有的线程</span><br><span class="line">if (s != null)</span><br><span class="line">LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后继节点的阻塞线程被唤醒后，就进入到acquireQueued()的if (p == head &amp;&amp; tryAcquire(arg))的判断中，此时被唤醒的线程将尝试获取资源。</p><p>当然，如果被唤醒的线程所在节点的前继节点不是头结点，经过shouldParkAfterFailedAcquire的调整，也会移动到等待队列的前面，直到其前继节点为头结点。</p><p>讲解完独占模式下资源的acquire/release过程，下面开始讲解共享模式下，线程如何完成资源的获取和共享。</p><h2 id="获取资源-共享模式"><a href="#获取资源-共享模式" class="headerlink" title="获取资源(共享模式)"></a>获取资源(共享模式)</h2><p>理解了独占模式下，资源的获取和释放过程，则共享模式下也就so easy了，首先看一下方法入口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public final void acquireShared(int arg) &#123;</span><br><span class="line">if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行tryAcquireShared方法获取资源，若获取成功则直接返回，若失败，则进入等待队列，执行自旋获取资源，具体由doAcquireShared方法来实现。</p><h3 id="tryAcquireShared-int"><a href="#tryAcquireShared-int" class="headerlink" title="tryAcquireShared(int)"></a>tryAcquireShared(int)</h3><p>同样的，tryAcquireShared(int)由继承AQS的自定义同步器来具体实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected int tryAcquireShared(int arg) &#123;</span><br><span class="line">throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其返回值为负值代表失败；0代表获取成功，但无剩余资源；正值代表获取成功且有剩余资源，其他线程可去获取。</p><h3 id="doAcquireShared-int"><a href="#doAcquireShared-int" class="headerlink" title="doAcquireShared(int)"></a>doAcquireShared(int)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private void doAcquireShared(int arg) &#123;</span><br><span class="line">// 将线程以共享模式添加到等待队列的尾部</span><br><span class="line">final Node node = addWaiter(Node.SHARED);</span><br><span class="line">// 初始化失败标志</span><br><span class="line">boolean failed = true;</span><br><span class="line">try &#123;</span><br><span class="line">// 初始化线程中断标志</span><br><span class="line">boolean interrupted = false;</span><br><span class="line">for (;;) &#123;</span><br><span class="line">// 获取当前节点的前继节点</span><br><span class="line">final Node p = node.predecessor();</span><br><span class="line">// 若前继节点为头结点，则执行tryAcquireShared获取资源</span><br><span class="line">if (p == head) &#123;</span><br><span class="line">int r = tryAcquireShared(arg);</span><br><span class="line">// 若获取资源成功，且有剩余资源，将自己设为头结点并唤醒后续的阻塞线程</span><br><span class="line">if (r &gt;= 0) &#123;</span><br><span class="line">setHeadAndPropagate(node, r);</span><br><span class="line">p.next = null; // help GC</span><br><span class="line">// 如果中断标志位为真，则线程执行自我了断</span><br><span class="line">if (interrupted)</span><br><span class="line">selfInterrupt();</span><br><span class="line">// 表征获取资源成功</span><br><span class="line">failed = false;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// houldParkAfterFailedAcquire(p, node)根据前继节点判断是否阻塞当前节点的线程</span><br><span class="line">// parkAndCheckInterrupt()阻塞当前线程并检查线程是否被中断过，若被中断过，将interrupted置为true</span><br><span class="line">if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">parkAndCheckInterrupt())</span><br><span class="line">interrupted = true;</span><br><span class="line">&#125;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">if (failed)</span><br><span class="line">// 放弃获取资源</span><br><span class="line">cancelAcquire(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，doAcquireShared与独占模式下的acquireQueued大同小异，主要有2点不同：</p><ol><li>doAcquireShared将线程的自我中断操作放在了方法体内部；</li><li>当线程获取到资源后，doAcquireShared会将当前线程所在的节点设为头结点，若资源有剩余则唤醒后续节点，比acquireQueued多了个唤醒后续节点的操作。</li></ol><p>上述方法体现了共享的本质，即当前线程吃饱了后，若资源有剩余，会招呼后面排队的来一起吃，好东西要大家一起分享嘛，哈哈。</p><p>下面具体看一下setHeadAndPropagate(Node, int)函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void setHeadAndPropagate(Node node, int propagate) &#123;</span><br><span class="line">// 记录原来的头结点，下面过程会用到</span><br><span class="line">Node h = head; </span><br><span class="line">// 设置新的头结点</span><br><span class="line">setHead(node);</span><br><span class="line"></span><br><span class="line">// 如果资源还有剩余，则唤醒后继节点</span><br><span class="line">if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 ||</span><br><span class="line">(h = head) == null || h.waitStatus &lt; 0) &#123;</span><br><span class="line">Node s = node.next;</span><br><span class="line">if (s == null || s.isShared())</span><br><span class="line">doReleaseShared();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，实际执行唤醒后继节点的方法是doReleaseShared()，继续追踪：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private void doReleaseShared() &#123;</span><br><span class="line">// 自旋操作</span><br><span class="line">for (;;) &#123;</span><br><span class="line">// 获取等待队列的头结点</span><br><span class="line">Node h = head;</span><br><span class="line">if (h != null &amp;&amp; h != tail) &#123;</span><br><span class="line">int ws = h.waitStatus;</span><br><span class="line">if (ws == Node.SIGNAL) &#123;</span><br><span class="line">if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</span><br><span class="line">continue; </span><br><span class="line">    // 唤醒后继节点的线程</span><br><span class="line">unparkSuccessor(h);</span><br><span class="line">&#125;</span><br><span class="line">else if (ws == 0 &amp;&amp;</span><br><span class="line"> !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</span><br><span class="line">continue;                // loop on failed CAS</span><br><span class="line">&#125;</span><br><span class="line">if (h == head)                   // loop if head changed</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="释放资源-共享模式"><a href="#释放资源-共享模式" class="headerlink" title="释放资源(共享模式)"></a>释放资源(共享模式)</h2><p>首先进入到方法入口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">// 尝试释放资源</span><br><span class="line">if (tryReleaseShared(arg)) &#123;</span><br><span class="line">// 唤醒后继节点的线程</span><br><span class="line">doReleaseShared();</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，tryReleaseShared(int)由继承AQS的自定义同步器来具体实现。</p><p>doReleaseShared()上节讲解setHeadAndPropagate已说明过，不再赘述。</p><p>至此，共享模式下的资源获取/释放就讲解完了，下面以一个具体场景来概括一下：</p><p>整个获取/释放资源的过程是通过传播完成的，如最开始有10个资源，线程A、B、C分别需要5、4、3个资源。</p><ul><li>A线程获取到5个资源，其发现资源还剩余5个，则唤醒B线程；</li><li>B线程获取到4个资源，其发现资源还剩余1个，唤醒C线程；</li><li>C线程尝试取3个资源，但发现只有1个资源，继续阻塞；</li><li>A线程释放1个资源，其发现资源还剩余2个，故唤醒C线程；</li><li>C线程尝试取3个资源，但发现只有2个资源，继续阻塞；</li><li>B线程释放2个资源，其发现资源还剩余4个，唤醒C线程；</li><li>C线程获取3个资源，其发现资源还剩1个，继续唤醒后续等待的D线程；</li><li>……</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了AQS在独占和共享两种模式下，如何进行资源的获取和释放(tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared)，需要注意的是，在acquire()和acquireShared()方法中，线程在阻塞过程中均是忽略中断的。</p><p>AQS也可以通过acquireInterruptibly()/acquireSharedInterruptibly()来支持线程在等待过程中响应中断。</p><p>篇幅有限，本文就讲解到这里。对于AQS其他高级特性，感兴趣的读者可跟一下源码。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/iou123lg/p/9464385.html" target="_blank" rel="noopener">https://www.cnblogs.com/iou123lg/p/9464385.html</a><br><a href="https://www.cnblogs.com/waterystone/p/4920797.html" target="_blank" rel="noopener">https://www.cnblogs.com/waterystone/p/4920797.html</a><br><a href="https://www.jianshu.com/p/0da2939391cf" target="_blank" rel="noopener">https://www.jianshu.com/p/0da2939391cf</a></p><p><img src="https://upload-images.jianshu.io/upload_images/10431632-86426e609c966a5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>欢迎您扫一扫上面的二维码，关注我的微信公众号！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;所谓AQS，指的是AbstractQueuedSynchronizer，它提供了一种实现阻塞锁和一系列依赖FIFO等待队列的同步器的框架，ReentrantLock、Semaphore、CountDownLatch、CyclicBarrier等并发类均是基于AQS来实现的，
      
    
    </summary>
    
      <category term="并发编程" scheme="http://ruanshubin.top/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://ruanshubin.top/tags/Java/"/>
    
      <category term="并发" scheme="http://ruanshubin.top/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>聊一聊ThreadLocal是个啥东东</title>
    <link href="http://ruanshubin.top/2019/04/30/%E8%81%8A%E4%B8%80%E8%81%8AThreadLocal%E6%98%AF%E4%B8%AA%E5%95%A5%E4%B8%9C%E4%B8%9C/"/>
    <id>http://ruanshubin.top/2019/04/30/聊一聊ThreadLocal是个啥东东/</id>
    <published>2019-04-30T07:32:00.000Z</published>
    <updated>2019-09-16T01:37:16.336Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote><p>ThreadLocal提供了线程私有的局部变量，可以在整个线程存活的过程中随时取用，从而减少了在同一个线程内多个函数或者组件之间公共变量传递的复杂度。同时，由于ThreadLocal变量的线程私有性，故不存在并发线程安全的问题。</p></blockquote><p>要满足上述特性，需要解决3个问题：</p><ul><li>与线程绑定，实现私有性；</li><li>提供合适的容器，方便变量的存取；</li><li>设计合理的垃圾回收机制，避免内存泄露。</li></ul><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>为解决前2个问题，JDK最早期的设计是在ThreadLocal类内部维护一个线程安全的Map，线程的ID作为Map的key，实例对象作为Map的value，进而达到各个线程值隔离的效果。</p><p>该种中心化的模式下，通过Map的key来进行线程的绑定，而Map同时又作为变量的容器，ThreadLocal类需要处理复杂的多线程同步及变量回收问题，笨重且效率较低，所以后期JDK换了一种去中心化的方式，将管理权下放给了下面的各个线程，下面通过源码来阐述。</p><p>首先看set方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void set(T value) &#123;</span><br><span class="line">Thread t = Thread.currentThread();</span><br><span class="line">ThreadLocalMap map = getMap(t);</span><br><span class="line">if (map != null)</span><br><span class="line">map.set(this, value);</span><br><span class="line">else</span><br><span class="line">createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，set方法主要分为以下两个步骤：</p><ol><li><p>通过getMap()获取当前线程的ThreadLocalMap(map)；</p></li><li><p>通过map.set(this, value)将当前的ThreadLocal(this)作为key，T(value)作为value添加进获取到的ThreadLocalMap(map)中。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap getMap(Thread t) &#123;</span><br><span class="line">return t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>threadLocals为Thread类的的成员变量，初始化为null。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/* ThreadLocal values pertaining to this thread. This map is maintained</span><br><span class="line"> * by the ThreadLocal class. */</span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = null;</span><br></pre></td></tr></table></figure><p>get方法与之类似，可以看到现在的ThreadLocal是通过ThreadLocalMap来实现线程绑定和变量容器的，每个Thread均维护一个ThreadLocalMap映射表，key为ThreadLocal实例本身，而value是真正需要存储的的Object，该种模式带来3个直接的好处：</p><ul><li>ThreadLocalMap与线程同生命周期，当Thread销毁之后，对应的ThreadLocalMap也随之销毁，减少内存使用量；</li><li>映射表的Entity数量变小了，以前是Thread的数量，现在是ThreadLocal的数量，映射表更加轻量，故性能得到有效提高；</li><li>每个线程均有自己的ThreadLocalMap，保证了并发环境下的线程安全。</li></ul><h3 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h3><p>ThreadLocalMap是ThreadLocal的静态内部类，它具有HashMap的部分特性，比如容量、扩容阈值等，内部通过Entity类来存储key和value，Entity的定义为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">/** The value associated with this ThreadLocal. */</span><br><span class="line">Object value;</span><br><span class="line"></span><br><span class="line">Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">super(k);</span><br><span class="line">value = v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Entry继承自WeakReference，通过上述源码super(k)，可以知道，ThreadLocalMap是使用ThreadLocal的弱引用作为Key的。</p><p>分析到这里，可以得到下面ThreadLocal对象之间的引用结构图（其中，实线为强引用，虚线为弱引用）：</p><p><img src="https://upload-images.jianshu.io/upload_images/10431632-5025dbeb75f34fc6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>可以看到，Java堆上的ThreadLocal对象存在两个引用链，外部声明的强引用和ThreadLocalMap的key的弱引用，考虑以下情况：</p><p>删除ThreadLocal外部声明的强引用，即将ThreadLocal Ref置为null，此时只剩ThreadLocalMap的key的弱引用，当下次GC时，Java堆上的ThreadLocal对象将被回收，ThreadLocalMap上的key变为null。</p><p>需要注意的是，由于CurrentThread-&gt;Thread-&gt;ThreadLocalMap-&gt;Entity-&gt;value强引用链的存在，即使该Entity的key已经为null，value仍旧不会被回收，只有当线程被销毁之后，value的这部分内存空间才会被回收掉。</p><p>一般情况下，上述问题影响不大，但是在线程一直运行不被销毁的环境中(如线程池中的核心线程)，会存在内存泄露的问题。</p><h3 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h3><p>由于Entity的value是与线程同生命周期的，所以当线程持续不被回收时，会造成内存泄露，为此ThreadLocalMap通过以下机制来解决上述问题.</p><p>首先看ThreadLocalMap的getEntry(ThreadLocal&lt;?&gt; key)方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123;</span><br><span class="line">int i = key.threadLocalHashCode &amp; (table.length - 1);</span><br><span class="line">Entry e = table[i];</span><br><span class="line">if (e != null &amp;&amp; e.get() == key)</span><br><span class="line">return e;</span><br><span class="line">else</span><br><span class="line">return getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先计算key所属entity在映射表中的位置i，如果映射表中i位置的entity非空且其key与方法传入的key相等，则直接返回entity；否则，调用getEntryAfterMiss(key, i, e)方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) &#123;</span><br><span class="line">Entry[] tab = table;</span><br><span class="line">int len = tab.length;</span><br><span class="line"></span><br><span class="line">while (e != null) &#123;</span><br><span class="line">ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">if (k == key)</span><br><span class="line">return e;</span><br><span class="line">if (k == null)</span><br><span class="line">expungeStaleEntry(i);</span><br><span class="line">else</span><br><span class="line">i = nextIndex(i, len);</span><br><span class="line">e = tab[i];</span><br><span class="line">&#125;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getEntryAfterMiss方法通过i = nextIndex(i, len)，从table的当前位置i往后遍历table中非空的entity，若entity的key与传入的key相等，则返回该entity(可以看出ThreadLocalMap是采用线性探查的方式来解决hash冲突的，探查步长为1)；若entity的key为null，则调用expungeStaleEntry(i)方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private int expungeStaleEntry(int staleSlot) &#123;</span><br><span class="line">Entry[] tab = table;</span><br><span class="line">int len = tab.length;</span><br><span class="line"></span><br><span class="line">// expunge entry at staleSlot</span><br><span class="line">tab[staleSlot].value = null;</span><br><span class="line">tab[staleSlot] = null;</span><br><span class="line">size--;</span><br><span class="line"></span><br><span class="line">// Rehash until we encounter null</span><br><span class="line">Entry e;</span><br><span class="line">int i;</span><br><span class="line">for (i = nextIndex(staleSlot, len);</span><br><span class="line"> (e = tab[i]) != null;</span><br><span class="line"> i = nextIndex(i, len)) &#123;</span><br><span class="line">ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">if (k == null) &#123;</span><br><span class="line">e.value = null;</span><br><span class="line">tab[i] = null;</span><br><span class="line">size--;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">int h = k.threadLocalHashCode &amp; (len - 1);</span><br><span class="line">if (h != i) &#123;</span><br><span class="line">tab[i] = null;</span><br><span class="line"></span><br><span class="line">// Unlike Knuth 6.4 Algorithm R, we must scan until</span><br><span class="line">// null because multiple entries could have been stale.</span><br><span class="line">while (tab[h] != null)</span><br><span class="line">h = nextIndex(h, len);</span><br><span class="line">tab[h] = e;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>expungeStaleEntry(i)首先清理掉当前key为null的entity:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// expunge entry at staleSlot</span><br><span class="line">tab[staleSlot].value = null;</span><br><span class="line">tab[staleSlot] = null;</span><br><span class="line">size--;</span><br></pre></td></tr></table></figure><p>接着进行rehash过程，其基本过程是遍历table中非null的entity，若遍历到的entity，其key为null，则清理掉该entity；若遍历到的entity的key不为null，则检查key的散列值是否属于当前位置，若不属于，将当前位置置空(tab[i] = null;)，不断往后探查，若table的某位置为null，则将entity移动到该位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tab[i] = null;</span><br><span class="line">// Unlike Knuth 6.4 Algorithm R, we must scan until</span><br><span class="line">// null because multiple entries could have been stale.</span><br><span class="line">while (tab[h] != null)</span><br><span class="line">h = nextIndex(h, len);</span><br><span class="line">tab[h] = e;</span><br></pre></td></tr></table></figure><p>这里的rehash过程，其实还有一种方法，就是当key的散列值j不属于当前位置i时，将table的位置i置空(tab[i] = null;)，然后将位置i原有的entity移动到table的j位置，若发生hash冲突，则往后线性探查。读者可以思考为啥JDK没有采用这种方法。</p><p>本质上讲，rehash过程一方面释放掉了key为null的entity的内存，避免了当前线程(CurrentThread)长期存在时的内存泄露问题。同时，rehash()将不属于某位置的entity移动到其他位置，避免了后面可能存在的hash冲突。</p><p>在ThreadLocalMap的set()和getEntity()方法中，均会调用expungeStaleEntry(int staleSlot)方法，但是当我们既不添加value也不获取value时，还是可能存在内存泄露的，所以最佳实践是：当ThreadLocal不需要时，手动调用其remove()方法，来删除对应的Entity及其value：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void remove() &#123;</span><br><span class="line"> ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line"> if (m != null)</span><br><span class="line"> m.remove(this);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>最终调用的是ThreadLocalMap的remove函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void remove(ThreadLocal&lt;?&gt; key) &#123;</span><br><span class="line">Entry[] tab = table;</span><br><span class="line">int len = tab.length;</span><br><span class="line">int i = key.threadLocalHashCode &amp; (len-1);</span><br><span class="line">for (Entry e = tab[i];</span><br><span class="line"> e != null;</span><br><span class="line"> e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">if (e.get() == key) &#123;</span><br><span class="line">e.clear();</span><br><span class="line">expungeStaleEntry(i);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若对应的key存在，remove会调用expungeStaleEntry(i)方法来删除对应的entity和value。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>ThreadLocal是通过ThreadLocalMap来实现线程绑定和变量存储的；</p></li><li><p>ThreadLocalMap的实体结构Entity<threadlocal, t="">继承自WeakReference，其key是对ThreadLocal对象的弱引用；</threadlocal,></p></li><li><p>ThreadLocal的<strong>get()、set(T)、remove()</strong>均会触发ThreadLocalMap的回收机制，删除无效的Entity。</p></li></ol><p><strong>小贴士：ThreadLocal的源码加注释也就722行，难度不大，设计得很是精巧，推荐读者阅读。</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/10431632-86426e609c966a5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>欢迎您扫一扫上面的二维码，关注我的微信公众号！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;ThreadLocal提供了线程私有的局部变量，可以在整个线程存活的过程中随时取用，从而减少了在同一个线程内多个函
      
    
    </summary>
    
      <category term="并发编程" scheme="http://ruanshubin.top/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://ruanshubin.top/tags/Java/"/>
    
      <category term="并发" scheme="http://ruanshubin.top/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>数据库事务隔离那些事儿</title>
    <link href="http://ruanshubin.top/2019/04/26/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"/>
    <id>http://ruanshubin.top/2019/04/26/数据库事务隔离那些事儿/</id>
    <published>2019-04-26T08:02:00.000Z</published>
    <updated>2019-09-16T01:37:16.333Z</updated>
    
    <content type="html"><![CDATA[<p>在高并发环境下，由于多用户同时对数据库进行读/写操作，数据的可见性和操作的原子性需要通过事务机制来保障。</p><p>下面我们通过4个典型场景来讲解数据库的事务隔离机制。</p><p>首先在Mysql数据库中创建1张表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `account` (</span><br><span class="line">  `id` int(11) NOT NULL COMMENT &apos;ID&apos;,</span><br><span class="line">  `name` varchar(255) DEFAULT NULL COMMENT &apos;姓名&apos;,</span><br><span class="line">  `account` float(255,0) DEFAULT NULL COMMENT &apos;账户余额&apos;,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><p>插入两条测试数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into account values(1, &quot;小明&quot;, 1000);</span><br><span class="line">insert into account values(1, &quot;小强&quot;, 1000);</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/10431632-98947adb28bf8e8b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="丢失更新"><a href="#丢失更新" class="headerlink" title="丢失更新"></a>丢失更新</h2><p>假设现在有2个线程操作account表:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">        线程A                      线程B</span><br><span class="line"></span><br><span class="line">读取到小明的account=1000</span><br><span class="line">     </span><br><span class="line">                      读取到小明的account=1000  </span><br><span class="line"> </span><br><span class="line">set account=account+200</span><br><span class="line"></span><br><span class="line">   写回account=1200</span><br><span class="line"></span><br><span class="line">                          set account=account+300</span><br><span class="line">        </span><br><span class="line"> 写回account=1300</span><br></pre></td></tr></table></figure><p>很明显，在这种多线程更新操作下，线程A的更新丢失了，小明本来应该收到500元，结果只收到了300元。</p><p>还我血汗钱，小明要杀程序员祭天了…</p><p>于是，聪明的程序员引入了X锁来解决更新丢失的问题。</p><p>所谓X锁，又称排他锁(Exclusive Lock)或写锁，即某线程对数据添加X锁后，则独占该数据，其他线程不能更新该数据。该线程释放X锁后，其他线程获取到X锁后才可以进行更新操作，也就是说X锁属于独占锁，比较重。</p><p>于是上述的转账操作优化为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">        线程A                      线程B</span><br><span class="line"></span><br><span class="line"> 获取account的X锁(成功)</span><br><span class="line"></span><br><span class="line">读取到小明的account=1000</span><br><span class="line">     </span><br><span class="line">                         获取account的X锁(失败)</span><br><span class="line"> </span><br><span class="line">set account=account+200</span><br><span class="line"></span><br><span class="line">   写回account=1200                 ......</span><br><span class="line">   </span><br><span class="line">   释放account的X锁</span><br><span class="line">   </span><br><span class="line">                             获取account的X锁(成功)</span><br><span class="line">                </span><br><span class="line">                            读取到小明的account=1200</span><br><span class="line"></span><br><span class="line">                            set account=account+300</span><br><span class="line">        </span><br><span class="line">   写回account=1500</span><br><span class="line">                       </span><br><span class="line">           释放account的X锁</span><br></pre></td></tr></table></figure><p>X锁优化对应的就是数据库事务隔离的最低级别<strong>Read Uncommited</strong>。</p><p>即Read Uncommited可以避免丢失更新。</p><h2 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h2><p>Read Uncommited虽然可以解决更新丢失的问题，但是X锁并不能约束其他线程并行的读取数据。</p><p>比如下述场景：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">       线程A                           线程B</span><br><span class="line">  </span><br><span class="line">                             获取account的X锁(成功)</span><br><span class="line"> </span><br><span class="line">            读取到小明的account=1000</span><br><span class="line">      </span><br><span class="line">            set account=account+200</span><br><span class="line">   </span><br><span class="line">                写回account=1200 </span><br><span class="line"> </span><br><span class="line">读取到小明的account=1200 </span><br><span class="line">   </span><br><span class="line">                                   Rollback</span><br><span class="line"></span><br><span class="line">            account恢复为1000</span><br><span class="line"> </span><br><span class="line">    释放account的X锁</span><br><span class="line">   </span><br><span class="line">       尴尬了！</span><br><span class="line"> 小明现在的数据是错误的</span><br></pre></td></tr></table></figure><p>我们用mysql模拟上述操作：</p><p>客户端A:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set session transaction isolation level read uncommitted;</span><br><span class="line">mysql&gt; start transaction;</span><br><span class="line">mysql&gt; select * from account;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/10431632-192e269d4ea64916.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>再起一个客户端B:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set session transaction isolation level read uncommitted;</span><br><span class="line">mysql&gt; start transaction;</span><br><span class="line">mysql&gt; update account set account=account+200 where id=1</span><br></pre></td></tr></table></figure><p>此时，客户端B的事务还未commit，通过客户端A执行select操作：</p><p><img src="https://upload-images.jianshu.io/upload_images/10431632-4837969f27ebb32c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>可以看到，客户端A的事务看到了客户端B的事务里未提交的修改数据。</p><p>此时，数据库中小明的account仍然是1000，可以起一个客户端C(未开启事务)来验证:</p><p><img src="https://upload-images.jianshu.io/upload_images/10431632-a3ef27756867c136.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>也就是说，客户端A中读取的数据与数据库中实际值不一致，出现了脏读。</p><p>出现脏读的原因主要是X锁仅对多线程的更新操作添加了约束，而对读取操作没做要求。</p><p>解决方法也就呼之欲出了，对读取操作也进行加锁呗。</p><p>那么是不是直接对读取操作也加X锁呢？</p><p>这样就太重了，而且由于X锁的独占性，当多线程环境下仅有读操作时，也需要频繁的加锁和释放锁，但实际上仅有读操作时，并发环境下并不会引发脏读(因为并没有线程更改数据嘛)。</p><p>于是，聪明的程序员引入了S锁来解决脏读的问题，同时又保证了锁的轻量性。</p><p>S锁，又称共享锁(Share Lock)或读锁，S锁与X锁的关系可以用1句话总结：</p><p><strong>如果一个数据加了X锁，就没法加S锁；同样加了S锁，就没法加X锁。</strong></p><p>当然，加了S锁的数据还可以继续添加S锁，因为并发读是互不影响的。</p><p>同时，在高并发环境下，为了防止单个线程长时间被S锁锁住，故有如下约定:</p><p><strong>读数据前添加S锁，读完之后立即释放。</strong></p><p>添加S锁机制之后，上面的流程优化如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">     线程A                           线程B</span><br><span class="line"> </span><br><span class="line">                            获取account的X锁(成功)</span><br><span class="line"> </span><br><span class="line">            读取到小明的account=1000</span><br><span class="line">      </span><br><span class="line">            set account=account+200</span><br><span class="line">   </span><br><span class="line">                写回account=1200 </span><br><span class="line"> </span><br><span class="line"> 获取account的S锁(失败) </span><br><span class="line">   </span><br><span class="line">                                  Rollback</span><br><span class="line"></span><br><span class="line">    ......   account恢复为1000</span><br><span class="line"> </span><br><span class="line">     释放account的X锁</span><br><span class="line">   </span><br><span class="line"> 获取account的S锁(成功)</span><br><span class="line"></span><br><span class="line">读取到小明的account=1000</span><br></pre></td></tr></table></figure><p>很明显，S锁限制了读时写和写时读，只有当写线程commit释放X锁之后，读线程才能获取到S锁完成数据的读取。</p><p>这种只能更新数据commit之后，才能读取到最新数据的事务隔离级别称为<strong>Read Committed</strong>。</p><p>即Read Committed可以避免脏读。</p><h2 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h2><p>在Read Committed事务隔离级别下，我们为了防止高并发环境下读线程长时间被锁住，做了以下规定：</p><p><strong>读数据前添加S锁，读完之后立即释放。</strong></p><p>此时，会出现以下问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">        线程A　　　　　　　　　　     线程B</span><br><span class="line"></span><br><span class="line"> 获取account的S锁(成功)</span><br><span class="line"> </span><br><span class="line"> 读取到的account=1000</span><br><span class="line"> </span><br><span class="line">   释放account的S锁</span><br><span class="line">   </span><br><span class="line">                           获取account的X锁(成功)</span><br><span class="line"></span><br><span class="line">                      set account=account+200</span><br><span class="line">做其他事情...                       </span><br><span class="line">                          写回account=1200 </span><br><span class="line">  </span><br><span class="line">      释放account的X锁</span><br><span class="line"></span><br><span class="line"> 获取account的S锁(成功)</span><br><span class="line"> </span><br><span class="line">重新读取到的account=1200</span><br><span class="line">  </span><br><span class="line">        What?</span><br><span class="line">   与之前读的不一样了？</span><br></pre></td></tr></table></figure><p>此时，在同一个事务中重新读取的数据发生了变化，即不可重复读。</p><p>同样用mysql数据库演示上述过程：</p><p>客户端A:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set session transaction isolation level read committed;</span><br><span class="line">mysql&gt; start transaction;</span><br><span class="line">mysql&gt; select * from account;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/10431632-c45331317d343592.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>此时再起一个客户端B:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set session transaction isolation level read committed;</span><br><span class="line">mysql&gt; start transaction;</span><br><span class="line">mysql&gt; update account set account=account+200 where id=1;</span><br><span class="line">mysql&gt; select * from account;</span><br><span class="line">mysql&gt; commit;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/10431632-e842b31829d7b095.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>此时，在客户端A的事务中继续查询:</p><p><img src="https://upload-images.jianshu.io/upload_images/10431632-93195a8dc6604189.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>故客户端A同一个事务中小明的account出现了2个不同的值，即出现了不可重复读。</p><p>而解决不可重复读的方法也很简单，把S锁的规定升级一下即可：</p><p><strong>读数据前添加S锁，事务提交之后才可以释放。</strong></p><p>此时，上面的流程变为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">       线程A　　　　　　　　　　     线程B</span><br><span class="line"></span><br><span class="line">获取account的S锁(成功)</span><br><span class="line"></span><br><span class="line">读取到的account=1000</span><br><span class="line">  </span><br><span class="line">                            获取account的X锁(失败)</span><br><span class="line">                  </span><br><span class="line">做其他事情...                                                        </span><br><span class="line">获取account的S锁(成功)</span><br><span class="line">                               </span><br><span class="line"> 读取到的account=1000              ......</span><br><span class="line"> </span><br><span class="line">      提交事务</span><br><span class="line">   </span><br><span class="line">  释放account的S锁</span><br><span class="line"></span><br><span class="line">        获取account的X锁(成功)</span><br><span class="line"></span><br><span class="line">      set account=account+200</span><br><span class="line">                 </span><br><span class="line">      写回account=1200 </span><br><span class="line"></span><br><span class="line">      释放account的X锁</span><br></pre></td></tr></table></figure><p>此时对应的数据库事务隔离级别即为<strong>Repeatable Read</strong>。</p><p>Repeatable Read解决了不可重复读的问题。</p><h2 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h2><p>通过X锁和S锁的组合应用，我们解决了数据的更新丢失、脏读、不可重复读3个问题，但由于X锁和S锁仅是对数据的更新(修改)和读取进行了限制，而对数据的添加和删除未做限制，那么即使在Repeatable Read隔离级别下，仍然会出现如下问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">        线程A                        线程B</span><br><span class="line"></span><br><span class="line">  获取数据的S锁(成功)</span><br><span class="line">  </span><br><span class="line">    查询account表</span><br><span class="line">  [(1, &quot;小明&quot;, 1000)</span><br><span class="line">  (2, &quot;小强&quot;, 1000)]</span><br><span class="line">  </span><br><span class="line"> 做其他事情...            插入数据(3, &quot;小花&quot;, 1000)  </span><br><span class="line">   </span><br><span class="line">                                 提交</span><br><span class="line">   </span><br><span class="line"> 插入数据(3, &quot;小花&quot;, 1000)  </span><br><span class="line"> </span><br><span class="line">报错：&apos;3&apos; for key &apos;PRIMARY&apos;</span><br><span class="line"> </span><br><span class="line">查询account表</span><br><span class="line">[(1, &quot;小明&quot;, 1000)</span><br><span class="line">(2, &quot;小强&quot;, 1000)]</span><br><span class="line"></span><br><span class="line">        What?</span><br><span class="line">这哪里有id为3的数据，眼花了？</span><br></pre></td></tr></table></figure><p>线程B的插入操作让线程A出现了幻觉，所以该种异常称之为幻读。</p><p>同样用mysql数据库演示上述过程：</p><p>客户端A:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set session transaction isolation level repeatable read;</span><br><span class="line">mysql&gt; start transaction;</span><br><span class="line">mysql&gt; select * from account;</span><br></pre></td></tr></table></figure><p>此时再起一个客户端B:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set session transaction isolation level repeatable read;</span><br><span class="line">mysql&gt; start transaction;</span><br><span class="line">mysql&gt; insert into account values(3, &quot;小红&quot;, 1000);</span><br><span class="line">mysql&gt; select * from account;</span><br><span class="line">mysql&gt; commit;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/10431632-7b8f39c224f9c0c9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>此时，客户端A在事务中继续执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into account values(3, &quot;小阁&quot;, 1500);</span><br><span class="line">mysql&gt; select * from account;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/10431632-f952495271306e5b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>还有一种幻读，指的是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">       线程A                        线程B</span><br><span class="line"></span><br><span class="line"> 获取数据的S锁(成功)</span><br><span class="line"> </span><br><span class="line">查询account表中的人数</span><br><span class="line">      返回2</span><br><span class="line"> </span><br><span class="line">做其他事情...            插入数据(3, &quot;小花&quot;, 1000)  </span><br><span class="line">  </span><br><span class="line">                                提交</span><br><span class="line"></span><br><span class="line">查询account表中的人数</span><br><span class="line">      返回3</span><br><span class="line">     </span><br><span class="line">  What?</span><br><span class="line">  刚才还是2的？</span><br></pre></td></tr></table></figure><p>只是MySQL的InnoDB引擎默认的Repeatable Read级别已经通过MVCC自动帮我们解决了，所以该级别下, 我们也模拟不出该种幻读的场景。</p><p>至于MVCC是啥，后面抽空再聊，哈哈…</p><p>说实话，幻读和不可重复读很容易混淆：</p><ul><li>不可重复读，主要是说在同一事务中多次读取一条记录, 发现该记录中某些列值被修改过；</li><li>幻读，主要是说在同一事务中多次读取一个范围内的记录(包括查询所有结果或者聚合统计)、插入时，发现结果不一致。</li></ul><p>解决幻读，只能放出我们的终极大招了，对整个事务加X锁，将事务的执行串行化，对应的数据库事务隔离级别为<strong>Serializable</strong>。</p><p>即Serializable解决了幻读的问题。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Read Uncommitted通过X锁来实现，锁住数据更新的阶段;</li><li>Read Committed通过X锁和S锁来实现，且读完即释放S锁;</li><li>Repeatable Read通过X锁和S锁来实现，事务提交之后释放S锁;</li><li>Serializeable通过X锁来实现，锁住整个事务。</li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">隔离级别</th><th style="text-align:center">丢失更新</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻读</th></tr></thead><tbody><tr><td style="text-align:left">Read Uncommitted</td><td style="text-align:center">No</td><td style="text-align:center">Yes</td><td style="text-align:center">Yes</td><td style="text-align:center">Yes</td></tr><tr><td style="text-align:left">Read Committed</td><td style="text-align:center">No</td><td style="text-align:center">No</td><td style="text-align:center">Yes</td><td style="text-align:center">Yes</td></tr><tr><td style="text-align:left">Repeatable Read</td><td style="text-align:center">No</td><td style="text-align:center">No</td><td style="text-align:center">No</td><td style="text-align:center">Yes</td></tr><tr><td style="text-align:left">Serializeable</td><td style="text-align:center">No</td><td style="text-align:center">No</td><td style="text-align:center">No</td><td style="text-align:center">No</td></tr></tbody></table></div><p><img src="https://upload-images.jianshu.io/upload_images/10431632-86426e609c966a5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>欢迎您扫一扫上面的二维码，关注我的微信公众号！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在高并发环境下，由于多用户同时对数据库进行读/写操作，数据的可见性和操作的原子性需要通过事务机制来保障。&lt;/p&gt;
&lt;p&gt;下面我们通过4个典型场景来讲解数据库的事务隔离机制。&lt;/p&gt;
&lt;p&gt;首先在Mysql数据库中创建1张表：&lt;/p&gt;
&lt;figure class=&quot;highl
      
    
    </summary>
    
      <category term="基础知识" scheme="http://ruanshubin.top/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="数据库" scheme="http://ruanshubin.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="http://ruanshubin.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>RestTemplate源码解读</title>
    <link href="http://ruanshubin.top/2019/04/25/RestTemplate%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>http://ruanshubin.top/2019/04/25/RestTemplate源码解读/</id>
    <published>2019-04-25T08:16:00.000Z</published>
    <updated>2019-09-16T01:37:16.308Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>SpringCloud的微服务均是以Http接口的形式来暴露自身服务的，因此在调用远程服务的时候必须使用HTTP客户端，可选的方案有JDK原生的URL Connection、Apache的Http Client、Netty的异步Http Client，Spring的RestTemplate和Fegin。</p><p>今天主要介绍一下Spring的RestTemplate。</p><h2 id="源码跟读"><a href="#源码跟读" class="headerlink" title="源码跟读"></a>源码跟读</h2><p>通过源码可以看到RestTemplate进行请求的很多方法最终调用的均是doExecute方法。</p><p><img src="https://upload-images.jianshu.io/upload_images/10431632-1f5644cd64712702.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>可以看出，主要分为创建请求Request，执行请求Request，处理返回结果response3个步骤。</p><h3 id="创建请求"><a href="#创建请求" class="headerlink" title="创建请求"></a>创建请求</h3><p>跟进createRequest()方法，发现该方法是由HttpAccessor负责实现的。</p><p><img src="https://upload-images.jianshu.io/upload_images/10431632-90eb05a69abf0365.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>其基本思路是传入请求地址url和请求方法method，然后由ClientHttpRequestFactory工厂负责Request的创建，ClientHttpRequestFactory为一个接口，其实现类主要有：</p><p><img src="https://upload-images.jianshu.io/upload_images/10431632-e46305d304a29ce9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>HttpAccessor提供了get/set方法，方便传入不同的ClientHttpRequestFactory实现类，如果需要自定义ClientHttpRequestFactory工厂，直接implements ClientHttpRequestFactory复写方法，然后注入HttpAccessor即可。</p><p>HttpAccessor默认使用的是SimpleClientHttpRequestFactory工厂实现类。</p><p><img src="https://upload-images.jianshu.io/upload_images/10431632-091a5cea9acc21e3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>继续跟进SimpleClientHttpRequestFactory工厂实现类。</p><p>它提供了两种请求创建方法，分别支持同步和异步请求：</p><ul><li>createRequest(URI uri, HttpMethod httpMethod)</li><li>createAsyncRequest(URI uri, HttpMethod httpMethod)</li></ul><p>上述两种方法均包括打开连接、准备连接、创建连接3个步骤。</p><p><img src="https://upload-images.jianshu.io/upload_images/10431632-afc3e2582b44f3a9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>先看openConnection方法，它的实现比较简单，有代理Proxy存在，则传入Proxy打开连接，否则则直接通过URL打来连接。</p><p><img src="https://upload-images.jianshu.io/upload_images/10431632-b934c4726c21f4ac.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>prepareConnection方法主要根据传入的参数，进行连接前的一些配置工作，比如设置连接超时、读取超时、根据不同请求method设置相应配置参数等。</p><p><img src="https://upload-images.jianshu.io/upload_images/10431632-f998e9f0d25bfecd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>最后创建连接的时候，根据bufferRequestBody是否为True，创建2种不同的连接，分别为批处理连接和流处理连接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return (ClientHttpRequest)(this.bufferRequestBody ? new SimpleBufferingClientHttpRequest(connection, this.outputStreaming) : new SimpleStreamingClientHttpRequest(connection, this.chunkSize, this.outputStreaming));</span><br></pre></td></tr></table></figure><h3 id="执行请求"><a href="#执行请求" class="headerlink" title="执行请求"></a>执行请求</h3><p>切回到RestTemplate类的doExecute方法，可以看到建立http连接，拿到ClientHttpRequest后，执行请求的方法为execute()。</p><p><img src="https://upload-images.jianshu.io/upload_images/10431632-07db9fde41b9c5f6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>ClientHttpRequest为接口，仅有一个execute()方法，看一下ClientHttpRequest的实现类：</p><p><img src="https://upload-images.jianshu.io/upload_images/10431632-e137cddb179da5f3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>其中用的比较多的是AbstractClientHttpRequest抽象类，SimpleStreamingClientHttpRequest和SimpleBufferingClientHttpRequest分别继承了AbstractClientHttpRequest，复写某些方法以支持流/批处理请求。</p><p>跟进AbstractClientHttpRequest抽象类的execute()方法，</p><p><img src="https://upload-images.jianshu.io/upload_images/10431632-46b845771c339dd1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/10431632-3eceafdfaf65f264.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>execute()内部调用的是executeInternal()，由子类来具体实现，可以看一下SimpleBufferingClientHttpRequest的方法实现，其他子类实现方式大同小异。</p><p><img src="https://upload-images.jianshu.io/upload_images/10431632-68552278bc70bf9f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>可以看到，主要是做了一些添加请求头、返回设置等的操作，最后得到请求的返回类SimpleClientHttpResponse。</p><p>至此，我们就拿到请求的返回了，下一步就是处理返回结果了。</p><h3 id="处理返回结果"><a href="#处理返回结果" class="headerlink" title="处理返回结果"></a>处理返回结果</h3><p>返回结果处理主要分为两步：</p><ul><li>handleResponse(url, method, response)</li><li>responseExtractor.extractData(response)</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/10431632-ef790aeb69ae07ad.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>其中，handleResponse(url, method, response)主要负责对请求的异常进行处理。</p><p><img src="https://upload-images.jianshu.io/upload_images/10431632-2b7ef3fd732202c0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>可以看到，handleResponse()方法首先获取请求错误的处理器errorHandler，然后把response交给它进行后续的处理。</p><p>而responseExtractor.extractData(response)主要负责返回数据的解析。</p><p>responseExtractor为接口，其实现类为：</p><p><img src="https://upload-images.jianshu.io/upload_images/10431632-3a56c5f6cb69668e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>其中ResponseEntityResponseExtractor和HeadersExtractor为RestTemplate的内部类，主要处理返回的headers和entity，我们重点关注返回消息的转化处理类HttpMessageConverterExtractor。</p><p><img src="https://upload-images.jianshu.io/upload_images/10431632-33d7bfc2f64afde9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>可以看到，extractData先将response交给responseWrapper，如果responseWrapper有消息体且非空，则进行返回消息的读取操作。</p><p>消息的读取需要借助HttpMessageConverter接口，HttpMessageConverter具有多种实现类，以完成不同格式消息的读取，相当于消息解码器或转换头。</p><p><img src="https://upload-images.jianshu.io/upload_images/10431632-522f06e68b210faf.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>可以看到，在构建HttpMessageConverterExtractor实例的时候，需要传入HttpMessageConverter的接口集合messageConverters，用于对不同返回格式消息的读取。</p><p><img src="https://upload-images.jianshu.io/upload_images/10431632-264bf1a324b82e1a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>首先，得到messageConverters的迭代器，然后遍历迭代器，依次执行不同HttpMessageConverter读取操作，最终完成返回消息体的读取操作。</p><p>迭代过程中，如果当前MessageConverter属于GenericHttpMessageConverter的接口实现，则执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return genericMessageConverter.read(this.responseType, (Class)null, responseWrapper);</span><br></pre></td></tr></table></figure><p>否则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return messageConverter.read(this.responseClass, responseWrapper);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>RestTemplate是Spring提供的用于访问Rest服务的客户端；</p></li><li><p>RestTemplate提供了多种便捷访问远程Http服务的方法,能够大大提高客户端的编写效率；</p></li><li><p>调用RestTemplate的默认构造函数，RestTemplate对象在底层通过使用java.net包下的实现创建HTTP请求；</p></li><li><p>可以通过使用ClientHttpRequestFactory指定不同的HTTP请求方式；</p></li><li><p>在设计模式上，主要通过工厂模式来完成各类Http客户端的创建。</p></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/10431632-86426e609c966a5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>欢迎您扫一扫上面的二维码，关注我的微信公众号！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;SpringCloud的微服务均是以Http接口的形式来暴露自身服务的，因此在调用远程服务的时候必须使用HTTP客户端，可选的方案有JDK原
      
    
    </summary>
    
      <category term="Springboot" scheme="http://ruanshubin.top/categories/Springboot/"/>
    
    
      <category term="Springboot" scheme="http://ruanshubin.top/tags/Springboot/"/>
    
      <category term="RestTemplate" scheme="http://ruanshubin.top/tags/RestTemplate/"/>
    
      <category term="RPC" scheme="http://ruanshubin.top/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo框架的HelloWorld</title>
    <link href="http://ruanshubin.top/2018/12/14/Dubbo%E6%A1%86%E6%9E%B6%E7%9A%84HelloWorld/"/>
    <id>http://ruanshubin.top/2018/12/14/Dubbo框架的HelloWorld/</id>
    <published>2018-12-14T05:03:00.000Z</published>
    <updated>2019-09-16T01:37:16.303Z</updated>
    
    <content type="html"><![CDATA[<p>随着微服务的流行，Dubbo和Spring Cloud框架受到越来越多的关注，本文主要基于1个简单Demo来介绍Dubbo框架的工作流程。</p><h2 id="Dubbo是什么"><a href="#Dubbo是什么" class="headerlink" title="Dubbo是什么?"></a>Dubbo是什么?</h2><blockquote><p>Apache Dubbo (incubating) is a high-performance, java based, open source RPC framework. </p></blockquote><p>Dubbo是：</p><ul><li>一个分布式服务框架；</li><li>致力于提供高性能和透明化的RPC远程服务调用方案；</li><li>阿里巴巴SOA服务化治理方案的核心框架，每天为2,000+个服务提供3,000,000,000+次访问量支持。</li></ul><blockquote><p>注：SOA是Service-Oriented Architecture的英文简称，即面向服务的架构，其主要解决多服务凌乱的问题，因此有人也称之为服务治理。</p></blockquote><p>dubbo的工作流程如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/10431632-a637cdff94f2b006.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>其中：</p><p>Provider为服务提供者，负责发布服务；</p><p>Consumer为服务消费者，负责调用服务；</p><p>Container为Dubbo容器，其依赖于Spring容器；</p><p>Registry为注册中心，当Container启动时会将所有可提供的服务在Registry进行注册，其作用是告知Consumer有哪些服务，以及服务的地址；</p><p>Monitor为监听器，负责服务注册、调用等流程的监控；</p><p>其中虚线为异步访问，实线为同步访问；</p><p>蓝色虚线代表Dubbo启动时完成的功能，红色虚线(实线)为程序运行过程中执行的功能。</p><h3 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h3><p>Dubbo支持以下4种注册中心：</p><ul><li>Multicast</li></ul><p>不需要启动任何中心节点，只要广播地址一样，就可以互相发现。组播受网络结构限制，只适合小规模应用或开发阶段使用。</p><ul><li>Zookeeper</li></ul><p>其优点是支持网络集群。</p><ul><li>Redis</li></ul><p>使用Redis的Key/Map结构存储数据；</p><p>主Key为服务名和类型；</p><p>Map中的Key为URL地址；</p><p>Map中的Value为过期时间，用于判断脏数据，脏数据由监控中心删除。(注意：服务器时间必需同步，否则过期检测会不准确)；</p><p>使用Redis的Publish/Subscribe事件通知数据变更；</p><ul><li>Simple</li></ul><p>本身为普通的Dubbo服务，可以减少第三方依赖，使整体通讯方式一致，不支持集群，可作为自定义注册中心的参考，但不适合直接用于生产环境。</p><h3 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h3><p>Dubbo支持以下4种负载均衡策略：</p><h3 id="Random-LoadBalance"><a href="#Random-LoadBalance" class="headerlink" title="Random LoadBalance"></a>Random LoadBalance</h3><ul><li>随机，按权重设置随机概率。</li><li>在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</li></ul><h3 id="RoundRobin-LoadBalance"><a href="#RoundRobin-LoadBalance" class="headerlink" title="RoundRobin LoadBalance"></a>RoundRobin LoadBalance</h3><ul><li>轮询，按公约后的权重设置轮询比率。</li><li>存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</li></ul><h3 id="LeastActive-LoadBalance"><a href="#LeastActive-LoadBalance" class="headerlink" title="LeastActive LoadBalance"></a>LeastActive LoadBalance</h3><ul><li>最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。</li><li>使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。</li></ul><h3 id="ConsistentHash-LoadBalance"><a href="#ConsistentHash-LoadBalance" class="headerlink" title="ConsistentHash LoadBalance"></a>ConsistentHash LoadBalance</h3><ul><li>一致性 Hash，相同参数的请求总是发到同一提供者。</li><li>当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。</li><li>算法参见：<a href="http://en.wikipedia.org/wiki/Consistent_hashing" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Consistent_hashing</a></li><li>缺省只对第一个参数 Hash，如果要修改，请配置 <dubbo:parameter key="hash.arguments" value="0,1"></dubbo:parameter></li><li>缺省用 160 份虚拟节点，如果要修改，请配置 <dubbo:parameter key="hash.nodes" value="320"></dubbo:parameter></li></ul><h2 id="示例编写"><a href="#示例编写" class="headerlink" title="示例编写"></a>示例编写</h2><p>下面通过1个简单Demo实际体验一把Dubbo。</p><h3 id="构建环境"><a href="#构建环境" class="headerlink" title="构建环境"></a>构建环境</h3><ul><li>Java 1.8.0_191</li><li>Zookeeper-3.4.10</li><li>dubbo 2.5.9</li><li>dubbo-monitor-simple-2.5.3</li><li>IntelliJ IDEA 2018.1</li></ul><h3 id="dubbo-service"><a href="#dubbo-service" class="headerlink" title="dubbo_service"></a>dubbo_service</h3><p>首先，基于Maven构建dubbo_service工程，其作用仅是定义服务的接口。</p><p>对应的pom.xml文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.ruanshubin&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;dubbo_service&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!-- https://mvnrepository.com/artifact/com.alibaba/dubbo --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;dubbo&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.5.9&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- https://mvnrepository.com/artifact/org.apache.zookeeper/zookeeper --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.4.10&lt;/version&gt;</span><br><span class="line">            &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- https://mvnrepository.com/artifact/com.101tec/zkclient --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.101tec&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;zkclient&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;0.11&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.11&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><ul><li>DemoService</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package com.ruanshubin.service;</span><br><span class="line"></span><br><span class="line">public interface DemoService &#123;</span><br><span class="line">    String sayHello(String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dubbo-provider"><a href="#dubbo-provider" class="headerlink" title="dubbo_provider"></a>dubbo_provider</h3><p>dubbo_provider为服务提供者，故其需要实现前面定义的服务接口。</p><p>其pom.xml文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.ruanshubin&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;dubbo_provider&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.ruanshubin&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;dubbo_service&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;!-- 打包操作 --&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;2.3&lt;/version&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;shade&lt;/goal&gt;</span><br><span class="line">                        &lt;/goals&gt;</span><br><span class="line">                        &lt;configuration&gt;</span><br><span class="line">                            &lt;transformers&gt;</span><br><span class="line">                                &lt;transformer</span><br><span class="line">                                        implementation=&quot;org.apache.maven.plugins.shade.resource.AppendingTransformer&quot;&gt;</span><br><span class="line">                                    &lt;resource&gt;META-INF/spring.handlers&lt;/resource&gt;</span><br><span class="line">                                &lt;/transformer&gt;</span><br><span class="line">                                &lt;transformer</span><br><span class="line">                                        implementation=&quot;org.apache.maven.plugins.shade.resource.AppendingTransformer&quot;&gt;</span><br><span class="line">                                    &lt;resource&gt;META-INF/spring.schemas&lt;/resource&gt;</span><br><span class="line">                                &lt;/transformer&gt;</span><br><span class="line">                                &lt;transformer</span><br><span class="line">                                        implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&gt;</span><br><span class="line">                                    &lt;mainClass&gt;&lt;/mainClass&gt;</span><br><span class="line">                                &lt;/transformer&gt;</span><br><span class="line">                            &lt;/transformers&gt;</span><br><span class="line">                        &lt;/configuration&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">                &lt;/executions&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><ul><li>接口实现类DemoServiceImpl</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.ruanshubin.service.Impl;</span><br><span class="line"></span><br><span class="line">import com.ruanshubin.service.DemoService;</span><br><span class="line"></span><br><span class="line">public class DemoServiceImpl implements DemoService &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String sayHello(String name) &#123;</span><br><span class="line">        System.out.println(&quot;服务被调用！&quot;);</span><br><span class="line">        return &quot;Hello &quot; + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面需要编写Container的启动类Provider。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.ruanshubin.dubbo;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class Provider &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;provider.xml&quot;);</span><br><span class="line">        context.start();</span><br><span class="line">        System.out.println(&quot;服务启动成功！&quot;);</span><br><span class="line">        System.in.read(); // 按任意键退出，该行代码的目的是保持容器的启动状态</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，provider.xml为Provider端的启动配置文件，具体为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">    http://www.springframework.org/schema/beans/spring-beans-4.3.xsd</span><br><span class="line">    http://code.alibabatech.com/schema/dubbo</span><br><span class="line">    http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 提供方应用信息，用于计算依赖关系 --&gt;</span><br><span class="line">    &lt;dubbo:application name=&quot;hello-world-app&quot;  /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 配置注册中心 --&gt;</span><br><span class="line">    &lt;dubbo:registry address=&quot;10.194.224.61:2181?backup=10.194.224.62:2181,10.194.224.63:2181&quot; protocol=&quot;zookeeper&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 用dubbo协议在20880端口暴露服务 --&gt;</span><br><span class="line">    &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 声明需要暴露的服务接口 --&gt;</span><br><span class="line">    &lt;dubbo:service interface=&quot;com.ruanshubin.service.DemoService&quot; ref=&quot;demoService&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 和本地bean一样实现服务 --&gt;</span><br><span class="line">    &lt;bean id=&quot;demoService&quot; class=&quot;com.ruanshubin.service.Impl.DemoServiceImpl&quot; /&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><h3 id="dubbo-consumer"><a href="#dubbo-consumer" class="headerlink" title="dubbo_consumer"></a>dubbo_consumer</h3><p>dubbo_consumer为服务消费方，先从注册中心拉取服务列表，然后调用相应服务。</p><p>其启动类Consumer如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.ruanshubin.dubbo;</span><br><span class="line"></span><br><span class="line">import com.ruanshubin.service.DemoService;</span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line">public class Consumer &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;consumer.xml&quot;);</span><br><span class="line">        // 获取服务实例</span><br><span class="line">        DemoService service = context.getBean(&quot;demoService&quot;, DemoService.class);</span><br><span class="line">        // 调取服务的方法，调用10次来测试负载均衡</span><br><span class="line">        for(int i=0; i&lt;10; i++)&#123;</span><br><span class="line">            String result = service.sayHello(args[0]);</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，consumer.xml为Consumer端的启动配置文件，具体为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">    http://www.springframework.org/schema/beans/spring-beans-4.3.xsd</span><br><span class="line">    http://code.alibabatech.com/schema/dubbo</span><br><span class="line">    http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 提供方应用信息，用于计算依赖关系 --&gt;</span><br><span class="line">    &lt;dubbo:application name=&quot;hello-world-app&quot;  /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 配置注册中心 --&gt;</span><br><span class="line">    &lt;dubbo:registry address=&quot;10.194.224.61:2181?backup=10.194.224.62:2181,10.194.224.63:2181&quot; protocol=&quot;zookeeper&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 声明需要调用的服务接口 --&gt;</span><br><span class="line">    &lt;dubbo:reference interface=&quot;com.ruanshubin.service.DemoService&quot; id=&quot;demoService&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>对dubbo_service执行install后，然后分别对dubbo_provider和dubbo_consumer执行package打包。</p><h2 id="示例测试"><a href="#示例测试" class="headerlink" title="示例测试"></a>示例测试</h2><h3 id="监控中心及管理控制台"><a href="#监控中心及管理控制台" class="headerlink" title="监控中心及管理控制台"></a>监控中心及管理控制台</h3><p>为方便查看服务的启动和调用(消费)情况，需要安装监控中心及管理控制台，其具体安装步骤如下：</p><ul><li>监控中心</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># 创建安装目录</span><br><span class="line">[root@slave1 software]# mkdir dubbo</span><br><span class="line"></span><br><span class="line"># 上传安装包、解压</span><br><span class="line">[root@slave1 ~]# mv dubbo-monitor-simple-2.5.3-assembly.tar.gz /usr/software/dubbo/</span><br><span class="line">tar -zxvf dubbo-monitor-simple-2.5.3-assembly.tar.gz</span><br><span class="line"></span><br><span class="line"># 修改配置文件，主要是修改注册中心的地址dubbo.registry.address</span><br><span class="line"># 这里填上设置好的Zookeeper集群地址</span><br><span class="line">[root@slave1 dubbo-monitor-simple-2.5.3]# vim conf/dubbo.properties</span><br><span class="line"></span><br><span class="line">dubbo.container=log4j,spring,registry,jetty</span><br><span class="line">dubbo.application.name=simple-monitor</span><br><span class="line">dubbo.application.owner=</span><br><span class="line">#dubbo.registry.address=multicast://224.5.6.7:1234</span><br><span class="line">dubbo.registry.address=zookeeper://slave1:2181?backup=slave2:2181,slave3:2181</span><br><span class="line">#dubbo.registry.address=redis://127.0.0.1:6379</span><br><span class="line">#dubbo.registry.address=dubbo://127.0.0.1:9090</span><br><span class="line">dubbo.protocol.port=7070</span><br><span class="line">dubbo.jetty.port=9090</span><br><span class="line">dubbo.jetty.directory=$&#123;user.home&#125;/monitor</span><br><span class="line">dubbo.charts.directory=$&#123;dubbo.jetty.directory&#125;/charts</span><br><span class="line">dubbo.statistics.directory=$&#123;user.home&#125;/monitor/statistics</span><br><span class="line">dubbo.log4j.file=logs/dubbo-monitor-simple.log</span><br><span class="line">dubbo.log4j.level=WARN</span><br><span class="line"></span><br><span class="line"># 修改完配置文件，然后启动</span><br><span class="line">bin/start.sh</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/10431632-ad246954920c2bdf.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="管理控制台"><a href="#管理控制台" class="headerlink" title="管理控制台"></a>管理控制台</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># 首先安装tomcat容器</span><br><span class="line"></span><br><span class="line"># 创建安装目录</span><br><span class="line">mkdir /usr/software/tomcat</span><br><span class="line"># 将安装包移动到安装目录</span><br><span class="line">mv ~/apache-tomcat-8.5.35.tar.gz /usr/software/tomcat</span><br><span class="line"># 切换到安装目录并解压</span><br><span class="line">cd /usr/software/tomcat </span><br><span class="line">tar -zxvf apache-tomcat-8.5.35.tar.gz</span><br><span class="line"># 启动</span><br><span class="line">bin/startup.sh</span><br><span class="line"># 登录界面 IP:8080</span><br><span class="line"></span><br><span class="line"># 清空tomcat/webapps/ROOT目录</span><br><span class="line">[root@slave1 apache-tomcat-8.5.35]# rm -rf webapps/ROOT/*</span><br><span class="line"># 解压dubbo-admin.war至tomcat/webapps/ROOT</span><br><span class="line">[root@slave1 apache-tomcat-8.5.35]# mv ~/dubbo-admin-2.5.4-jdk1.8.war /usr/software/dubbo/apache-tomcat-8.5.35</span><br><span class="line">[root@slave1 apache-tomcat-8.5.35]# unzip dubbo-admin-2.5.4-jdk1.8.war -d webapps/ROOT/</span><br><span class="line"></span><br><span class="line"># 修改配置文件，主要是配置管理控制台的注册中心地址，及用户名密码</span><br><span class="line">[root@slave1 apache-tomcat-8.5.35]# cd webapps/ROOT/WEB-INF/</span><br><span class="line">[root@slave1 WEB-INF]# vim dubbo.properties</span><br><span class="line"></span><br><span class="line">dubbo.registry.address=zookeeper://slave1:2181?backup=slave2:2181,slave3:2181</span><br><span class="line">dubbo.admin.root.password=root</span><br><span class="line">dubbo.admin.guest.password=guest</span><br><span class="line"></span><br><span class="line"># 启动tomcat</span><br><span class="line">bin/startup.sh</span><br></pre></td></tr></table></figure><p>管理控制台默认Web端口号为8080。</p><p><img src="https://upload-images.jianshu.io/upload_images/10431632-824f068dd9c21688.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="部署测试"><a href="#部署测试" class="headerlink" title="部署测试"></a>部署测试</h3><p>首先，将Provider端部署包dubbo_provider-1.0-SNAPSHOT.jar上传到相应机器，这里我上传了4台机器：</p><p><img src="https://upload-images.jianshu.io/upload_images/10431632-61989b21ce353957.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在4台机器上分别执行下述命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar dubbo_provider-1.0-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/10431632-412e9c4f06e7f807.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p>注意：部署的机器须保证有对应版本的Java环境。</p></blockquote><p>登录Dubbo的管理控制台，可以看到DemoService服务已经存在，并存在于4台机器上。</p><p><img src="https://upload-images.jianshu.io/upload_images/10431632-80c1518d28c316c2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/10431632-2963947719917e80.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>随便找一台与之前4台机器联网、有Java环境的机器，打开终端输入以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar dubbo_consumer-1.0-SNAPSHOT.jar World</span><br></pre></td></tr></table></figure><p>可以看出，调用远程服务成功。</p><p><img src="https://upload-images.jianshu.io/upload_images/10431632-04aa286cc10abfc8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>下面看看4台机器被调用的次数：</p><p>1号机器调用5次：</p><p><img src="https://upload-images.jianshu.io/upload_images/10431632-b5682ef3d8d28b50.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>2号机器被调用3次：</p><p><img src="https://upload-images.jianshu.io/upload_images/10431632-6d4ad15d02a7a744.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>3号机器被调用2次：</p><p><img src="https://upload-images.jianshu.io/upload_images/10431632-ffb85362fe32121a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>4号机器被调用0次：</p><p><img src="https://upload-images.jianshu.io/upload_images/10431632-fa3268644f0f41d0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>之所以这样的原因是：Dubbo默认的负载均衡策略为Random。</p><p>Dubbo有4种均衡策略，其具体的工作机制是怎么样的呢，篇幅有限，我们下次出一篇专门讲。</p><p><img src="https://upload-images.jianshu.io/upload_images/10431632-a592bb9d7a331a0a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="行走的思想者"></p><p>欢迎您扫一扫上面的二维码，关注我的微信公众号！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;随着微服务的流行，Dubbo和Spring Cloud框架受到越来越多的关注，本文主要基于1个简单Demo来介绍Dubbo框架的工作流程。&lt;/p&gt;
&lt;h2 id=&quot;Dubbo是什么&quot;&gt;&lt;a href=&quot;#Dubbo是什么&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="SpringCloud" scheme="http://ruanshubin.top/categories/SpringCloud/"/>
    
    
      <category term="微服务" scheme="http://ruanshubin.top/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="Dubbo" scheme="http://ruanshubin.top/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>一文搞懂原码、反码、补码</title>
    <link href="http://ruanshubin.top/2018/12/10/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%E5%8E%9F%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81/"/>
    <id>http://ruanshubin.top/2018/12/10/一文搞懂原码、反码、补码/</id>
    <published>2018-12-10T07:19:00.000Z</published>
    <updated>2019-09-16T01:37:16.331Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>计算机底层均是以二进制表示的，数字也不例外，本文旨在探讨一下数字的原码、反码和补码。</p></blockquote><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>需要声明的是，本文涉及到的数字及运算均基于<strong>8位bit</strong>下的值。</p><h3 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h3><p>最高位为符号位，0代表正数，1代表负数，非符号位为该数字绝对值的二进制表示。</p><p>如：</p><p>127的原码为0111 1111<br>-127的原码为1111 1111</p><h3 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h3><p>正数的反码与原码一致；</p><p>负数的反码是对原码按位取反，只是<strong>最高位(符号位)不变</strong>。</p><p>如:</p><p>127的反码为0111 1111<br>-127的反码为1000 0000</p><h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><p>正数的补码与原码一致；</p><p>负数的补码是该数的<strong>反码加1</strong>。</p><p>如：</p><p>127的补码为0111 1111<br>-127的补码为1000 0001</p><p>总结一下就是：</p><ol><li><p>正数的原码、反码、补码是一致的；</p></li><li><p>负数的补码是反码加1，反码是对原码按位取反，只是<strong>最高位(符号位)不变</strong>；</p></li><li><p>计算机数字运算均是基于<strong>补码</strong>的。</p></li></ol><p>下面就来探讨一下，为啥要用补码来表示数字。</p><h2 id="补码有啥好？"><a href="#补码有啥好？" class="headerlink" title="补码有啥好？"></a>补码有啥好？</h2><p>如果计算机内部采用原码来表示数，那么在进行加法和减法运算的时候，需要转化为两个绝对值的加法和减法运算；</p><p>计算机既要实现加法器，又要实现减法器，代价有点大，那么可不可以只用一种类型的运算器来实现加和减的远算呢？</p><p>很容易想到的就是<strong>化减为加</strong>，举一个生活中的例子来说明这个问题：</p><p>时钟一圈是360度，当然也存在365度，但其实它和5度是一样的；</p><p>相同的道理，-30度表示逆时针旋转30度，其与顺时针旋转330度是一样的；</p><p>这里数字360表示时钟的一圈，在计算机里类似的概念叫<strong>模</strong>，它可以实现<strong>化减为加</strong>，本质上是将<strong>溢出的部分舍去</strong>而不改变结果。</p><p>易得，单字节(8位)运算的模为256=2^8。</p><p>在没有符号位的情况下，127+2=129，即：</p><p><img src="https://upload-images.jianshu.io/upload_images/10431632-bc74cfceab8109d3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>这时，我们将最高位作为符号位，计算机数字均以补码来表示，则1000 0001的原码为减1后按位取反得1111 1111，也就是-127。</p><p>也就是说，计算机里的129即表示-127，相当于模256为一圈，顺时针的129则和逆时针127即-127是一样的。</p><p>故可以得到以下结论：</p><p>负数的补码为<strong>模减去该数的绝对值</strong>。 </p><p>如-5的补码为：</p><p>-5=256-5=251=1111 1011(二进制)</p><p>同样的，临界值-128也可以表示出来：</p><p>-128=256-128=128=1000 0000(二进制)</p><p>但是正128就会溢出了，故单字节(8位)表示的数字范围为-128—127。</p><p>最后，我们来看一下，补码是如何通过模的<strong>溢出舍弃</strong>操作来完成<strong>化减为加</strong>的！</p><p>16-5=16+(-5)=11</p><p><img src="https://upload-images.jianshu.io/upload_images/10431632-548439c31aba9e05.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>1 0000 1011将溢出位舍去，得0000 1011(二进制)=11。</p><p>好的，本文分享就到这里，希望能够帮助到大家。</p><p><img src="https://upload-images.jianshu.io/upload_images/10431632-a592bb9d7a331a0a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="行走的思想者"></p><p>欢迎您扫一扫上面的二维码，关注我的微信公众号！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;计算机底层均是以二进制表示的，数字也不例外，本文旨在探讨一下数字的原码、反码和补码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;
      
    
    </summary>
    
      <category term="基础知识" scheme="http://ruanshubin.top/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="编码" scheme="http://ruanshubin.top/tags/%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
</feed>
