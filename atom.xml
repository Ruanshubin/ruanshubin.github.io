<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>阮树斌 | 技术改变生活</title>
  
  <subtitle>交通 | 数据 | 算法 &lt;br&gt; Java | Python | Scala | Matlab | GIS</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ruanshubin.top/"/>
  <updated>2019-12-25T03:16:55.091Z</updated>
  <id>http://ruanshubin.top/</id>
  
  <author>
    <name>Ruan Shubin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PostgreSQL</title>
    <link href="http://ruanshubin.top/2019/11/02/PostgreSQL%E5%AE%89%E8%A3%85/"/>
    <id>http://ruanshubin.top/2019/11/02/PostgreSQL安装/</id>
    <published>2019-11-02T13:30:00.000Z</published>
    <updated>2019-12-25T03:16:55.091Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备编译环境"><a href="#准备编译环境" class="headerlink" title="准备编译环境"></a>准备编译环境</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 检查服务器上是否存在gcc-c++的环境，使用命令：</span><br><span class="line">rpm -qa | grep gcc-c++</span><br><span class="line"></span><br><span class="line"># 若无，则访问镜像网站获取：http://mirrors.aliyun.com/centos/7/os/x86_64/Packages/</span><br><span class="line"></span><br><span class="line">rpm -Uvh *.rpm --nodeps --force</span><br><span class="line"></span><br><span class="line"># 查看gcc版本和g++版本，会看到详细的版本信息，安装完成</span><br><span class="line"></span><br><span class="line">gcc -v</span><br><span class="line">g++ -v</span><br></pre></td></tr></table></figure><h2 id="编译postgresql源码包，并安装"><a href="#编译postgresql源码包，并安装" class="headerlink" title="编译postgresql源码包，并安装"></a>编译postgresql源码包，并安装</h2><p>访问 <a href="https://www.postgresql.org/ftp/source/，选择对应版本：" target="_blank" rel="noopener">https://www.postgresql.org/ftp/source/，选择对应版本：</a></p><p><img src="/2019/11/02/PostgreSQL安装/1.jpg" alt=""></p><p>点击之后，下载对应的tar.gz源码包，然后将其上传到服务器指定路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">[root@test postgresql]# tar -zvxf postgresql-9.6.9.tar.gz </span><br><span class="line"></span><br><span class="line"># 进入解压后目录，通过命令 ./configure --help 可以看到配置相关的帮助信息</span><br><span class="line">[root@test postgresql]# cd postgresql-9.6.9/</span><br><span class="line">[root@test postgresql-9.6.9]# ./configure --help</span><br><span class="line"></span><br><span class="line"># 其中，--prefix=dir 可以指定安装目录：</span><br><span class="line">[root@test software]# mkdir pgsql</span><br><span class="line"></span><br><span class="line">[root@test postgresql-9.6.9]# ./configure --prefix=/usr/software/pgsql</span><br><span class="line"></span><br><span class="line"># 此时，会报以下错误：</span><br><span class="line"></span><br><span class="line">configure: error: readline library not found</span><br><span class="line">If you have readline already installed, see config.log for details on the</span><br><span class="line">failure.  It is possible the compiler isn&apos;t looking in the proper directory.</span><br><span class="line">Use --without-readline to disable readline support.</span><br><span class="line"></span><br><span class="line"># 安装缺少的包即可</span><br><span class="line"></span><br><span class="line">[root@test outrpm]# rpm -ivh ncurses-devel-5.9-14.20130511.el7_4.x86_64.rpm </span><br><span class="line">[root@test outrpm]# rpm -ivh readline-devel-6.2-10.el7.x86_64.rpm </span><br><span class="line">[root@test outrpm]# rpm -ivh zlib-1.2.7-18.el7.x86_64.rpm </span><br><span class="line"></span><br><span class="line"># 安装zlib会与原来的zlib冲突</span><br><span class="line">[root@test outrpm]# rpm -ivh zlib-1.2.7-18.el7.x86_64.rpm </span><br><span class="line">warning: zlib-1.2.7-18.el7.x86_64.rpm: Header V3 RSA/SHA256 Signature, key ID f4a80eb5: NOKEY</span><br><span class="line">Preparing...                          ################################# [100%]</span><br><span class="line">        file /usr/lib64/libz.so.1.2.7 from install of zlib-1.2.7-18.el7.x86_64 conflicts with file from package zlib-1.2.7-17.el7.x86_64</span><br><span class="line"></span><br><span class="line"># 添加--force参数强制更新  --nodeps 为不考虑依赖</span><br><span class="line">[root@test outrpm]# rpm -ivh zlib-1.2.7-18.el7.x86_64.rpm --force</span><br><span class="line"></span><br><span class="line">[root@tcd-test outrpm]# rpm -ivh zlib-devel-1.2.7-18.el7.x86_64.rpm </span><br><span class="line"></span><br><span class="line"># 然后，重新注册即可</span><br><span class="line">[root@test postgresql-9.6.9]# ./configure --prefix=/usr/software/pgsql</span><br><span class="line">[root@tcd-test postgresql-9.6.9]# make</span><br><span class="line">[root@tcd-test postgresql-9.6.9]# make install</span><br></pre></td></tr></table></figure><h2 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h2><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@tcd-test ~]# groupadd postgres</span><br><span class="line">[root@tcd-test ~]# useradd postgres -g postgres</span><br><span class="line">[root@tcd-test ~]# passwd postgres</span><br><span class="line"></span><br><span class="line"># 在安装目录创建data和log目录</span><br><span class="line">[root@tcd-test ~]# cd /usr/software/pgsql/</span><br><span class="line">[root@tcd-test pgsql]# mkdir data</span><br><span class="line">[root@tcd-test pgsql]# mkdir log</span><br><span class="line"></span><br><span class="line"># 设定权限</span><br><span class="line">[root@tcd-test ~]# chown -R postgres:postgres /usr/software/pgsql/</span><br></pre></td></tr></table></figure><h3 id="环境变量配置"><a href="#环境变量配置" class="headerlink" title="环境变量配置"></a>环境变量配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line"># 底部添加以下内容：</span><br><span class="line">export PGDATA=/usr/software/pgsql/data</span><br><span class="line">export PG_HOME=/usr/software/pgsql</span><br><span class="line">export PATH=$PATH:$PG_HOME/bin</span><br><span class="line"></span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><h3 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 初始化数据库的帮助信息</span><br><span class="line">[root@tcd-test pgsql]# initdb --help</span><br></pre></td></tr></table></figure><p><img src="/2019/11/02/PostgreSQL安装/2.jpg" alt=""></p><p>由于之前在配置文件中已经设定了环境变量 PGDATA ，因此可以直接使用命令 initdb 来完成数据库初始化操作。</p><p><strong>切换为postgres用户</strong>,初始化数据库。</p><p>注意，如果root用户下执行数据库初始化操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@tcd-test pgsql]# initdb </span><br><span class="line">initdb: cannot be run as root</span><br><span class="line">Please log in (using, e.g., &quot;su&quot;) as the (unprivileged) user that will</span><br><span class="line">own the server process.</span><br><span class="line"></span><br><span class="line">[root@tcd-test pgsql]# su postgres</span><br><span class="line">[postgres@tcd-test pgsql]$ initdb</span><br></pre></td></tr></table></figure><h3 id="配置数据库"><a href="#配置数据库" class="headerlink" title="配置数据库"></a>配置数据库</h3><p>进入*/pgsql/data 目录，使用命令vim pg_hba.conf，配置对数据库的访问控制(设置为可以通过密码访问);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[postgres@tcd-test pgsql]$ cd /usr/software/pgsql/data</span><br><span class="line">[postgres@tcd-test data]$ vim ./pg_hba.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/11/02/PostgreSQL安装/3.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[postgres@tcd-test data]$ vim ./postgresql.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/11/02/PostgreSQL安装/4.jpg" alt=""></p><h3 id="关闭防火墙-root用户"><a href="#关闭防火墙-root用户" class="headerlink" title="关闭防火墙(root用户)"></a>关闭防火墙(root用户)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 查看防火墙状态</span><br><span class="line">systemctl status firewalld</span><br><span class="line"># 关闭防火墙</span><br><span class="line">systemctl stop firewalld</span><br><span class="line"># 设置开机不启动</span><br><span class="line">systemctl disable firewalld</span><br></pre></td></tr></table></figure><h3 id="配置系统服务-root用户"><a href="#配置系统服务-root用户" class="headerlink" title="配置系统服务(root用户)"></a>配置系统服务(root用户)</h3><p>进入postgresql源码包的解压目录；</p><p>执行命令 cp contrib/start-scripts/linux /etc/init.d/postgresql；</p><p>然后vim /etc/init.d/postgresql，进行配置修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@tcd-test ~]# cd /usr/software/postgresql/postgresql-9.6.9/</span><br><span class="line">[root@tcd-test postgresql-9.6.9]# cp contrib/start-scripts/linux /etc/init.d/postgresql</span><br><span class="line">vim /etc/init.d/postgresql</span><br></pre></td></tr></table></figure><p><img src="/2019/11/02/PostgreSQL安装/5.jpg" alt=""></p><p>使用命令chmod +x /etc/init.d/postgresql，赋予该文件执行权限;</p><p>另外，还可以使用命令chkconfig —add postgresql，设置服务开机自启。</p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><h3 id="启动数据库服务"><a href="#启动数据库服务" class="headerlink" title="启动数据库服务"></a>启动数据库服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@tcd-test ~]# service postgresql status</span><br><span class="line">pg_ctl: no server running</span><br><span class="line">[root@tcd-test ~]# service postgresql start</span><br><span class="line">Starting PostgreSQL: ok</span><br></pre></td></tr></table></figure><h3 id="本地连接"><a href="#本地连接" class="headerlink" title="本地连接"></a>本地连接</h3><p>启动成功后，可以通过postgresql自带的客户端工具psql来进行连接；</p><p>postgresql用户直接输入psql看到版本信息则说明连接成功。</p><p>然后，使用 “\password”，设置密码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@tcd-test ~]# su postgres</span><br><span class="line">[postgres@tcd-test root]$ psql</span><br><span class="line">could not change directory to &quot;/root&quot;: Permission denied</span><br><span class="line">psql (9.6.9)</span><br><span class="line">Type &quot;help&quot; for help.</span><br><span class="line"></span><br><span class="line">postgres=# \password</span><br><span class="line">Enter new password: </span><br><span class="line">Enter it again: </span><br><span class="line">postgres=# </span><br><span class="line">postgres=# \l</span><br><span class="line">                                  List of databases</span><br><span class="line">   Name    |  Owner   | Encoding |   Collate   |    Ctype    |   Access privileges   </span><br><span class="line">-----------+----------+----------+-------------+-------------+-----------------------</span><br><span class="line"> postgres  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | </span><br><span class="line"> template0 | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +</span><br><span class="line">           |          |          |             |             | postgres=CTc/postgres</span><br><span class="line"> template1 | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +</span><br><span class="line">           |          |          |             |             | postgres=CTc/postgres</span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure><h3 id="远程连接"><a href="#远程连接" class="headerlink" title="远程连接"></a>远程连接</h3><p><img src="/2019/11/02/PostgreSQL安装/6.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;准备编译环境&quot;&gt;&lt;a href=&quot;#准备编译环境&quot; class=&quot;headerlink&quot; title=&quot;准备编译环境&quot;&gt;&lt;/a&gt;准备编译环境&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gut
      
    
    </summary>
    
      <category term="基础" scheme="http://ruanshubin.top/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="数据库" scheme="http://ruanshubin.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="PostgreSQL" scheme="http://ruanshubin.top/tags/PostgreSQL/"/>
    
  </entry>
  
  <entry>
    <title>git私服搭建</title>
    <link href="http://ruanshubin.top/2019/11/01/git%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/"/>
    <id>http://ruanshubin.top/2019/11/01/git私服搭建/</id>
    <published>2019-11-01T13:30:00.000Z</published>
    <updated>2019-12-25T03:12:21.896Z</updated>
    
    <content type="html"><![CDATA[<h2 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h2><p>系统： Linux：<strong>CentOS 7.2 64位</strong></p><p>由于CentOS已经内置了<strong>OpenSSH</strong>,如果您的系统没有，请自行安装。</p><p>查看ssh版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@ruanshubin ~]# ssh -V</span><br><span class="line"></span><br><span class="line"># 输出以下表示没问题，可以继续。 版本可能不一致，能用即可。</span><br><span class="line">OpenSSH_7.4p1, OpenSSL 1.0.2k-fips  26 Jan 2017</span><br></pre></td></tr></table></figure><blockquote><p>避免系统环境和其他的不一致，请核对您系统的版本，其他发行版请对应修改。</p></blockquote><h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><p>建议以下操作都切换到root:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 请确保您切换到了root账户</span><br><span class="line">$ su root</span><br><span class="line">$ yum install -y git</span><br><span class="line"></span><br><span class="line"># 验证是否安装成功</span><br><span class="line">$ git --version</span><br><span class="line"># 输出如下内容表示成功：</span><br><span class="line">git version x.x.x.x</span><br></pre></td></tr></table></figure><h2 id="添加git的管理的账户和设置密码"><a href="#添加git的管理的账户和设置密码" class="headerlink" title="添加git的管理的账户和设置密码"></a>添加git的管理的账户和设置密码</h2><p>设置专门管理git的账号非必须，但是建议这么操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 添加git账户</span><br><span class="line">$ adduser git</span><br><span class="line"></span><br><span class="line"># 修改git的密码</span><br><span class="line">$ passwd git</span><br><span class="line"># 然后两次输入git的密码确认后。</span><br><span class="line"></span><br><span class="line"># 查看git是否安装成功</span><br><span class="line">$ cd /home &amp;&amp; ls -al</span><br><span class="line"># 如果已经有了git，那么表示成，参考如下：</span><br><span class="line">drwxr-xr-x.  5 root root 4096 Apr  4 15:03 .</span><br><span class="line">dr-xr-xr-x. 19 root root 4096 Apr  4 15:05 ..</span><br><span class="line">drwx------  10 git  git  4096 Apr  4 00:26 git</span><br><span class="line"></span><br><span class="line"># 默认还给我们分配一个名字叫git的组。</span><br></pre></td></tr></table></figure><h2 id="git的权限管理"><a href="#git的权限管理" class="headerlink" title="git的权限管理"></a>git的权限管理</h2><p>git仓库的权限管理，我们可以手动进行管理和配置，也可以通过其他辅助工具。如果小团队的话，直接通过ssh公钥进行管理即可，如果大点的团队，最好用gitolite 或者 gitosis，两者都差不多，一个是Perl开发，一个是Python开发。</p><p>以下我分别介绍手动管理权限和使用gitolite管理的方式，注意两者不兼容，不能混用。</p><h3 id="git的手动权限管理"><a href="#git的手动权限管理" class="headerlink" title="git的手动权限管理"></a>git的手动权限管理</h3><p>经过以上步骤，其实服务器的基本已经配置好，但是需要设置权限和配置远程访问git仓库的方式。我们只介绍ssh的方式，https不做介绍。</p><h4 id="配置服务端的ssh访问"><a href="#配置服务端的ssh访问" class="headerlink" title="配置服务端的ssh访问"></a>配置服务端的ssh访问</h4><p>切换到git账号,并创建ssh的默认目录和校验公钥的配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 1.切换到git账号</span><br><span class="line">$ su git</span><br><span class="line"># 2.进入 git账户的主目录</span><br><span class="line">$ cd /home/git</span><br><span class="line"></span><br><span class="line"># 3.创建.ssh的配置，如果此文件夹已经存在请忽略此步。</span><br><span class="line">$ mkdir .ssh</span><br><span class="line"></span><br><span class="line"># 4. 进入刚创建的.ssh目录并创建authorized_keys文件,此文件存放客户端远程访问的 ssh的公钥。</span><br><span class="line">$ cd /home/git/.ssh</span><br><span class="line">$ touch authorized_keys</span><br><span class="line"></span><br><span class="line"># 5. 设置权限，此步骤不能省略，而且权限值也不要改，不然会报错。</span><br><span class="line">$ chmod 700 /home/git/.ssh/</span><br><span class="line">$ chmod 600 /home/git/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>此时，服务端的配置基本完成。接下需要把客户端的公钥拷贝到authorized_keys文件中。</p><h4 id="配置客户端的ssh私钥并上传服务器"><a href="#配置客户端的ssh私钥并上传服务器" class="headerlink" title="配置客户端的ssh私钥并上传服务器"></a>配置客户端的ssh私钥并上传服务器</h4><p>以下是客户端创建ssh私钥和拷贝的过程，如果您有私钥越过创建私钥的过程。</p><p>请用您的客户端进入终端（如果只有一台电脑，可以用不同的账号模拟不同客户端）</p><p>第一步： 创建客户端的ssh私钥和公钥</p><p>检查是否已经拥有ssh公钥和私钥：进入用户的主目录。</p><p>用户主目录：<br>Windows系统：C:\Users\用户名<br>Linux系统：/home/用户名<br>Mac系统：/Users/用户名</p><p>然后查看是否有.ssh文件夹，此文件夹下是否有如下几个文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 用户主目录的.ssh文件夹下</span><br><span class="line">.ssh</span><br><span class="line">├── id_rsa</span><br><span class="line">└── id_rsa.pub  # 我们要用的私钥</span><br></pre></td></tr></table></figure><p>如果没有，那么用ssh-keygen创建ssh的私钥。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa</span><br><span class="line"></span><br><span class="line"># 接下来，三个回车默认即可。</span><br></pre></td></tr></table></figure><p>创建私钥成功后，在查看用户目录是否有意加有了公钥文件id_rsa.pub</p><p>第二步： 拷贝私钥到git的服务器</p><p>如何把客户端的文件拷贝到服务器端，我建议用scp命令进行拷贝。</p><p>以下以mac系统为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 首先进入我的用户主目录的.ssh目录下，注意用户名xxx替换成自己的</span><br><span class="line">$ cd /Users/xxx/.ssh</span><br><span class="line"></span><br><span class="line"># 以下命令是：把本地的id_rsa.pub文件拷贝到 aicoder.com服务器，登录aicoder.com服务的账号是git。</span><br><span class="line"># 冒号后面默认就是git账号的主目录，最后文件被保存成laoma.pub</span><br><span class="line"># 注意：把域名换成你自己的或者ip，最后的文件名可以自己定，后面还有用。</span><br><span class="line">$ scp ./id_rsa.pub git@aicoder.com:.ssh/laoma.pub</span><br></pre></td></tr></table></figure><h4 id="服务器端添加客户端的SSH公钥"><a href="#服务器端添加客户端的SSH公钥" class="headerlink" title="服务器端添加客户端的SSH公钥"></a>服务器端添加客户端的SSH公钥</h4><p>切换到服务器端，把刚才上传的laoma.pub文件的内容添加到 authorized_keys中，就可以允许客户端ssh访问了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 切换到git账户</span><br><span class="line">$ su git</span><br><span class="line">$ cd /home/git/.ssh</span><br><span class="line"></span><br><span class="line">$ ls -al</span><br><span class="line"># 查看一下.ssh目录是否有authorized_keys和laoma.pub文件</span><br><span class="line"># .</span><br><span class="line"># |-- authorized_keys</span><br><span class="line"># `-- laoma.pub</span><br><span class="line"></span><br><span class="line"># 如果有，那么进行下面的把laoma.pub文件中的内容添加到authorized_keys中.</span><br><span class="line">$ cat laoma.pub &gt;&gt; authorized_keys</span><br><span class="line"></span><br><span class="line"># &gt;&gt; 是在文件后面追加的意思，主要如果用其他编辑器，每个ssh的pub要单独一行，建议用cat命令方便简单。</span><br></pre></td></tr></table></figure><p>到此为止，您配置的客户端应该可以ssh的方式直接用git账号登录服务器。(当然不安全，后面可以控制)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 在客户端用ssh测试连接远程服务器,请将域名aicoder.com换成你的ip地址或者域名</span><br><span class="line">$ ssh git@aicoder.com    </span><br><span class="line"></span><br><span class="line"># 第一次连接有警告，输入yes继续即可。如果可以连接上，那么恭喜你的ssh配置已经可以了。</span><br></pre></td></tr></table></figure><h4 id="服务器端创建测试git仓库"><a href="#服务器端创建测试git仓库" class="headerlink" title="服务器端创建测试git仓库"></a>服务器端创建测试git仓库</h4><p>进入服务器的终端。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 切换到git账号</span><br><span class="line">$ su git</span><br><span class="line"># 进入git账号的用户主目录。</span><br><span class="line"></span><br><span class="line">$ cd /home/git</span><br><span class="line"># 在用户主目录下创建 test.git仓库的文件夹</span><br><span class="line"></span><br><span class="line">$ mkdir test.git  &amp;&amp; cd test.git</span><br><span class="line"># 在test.git目录下初始化git仓库</span><br><span class="line"></span><br><span class="line">$ git init --bare</span><br><span class="line"># 输出如下内容，表示成功</span><br><span class="line">Initialized empty Git repository in /home/git/test.git/</span><br></pre></td></tr></table></figure><blockquote><p>git init —bare 是在当前目录创建一个裸仓库，也就是说没有工作区的文件，直接把git仓库隐藏的文件放在当前目录下，此目录仅用于存储仓库的历史版本等数据。</p></blockquote><p>此时，客户端就可以进行clone或者remote add此仓库了。</p><h4 id="客户端测试连接git远程仓库"><a href="#客户端测试连接git远程仓库" class="headerlink" title="客户端测试连接git远程仓库"></a>客户端测试连接git远程仓库</h4><p>客户端，可以新建一个文件夹，初始化一个仓库，然后跟远程服务器上的空仓库建立连接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 以下shell代码，纯手写没有验证，如果有错误请自行纠正。</span><br><span class="line">$ mkdir demos &amp;&amp; cd demos</span><br><span class="line">$ git init</span><br><span class="line">$ touch a.txt</span><br><span class="line">$ echo &apos;aicoder.com&apos; &gt;&gt; a.txt</span><br><span class="line"></span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m &apos;the first commit&apos;</span><br><span class="line"></span><br><span class="line"># 把当前仓库跟远程仓库添映射</span><br><span class="line">$ git remote add origin git@aicoder.com:test.git</span><br><span class="line"></span><br><span class="line"># 把当前仓库push到远程仓库。</span><br><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure><p>到此为止，我们就可以尽情的享用git私服了，但是！但是！但是！客户端可以直接ssh登录啊，这是bug，也是不安全的隐患，且看下面怎么禁用git账号的shell登录。</p><h4 id="修改Git-remote-add时使用的远程仓库"><a href="#修改Git-remote-add时使用的远程仓库" class="headerlink" title="修改Git remote add时使用的远程仓库"></a>修改Git remote add时使用的远程仓库</h4><p>方法一：</p><p>git remote rm origin<br>git remote add origin git@github.com:Liutos/foobar.git</p><p>方法二：</p><p>git remote set-url origin <url><br>把<url>替换成新的url地址。</url></url></p><p>方法三：</p><p>直接修改.git/config文件</p><h4 id="禁止客户端shell登录"><a href="#禁止客户端shell登录" class="headerlink" title="禁止客户端shell登录"></a>禁止客户端shell登录</h4><p>因为前面我们添加了客户端的ssh的公钥到远程服务器，所以客户端可以直接通过shell远程登录服务器，这不安全，也不是我们想要的。且看下面如何禁用shell登录：</p><p>第一步：<br>给 /home/git 下面创建git-shell-commands目录，并把目录的拥有者设置为git账户。可以直接用git账号登录服务器终端操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ su git</span><br><span class="line">$ mkdir /home/git/git-shell-commands</span><br></pre></td></tr></table></figure><blockquote><p>此文件夹是git-shell用到的目录，需要我们手动创建，不然报错：fatal: Interactive git shell is not enabled. hint: ~/git-shell-commands should exist and have read and execute access.</p></blockquote><p>第二步：修改/etc/passwd文件，修改:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/passwd</span><br><span class="line"></span><br><span class="line"># 可以通过 vim的正则搜索快速定位到这行，  命名模式下  :/git:x</span><br><span class="line"></span><br><span class="line"># 找到这句, 注意1000可能是别的数字</span><br><span class="line">git:x:1000:1000::/home/git:/bin/bash</span><br><span class="line"></span><br><span class="line"># 改为：</span><br><span class="line">git:x:1000:1000::/home/git:/bin/git-shell</span><br><span class="line"></span><br><span class="line"># 最好不要直接改，可以先复制一行，然后注释掉一行，修改一行，保留原始的，这就是经验！！！</span><br><span class="line"># vim快捷键： 命令模式下：yy复制行， p 粘贴  0光标到行首 $到行尾 x删除一个字符  i进入插入模式 </span><br><span class="line"># 修改完后退出保存：  esc进入命令模式， 输入：:wq!   保存退出。</span><br></pre></td></tr></table></figure><p>好了，此时我们就不用担心客户端通过shell登录，只允许使用git-shell进行管理git的仓库。</p><p>如果有其他小伙伴要连接git服务器，仅需要把他的公钥也添加到authorized_keys即可。</p><h3 id="git的自动权限管理：gitolite"><a href="#git的自动权限管理：gitolite" class="headerlink" title="git的自动权限管理：gitolite"></a>git的自动权限管理：gitolite</h3><p>如果团队大点的，我们可以用gitolite管理，而且使用很方便。</p><h4 id="gitolite的安装和配置"><a href="#gitolite的安装和配置" class="headerlink" title="gitolite的安装和配置"></a>gitolite的安装和配置</h4><p>以下配置此承接第5，如果第6步您已经操作，请注意第二步的说明。</p><p>第一步：添加gitolite依赖的perl的包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum install &apos;perl(Data::Dumper)&apos;</span><br></pre></td></tr></table></figure><p>第二步：清空服务器端配置的ssh的公钥</p><p>确保：~/.ssh/authorized_keys文件是空的，或者不存在。如果已经存在，建议你把他改名即可，比如：authorized_keys.bak</p><p>第三步：上传管理员的客户端的ssh公钥到服务器</p><p>把你管理员电脑的ssh的id_rsa.pub文件拷贝到服务器的： $HOME/YourName.pub</p><p>YourName可以自定义，最好根据不同伙伴的名字命名。</p><p>参考：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># mac客户端</span><br><span class="line">$ scp /Users/fly/.ssh/id_rsa.pub git@aicoder.com:malun.pub</span><br></pre></td></tr></table></figure><p>第四步：安装配置gitolite</p><p>用git账号登录，并执行如下命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># 切换到git账号</span><br><span class="line">$ su git</span><br><span class="line"></span><br><span class="line"># 进入git主目录</span><br><span class="line">$ cd /home/git</span><br><span class="line"></span><br><span class="line"># 下载gitolite的仓库</span><br><span class="line">$ git clone https://github.com/sitaramc/gitolite</span><br><span class="line"></span><br><span class="line"># 创建bin文件夹，必须！！！</span><br><span class="line">$ mkdir -p $HOME/bin</span><br><span class="line"></span><br><span class="line"># 用下载下来的仓库中的insall执行安装操作，指向的目录就是上一命令行创建的目录</span><br><span class="line">$ ./gitolite二进制/install -to $HOME/bin</span><br><span class="line"></span><br><span class="line"># 把上传到服务器的 管理员的公钥setup到gitolite中，注意：YourName.pub改成你自己的文件名。</span><br><span class="line">$ ~/bin/gitolite setup -pk ~/YourName.pub</span><br><span class="line"></span><br><span class="line"># 此时安装配完成后，查看git主目录</span><br><span class="line">$ ls /home/git</span><br><span class="line">drwxr-xr-x   7 git  git  4096 Apr  3 23:50 bin               # 我们创建的存放gitolite二进制</span><br><span class="line">drwxrwxr-x   6 git  git  4096 Apr  3 23:40 gitolite</span><br><span class="line">drwx------   6 git  git  4096 Apr  3 23:52 .gitolite</span><br><span class="line">-rw-------   1 git  git  7130 Apr  3 23:52 .gitolite.rc</span><br><span class="line">-rw-------   1 git  git   398 Apr  3 23:39 malun.pub         # 管理员的公钥</span><br><span class="line">drwxrw----   3 git  git  4096 Apr  3 23:40 .pki</span><br><span class="line">-rw-------   1 git  git    19 Apr  4 00:26 projects.list     # 仓库列表（gitolite自动创建）</span><br><span class="line">drwx------   5 git  git  4096 Apr  4 00:26 repositories      # 存放所有仓库文件夹</span><br><span class="line">drwx------   2 git  git  4096 Apr  4 15:50 .ssh</span><br><span class="line"></span><br><span class="line"># repositories目录下已经有了两个git仓库了。</span><br><span class="line"># .</span><br><span class="line"># |-- gitolite-admin.git    # 管理配置权限的仓库</span><br><span class="line"># `-- testing.git           # 测试仓库</span><br></pre></td></tr></table></figure><p>好了，到此位置，管理员就可以直接把默认的远程管理的仓库gitolite-admin直接clone到本地进行管理git服务了。</p><p>第五步：管理员在本地管理和配置服务器端的仓库</p><p>下载服务器端的远程管理仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 下载远程管理仓库, 请把aicoder.com换成你自己服务器的域名或者ip</span><br><span class="line">$ git clone git@aicoder.com:gitolite-admin</span><br><span class="line">$ cd gitolite-admin</span><br><span class="line"># 目录结构如下：</span><br><span class="line"># .</span><br><span class="line"># ├── conf                # 配置文件夹</span><br><span class="line"># │   └── gitolite.conf   # 配置权限的文件</span><br><span class="line"># └── keydir              # 客户端的公钥文件夹，所有伙伴的公钥要放到此目录下</span><br><span class="line">#     └── malun.pub</span><br></pre></td></tr></table></figure><h4 id="gitolite的权限配置"><a href="#gitolite的权限配置" class="headerlink" title="gitolite的权限配置"></a>gitolite的权限配置</h4><ul><li>添加其他开发的小伙伴</li></ul><p>把小伙伴的公钥发给管理员。管理员添加到gitolite-admin仓库的keydir目录下,注意文件名字格式为username.pub,username就是配置权限时的用户名。</p><ul><li>配置用户对仓库的读写权限</li></ul><p>直接修改conf文件夹下的，gitolite.conf文件。简单解释下几个用法：</p><ul><li>repo代表仓库的意思，如果新添加一个repo，代表服务端新建一个空仓库，仓库push到服务端后会自动创建。</li><li>RW 代表可读可写</li><li>@all 代表所有人。</li><li>master和 dev代表分支</li></ul><p>参考：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@admin = malun  </span><br><span class="line">@om = malun bcd  </span><br><span class="line">  </span><br><span class="line">repo gitolite-admin  </span><br><span class="line">    RW+     =   malun </span><br><span class="line">  </span><br><span class="line">repo testing  </span><br><span class="line">    RW+     =   @all  </span><br><span class="line">  </span><br><span class="line">repo om  </span><br><span class="line">    RW+     =   @admin  </span><br><span class="line">    RW+ master = @admin  </span><br><span class="line">    RW+ dev  =   @om</span><br></pre></td></tr></table></figure><ul><li>应用修改到服务器端</li></ul><p>做好配置后，由管理员把修改push到服务器端，会自动处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add conf</span><br><span class="line">$ git add keydir</span><br><span class="line">$ git commit -m &quot;added foo, gave access to alice, bob, carol&quot;</span><br><span class="line">$ git push</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;系统环境&quot;&gt;&lt;a href=&quot;#系统环境&quot; class=&quot;headerlink&quot; title=&quot;系统环境&quot;&gt;&lt;/a&gt;系统环境&lt;/h2&gt;&lt;p&gt;系统： Linux：&lt;strong&gt;CentOS 7.2 64位&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于CentOS已经内置了
      
    
    </summary>
    
      <category term="基础" scheme="http://ruanshubin.top/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Git" scheme="http://ruanshubin.top/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>gitlab搭建</title>
    <link href="http://ruanshubin.top/2019/11/01/gitlab%E6%90%AD%E5%BB%BA/"/>
    <id>http://ruanshubin.top/2019/11/01/gitlab搭建/</id>
    <published>2019-11-01T13:30:00.000Z</published>
    <updated>2019-12-25T03:11:22.347Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><ul><li>配置yum源</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/yum.repos.d/gitlab-ce.repo</span><br></pre></td></tr></table></figure><p>复制以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[gitlab-ce]</span><br><span class="line">name=gitlab-ce</span><br><span class="line">baseurl=http://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el6</span><br><span class="line">Repo_gpgcheck=0</span><br><span class="line">Enabled=1</span><br><span class="line">Gpgkey=https://packages.gitlab.com/gpg.key</span><br></pre></td></tr></table></figure><ul><li>更新本地yum缓存</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum makecache</span><br></pre></td></tr></table></figure><p><img src="/2019/11/01/gitlab搭建/1.jpg" alt=""></p><ul><li>安装GitLab社区版</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y gitlab-ce --nogpgcheck  #自动安装最新版</span><br><span class="line">sudo yum install gitlab-ce-x.x.x  #安装指定版本</span><br></pre></td></tr></table></figure><ul><li>GitLab常用命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-ctl start    # 启动所有 gitlab 组件；</span><br><span class="line">sudo gitlab-ctl stop        # 停止所有 gitlab 组件；</span><br><span class="line">sudo gitlab-ctl restart        # 重启所有 gitlab 组件；</span><br><span class="line">sudo gitlab-ctl status        # 查看服务状态；</span><br><span class="line">sudo gitlab-ctl reconfigure        # 启动服务；</span><br><span class="line">sudo vim /etc/gitlab/gitlab.rb        # 修改默认的配置文件；</span><br><span class="line">gitlab-rake gitlab:check SANITIZE=true --trace    # 检查gitlab；</span><br><span class="line">sudo gitlab-ctl tail        # 查看日志；</span><br></pre></td></tr></table></figure><h2 id="安装问题"><a href="#安装问题" class="headerlink" title="安装问题"></a>安装问题</h2><ul><li>yum安装软件时报错libmysqlclient.so.18()(64bit)</li></ul><p>环境：CentOS 7.2，使用网易yum的网络源<br>问题：<br>使用yum安装软件时报错<br>…<br>2:postfix-2.10.1-6.el7.x86_64 has missing requires of libmysqlclient.so.18()(64bit)<br>2:postfix-2.10.1-6.el7.x86_64 has missing requires of libmysqlclient.so.18(libmysqlclient_18)(64bit)<br>重点关注：libmysqlclient.so.18()(64bit)<br>解决:<br>缺少Percona-XtraDB-Cluster-shared-55-5.5.37-25.10.756.el6.x86_64.rpm这个包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># wget http://www.percona.com/redir/downloads/Percona-XtraDB-Cluster/5.5.37-25.10/RPM/rhel6/x86_64/Percona-XtraDB-Cluster-shared-55-5.5.37-25.10.756.el6.x86_64.rpm</span><br><span class="line"># rpm -ivh Percona-XtraDB-Cluster-shared-55-5.5.37-25.10.756.el6.x86_64.rpm</span><br></pre></td></tr></table></figure><ul><li>安装后访问报502</li></ul><p>解决方案为修改默认端口号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@ianly]# vim /etc/gitlab/gitlab.rb </span><br><span class="line"></span><br><span class="line">修改两个冲突端口号</span><br><span class="line">external_url &apos;http://ip:8899&apos;</span><br><span class="line">unicorn[&apos;port&apos;] = 8088</span><br><span class="line"></span><br><span class="line"># 启动GitLab</span><br><span class="line">[root@ianly]# gitlab-ctl reconfigure</span><br><span class="line">[root@ianly]# gitlab-ctl restart</span><br><span class="line"></span><br><span class="line"># 访问http://ip:8899</span><br></pre></td></tr></table></figure><ul><li>忘记root密码</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@ruanshubin gitlab]# gitlab-rails console production</span><br><span class="line"></span><br><span class="line">irb(main):01:0&gt; user = User.where(id:1).first</span><br><span class="line">irb(main):02:0&gt; user.password=&apos;Administrator&apos;</span><br><span class="line">irb(main):03:0&gt; user.save!</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装步骤&quot;&gt;&lt;a href=&quot;#安装步骤&quot; class=&quot;headerlink&quot; title=&quot;安装步骤&quot;&gt;&lt;/a&gt;安装步骤&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;配置yum源&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table
      
    
    </summary>
    
      <category term="基础" scheme="http://ruanshubin.top/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Git" scheme="http://ruanshubin.top/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Springboot自定义Starter</title>
    <link href="http://ruanshubin.top/2019/10/31/Springboot%E8%87%AA%E5%AE%9A%E4%B9%89Starter/"/>
    <id>http://ruanshubin.top/2019/10/31/Springboot自定义Starter/</id>
    <published>2019-10-31T13:30:00.000Z</published>
    <updated>2019-12-25T03:08:24.097Z</updated>
    
    <content type="html"><![CDATA[<p>在springboot中，使用的最多的就是starter。starter可以理解为一个可拔插式的插件，例如，你想使用jdbc插件，那么可以使用spring-boot-starter-jdbc；如果想使用mongodb，可以使用spring-boot-starter-data-mongodb。 </p><p>下面介绍如何自定义Starter。</p><h2 id="自定义Starter"><a href="#自定义Starter" class="headerlink" title="自定义Starter"></a>自定义Starter</h2><h3 id="创建maven工程"><a href="#创建maven工程" class="headerlink" title="创建maven工程"></a>创建maven工程</h3><ul><li>命名规范</li></ul><p>注意artifactId的命名规则，Spring官方Starter通常命名为spring-boot-starter-{name}如 spring-boot-starter-web， Spring官方建议非官方Starter命名应遵循{name}-spring-boot-starter的格式, 如mybatis-spring-boot-starter。这里创建的项目的artifactId为helloworld-spring-boot-starter。</p><ul><li>引入必要依赖</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;</span><br><span class="line">&lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><h3 id="XxxProperties"><a href="#XxxProperties" class="headerlink" title="XxxProperties"></a>XxxProperties</h3><p>在使用Spring官方的Starter时通常可以在application.properties中来配置参数覆盖掉默认的值，例如在使用redis时一般就会有对应的RedisProperties</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@ConfigurationProperties(prefix = &quot;spring.redis&quot;)</span><br><span class="line">public class RedisProperties &#123;</span><br><span class="line">    private int database = 0;</span><br><span class="line">    private String url;</span><br><span class="line">    private String host = &quot;localhost&quot;;</span><br><span class="line">    private String password;</span><br><span class="line">    private int port = 6379;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来模仿来定义自己的Properties类:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@ConfigurationProperties(prefix = &quot;spring.person&quot;)</span><br><span class="line">public class PersonProperties &#123;</span><br><span class="line">    // 姓名</span><br><span class="line">    private String name;</span><br><span class="line">    // 年龄</span><br><span class="line">    private int age;</span><br><span class="line">    // 性别</span><br><span class="line">    private String sex = &quot;M&quot;;</span><br><span class="line"></span><br><span class="line">    // Getter &amp; Setter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="核心服务类"><a href="#核心服务类" class="headerlink" title="核心服务类"></a>核心服务类</h3><p>每个starter都有自己的功能，例如在spring-boot-starter-jdbc中最重要的类时JdbcTemplate，每个starter中的核心业务类明白都不同，也没什么规律（像spring-boot-starter-data-xxx的命名是比较有规律的），这里使用PersonService来定义helloworld-spring-boot-starter的功能，这里通过一个sayHello来模拟一个功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class PersonService &#123;</span><br><span class="line">    private PersonProperties properties;</span><br><span class="line"></span><br><span class="line">    public PersonService() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public PersonService(PersonProperties properties) &#123;</span><br><span class="line">        this.properties = properties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void sayHello()&#123;</span><br><span class="line">        System.out.println(&quot;大家好，我叫：&quot; + properties.getName() + &quot;,今年&quot; + properties.getAge() + &quot;岁&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自动配置类"><a href="#自动配置类" class="headerlink" title="自动配置类"></a>自动配置类</h3><p>一般每个starter都至少会有一个自动配置类，一般命名规则使用XxxAutoConfiguration, 例如RedisAutoConfiguration</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ConditionalOnClass(&#123; JedisConnection.class, RedisOperations.class, Jedis.class &#125;)</span><br><span class="line">@EnableConfigurationProperties(RedisProperties.class)</span><br><span class="line">public class RedisAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    @Configuration</span><br><span class="line">    @ConditionalOnClass(GenericObjectPool.class)</span><br><span class="line">    protected static class RedisConnectionConfiguration &#123;</span><br><span class="line">        private final RedisProperties properties;</span><br><span class="line"></span><br><span class="line">        @Bean</span><br><span class="line">        @ConditionalOnMissingBean(RedisConnectionFactory.class)</span><br><span class="line">        public JedisConnectionFactory redisConnectionFactory()</span><br><span class="line">                throws UnknownHostException &#123;</span><br><span class="line">            return applyProperties(createJedisConnectionFactory());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;       </span><br><span class="line"></span><br><span class="line">    @Configuration</span><br><span class="line">    protected static class RedisConfiguration &#123;</span><br><span class="line">        @Bean</span><br><span class="line">        @ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)</span><br><span class="line">        public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory)</span><br><span class="line">                        throws UnknownHostException &#123;</span><br><span class="line">            RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;Object, Object&gt;();</span><br><span class="line">            template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">            return template;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们定义自己的自动配置PersonServiceAutoConfiguration，并将核心功能类PersonService放入到Spring Context容器中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableConfigurationProperties(PersonProperties.class)</span><br><span class="line">@ConditionalOnClass(PersonService.class)</span><br><span class="line">@ConditionalOnProperty(prefix = &quot;spring.person&quot;, value = &quot;enabled&quot;, matchIfMissing = true)</span><br><span class="line">public class PersonServiceAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private PersonProperties properties;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnMissingBean(PersonService.class)  // 当容器中没有指定Bean的情况下，自动配置PersonService类</span><br><span class="line">    public PersonService personService()&#123;</span><br><span class="line">        PersonService personService = new PersonService(properties);</span><br><span class="line">        return personService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>@ConditionalOnClass：当类路径classpath下有指定的类的情况下进行自动配置</li><li>@ConditionalOnMissingBean:当容器(Spring Context)中没有指定Bean的情况下进行自动配置</li><li>@ConditionalOnProperty(prefix = “example.service”, value = “enabled”, matchIfMissing = true)，当配置文件中example.service.enabled=true时进行自动配置，如果没有设置此值就默认使用matchIfMissing对应的值</li><li>@ConditionalOnMissingBean，当Spring Context中不存在该Bean时。</li><li>@ConditionalOnBean:当容器(Spring Context)中有指定的Bean的条件下</li><li>@ConditionalOnMissingClass:当类路径下没有指定的类的条件下</li><li>@ConditionalOnExpression:基于SpEL表达式作为判断条件</li><li>@ConditionalOnJava:基于JVM版本作为判断条件</li><li>@ConditionalOnJndi:在JNDI存在的条件下查找指定的位置</li><li>@ConditionalOnNotWebApplication:当前项目不是Web项目的条件下</li><li>@ConditionalOnWebApplication:当前项目是Web项目的条件下</li><li>@ConditionalOnResource:类路径下是否有指定的资源</li><li>@ConditionalOnSingleCandidate:当指定的Bean在容器中只有一个，或者在有多个Bean的情况下，用来指定首选的Bean</li></ul><h3 id="src-main-resources-META-INF-spring-factories"><a href="#src-main-resources-META-INF-spring-factories" class="headerlink" title="src/main/resources/META-INF/spring.factories"></a>src/main/resources/META-INF/spring.factories</h3><p>注意：META-INF是自己手动创建的目录，spring.factories也是手动创建的文件,在该文件中配置自己的自动配置类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.ruanshubin.config.PersonServiceAutoConfiguration</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul><li>打包mvn clean install</li><li>创建一个Spring Boot工程并引入依赖</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.ruanshubin.springboot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;helloworld-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><ul><li>配置application.properties</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.person.name=mengday</span><br><span class="line">spring.person.age=28</span><br></pre></td></tr></table></figure><ul><li>test</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class MystarterApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private PersonService personService;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testHelloWorld() &#123;</span><br><span class="line">        personService.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从使用者的角度来看，自己并没有将PersonService放入到Spring容器中，就直接来使用了，进行注入进来了。</p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>总结下Starter的工作原理：</p><ul><li>Spring Boot在启动时扫描项目所依赖的JAR包，寻找包含spring.factories文件的JAR包，</li><li>然后读取spring.factories文件获取配置的自动配置类AutoConfiguration，</li><li>然后将自动配置类下满足条件(@ConditionalOnXxx)的@Bean放入到Spring容器中(Spring Context)</li><li>这样使用者就可以直接用来注入，因为该类已经在容器中了</li></ul><p>@ConfigurationProperties: 注解主要用来把properties配置文件转化为对应的XxxProperties来使用的,并不会把该类放入到IOC容器中，如果想放入到容器中可以在XxxProperties上使用@Component来标注，也可以使用@EnableConfigurationProperties(XxxProperties.class)统一配置到Application上来，这种方式可以在Application上来统一开启指定的属性，这样也没必要在每个XxxProperties上使用@Component</p><p>@EnableConfigurationProperties(XxxProperties.class) 注解的作用是@ConfigurationProperties注解生效。如果只配置@ConfigurationProperties注解，在IOC容器中是获取不到properties配置文件转化的bean的</p><p>如果在每个Properties上都使用@Component来标注，那么在XxxApplication上也不需要使用@EnableConfigurationProperties({XxxProperties.class})来标注了，同样也可以在spring上下文容器中也能获取到XxxProperties对应的bean</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在springboot中，使用的最多的就是starter。starter可以理解为一个可拔插式的插件，例如，你想使用jdbc插件，那么可以使用spring-boot-starter-jdbc；如果想使用mongodb，可以使用spring-boot-starter-data
      
    
    </summary>
    
      <category term="Springboot" scheme="http://ruanshubin.top/categories/Springboot/"/>
    
    
      <category term="Java" scheme="http://ruanshubin.top/tags/Java/"/>
    
      <category term="Springboot" scheme="http://ruanshubin.top/tags/Springboot/"/>
    
  </entry>
  
  <entry>
    <title>ELK系统研究</title>
    <link href="http://ruanshubin.top/2019/10/30/ELK%E7%B3%BB%E7%BB%9F%E7%A0%94%E7%A9%B6/"/>
    <id>http://ruanshubin.top/2019/10/30/ELK系统研究/</id>
    <published>2019-10-30T13:30:00.000Z</published>
    <updated>2019-12-25T03:05:34.856Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><h3 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h3><ul><li>业务发展越来越庞大，服务器越来越多;</li><li>各种访问日志、应用日志、错误日志量越来越多，导致运维人员无法很好的去管理日志;</li><li>开发人员排查问题，需要到服务器上查日志，不方便;</li><li>运营人员需要一些数据，需要我们运维到服务器上分析日志。</li></ul><h3 id="为什么要用到ELK"><a href="#为什么要用到ELK" class="headerlink" title="为什么要用到ELK"></a>为什么要用到ELK</h3><p>一般我们需要进行日志分析场景：直接在日志文件中grep、awk 就可以获得自己想要的信息。但在规模较大也就是日志量多而复杂的场景中，此方法效率低下，面临问题包括日志量太大如何归档、文本搜索太慢怎么办、如何多维度查询。需要集中化的日志管理，所有服务器上的日志收集汇总。常见解决思路是建立集中式日志收集系统，将所有节点上的日志统一收集，管理，访问。</p><p>大型系统通常都是一个分布式部署的架构，不同的服务模块部署在不同的服务器上，问题出现时，大部分情况需要根据问题暴露的关键信息，定位到具体的服务器和服务模块，构建一套集中式日志系统，可以提高定位问题的效率。</p><p>一个完整的集中式日志系统，需要包含以下几个主要特点：</p><ul><li>收集－能够采集多种来源的日志数据;</li><li>传输－能够稳定的把日志数据传输到中央系统;</li><li>存储－如何存储日志数据;</li><li>分析－可以支持UI分析;</li><li>警告－能够提供错误报告，监控机制。</li></ul><p>而ELK则提供了一整套解决方案，并且都是开源软件，之间互相配合使用，完美衔接，高效的满足了很多场合的应用。是目前主流的一种日志系统。</p><h3 id="ELK简介"><a href="#ELK简介" class="headerlink" title="ELK简介"></a>ELK简介</h3><p>ELK是三个开源软件的缩写，分别为：Elasticsearch 、 Logstash以及Kibana , 它们都是开源软件。不过现在还新增了一个Beats，它是一个轻量级的日志收集处理工具(Agent)，Beats占用资源少，适合于在各个服务器上搜集日志后传输给Logstash，官方也推荐此工具，目前由于原本的ELK Stack成员中加入了Beats工具所以已改名为Elastic Stack。</p><p>Elastic Stack包含：</p><ul><li><p>Elasticsearch是个开源分布式搜索引擎，提供搜集、分析、存储数据三大功能。它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，restful风格接口，多数据源，自动搜索负载等。详细可参考Elasticsearch权威指南;</p></li><li><p>Logstash主要是用来日志的搜集、分析、过滤日志的工具，支持大量的数据获取方式。一般工作方式为c/s架构，client端安装在需要收集日志的主机上，server端负责将收到的各节点日志进行过滤、修改等操作在一并发往elasticsearch上去;</p></li><li><p>Kibana也是一个开源和免费的工具，Kibana可以为Logstash和ElasticSearch 提供的日志分析友好的Web界面，可以帮助汇总、分析和搜索重要数据日志;</p></li><li><p>Beats在这里是一个轻量级日志采集器，其实Beats家族有6个成员，早期的ELK架构中使用Logstash收集、解析日志，但是Logstash对内存、cpu、io等资源消耗比较高。相比Logstash，Beats所占系统的CPU和内存几乎可以忽略不计。</p></li></ul><p>ELK Stack （5.0版本之后）—&gt; Elastic Stack == （ELK Stack + Beats）。目前Beats包含六种工具：</p><ul><li>Packetbeat： 网络数据（收集网络流量数据）;</li><li>Metricbeat： 指标 （收集系统、进程和文件系统级别的 CPU 和内存使用情况等数据）;</li><li>Filebeat： 日志文件（收集文件数据）;</li><li>Winlogbeat： windows事件日志（收集 Windows 事件日志数据）;</li><li>Auditbeat：审计数据 （收集审计日志）;</li><li>Heartbeat：运行时间监控 （收集系统运行时的数据）。</li></ul><h3 id="ELK部署"><a href="#ELK部署" class="headerlink" title="ELK部署"></a>ELK部署</h3><p>下载：<a href="https://www.elastic.co/cn/downloads/" target="_blank" rel="noopener">https://www.elastic.co/cn/downloads/</a></p><p><img src="/2019/10/30/ELK系统研究/1.jpg" alt=""></p><h4 id="Elasticsearch安装"><a href="#Elasticsearch安装" class="headerlink" title="Elasticsearch安装"></a>Elasticsearch安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"># 解压es的安装包</span><br><span class="line">[root@sumo elasticsearch-6.6.2]# tar -zvxf elasticsearch-6.6.2-linux-x86_64.tar.gz </span><br><span class="line"></span><br><span class="line">[root@sumo elasticsearch-6.6.2]# cd elasticsearch-6.6.2/</span><br><span class="line">[root@sumo elasticsearch-6.6.2]# cd config/</span><br><span class="line">[root@sumo config]# vim elasticsearch.yml</span><br><span class="line"></span><br><span class="line"># ======================== Elasticsearch Configuration =========================</span><br><span class="line">#</span><br><span class="line"># NOTE: Elasticsearch comes with reasonable defaults for most settings.</span><br><span class="line">#       Before you set out to tweak and tune the configuration, make sure you</span><br><span class="line">#       understand what are you trying to accomplish and the consequences.</span><br><span class="line">#</span><br><span class="line"># The primary way of configuring a node is via this file. This template lists</span><br><span class="line"># the most important settings you may want to configure for a production cluster.</span><br><span class="line">#</span><br><span class="line"># Please consult the documentation for further information on configuration options:</span><br><span class="line"># https://www.elastic.co/guide/en/elasticsearch/reference/index.html</span><br><span class="line">#</span><br><span class="line"># ---------------------------------- Cluster -----------------------------------</span><br><span class="line">#</span><br><span class="line"># Use a descriptive name for your cluster:</span><br><span class="line">#</span><br><span class="line">cluster.name: ELK</span><br><span class="line">#</span><br><span class="line"># ------------------------------------ Node ------------------------------------</span><br><span class="line">#</span><br><span class="line"># Use a descriptive name for the node:</span><br><span class="line">#</span><br><span class="line">node.name: node-1</span><br><span class="line">#</span><br><span class="line"># Add custom attributes to the node:</span><br><span class="line">#</span><br><span class="line">#node.attr.rack: r1</span><br><span class="line">#</span><br><span class="line"># ----------------------------------- Paths ------------------------------------</span><br><span class="line">#</span><br><span class="line"># Path to directory where to store the data (separate multiple locations by comma):</span><br><span class="line">#</span><br><span class="line">#path.data: /path/to/data</span><br><span class="line">#</span><br><span class="line"># Path to log files:</span><br><span class="line">#</span><br><span class="line">#path.logs: /path/to/logs</span><br><span class="line">#</span><br><span class="line"># ----------------------------------- Memory -----------------------------------</span><br><span class="line">#</span><br><span class="line"># Lock the memory on startup:</span><br><span class="line">#</span><br><span class="line">#bootstrap.memory_lock: true</span><br><span class="line">#</span><br><span class="line"># Make sure that the heap size is set to about half the memory available</span><br><span class="line"># on the system and that the owner of the process is allowed to use this</span><br><span class="line"># limit.</span><br><span class="line">#</span><br><span class="line"># Elasticsearch performs poorly when the system is swapping the memory.</span><br><span class="line">#</span><br><span class="line"># ---------------------------------- Network -----------------------------------</span><br><span class="line">#</span><br><span class="line"># Set the bind address to a specific IP (IPv4 or IPv6):</span><br><span class="line">#</span><br><span class="line">network.host: 10.194.224.83</span><br><span class="line">#</span><br><span class="line"># Set a custom port for HTTP:</span><br><span class="line">#</span><br><span class="line">http.port: 9200</span><br><span class="line">#</span><br><span class="line"># For more information, consult the network module documentation.</span><br><span class="line">#</span><br><span class="line"># --------------------------------- Discovery ----------------------------------</span><br><span class="line">#</span><br><span class="line"># Pass an initial list of hosts to perform discovery when this node is started:</span><br><span class="line"># The default list of hosts is [&quot;127.0.0.1&quot;, &quot;[::1]&quot;]</span><br><span class="line">#</span><br><span class="line">#discovery.seed_hosts: [&quot;host1&quot;, &quot;host2&quot;]</span><br><span class="line">#</span><br><span class="line"># Bootstrap the cluster using an initial set of master-eligible nodes:</span><br><span class="line">#</span><br><span class="line">#cluster.initial_master_nodes: [&quot;node-1&quot;, &quot;node-2&quot;]</span><br><span class="line">cluster.initial_master_nodes: [&quot;node-1&quot;]</span><br><span class="line">#</span><br><span class="line"># For more information, consult the discovery and cluster formation module documentation.</span><br><span class="line">#</span><br><span class="line"># ---------------------------------- Gateway -----------------------------------</span><br><span class="line">#</span><br><span class="line"># Block initial recovery after a full cluster restart until N nodes are started:</span><br><span class="line">#</span><br><span class="line">#gateway.recover_after_nodes: 3</span><br><span class="line">#</span><br><span class="line"># For more information, consult the gateway module documentation.</span><br><span class="line">#</span><br><span class="line"># ---------------------------------- Various -----------------------------------</span><br><span class="line">#</span><br><span class="line"># Require explicit names when deleting indices:</span><br><span class="line">#</span><br><span class="line">#action.destructive_requires_name: true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 创建es账户</span><br><span class="line">[root@sumo config]# groupadd elsearch</span><br><span class="line">[root@sumo config]# useradd elsearch -g elsearch -p elsearch</span><br><span class="line">[root@sumo config]# chown -R elsearch:elsearch  es根目录</span><br><span class="line"></span><br><span class="line"># 切换到elsearch用户</span><br><span class="line">[root@sumo config]# su elsearch</span><br><span class="line">[elsearch@sumo config]$ </span><br><span class="line"></span><br><span class="line"># 启动es</span><br><span class="line">[elsearch@sumo config]$ /usr/software/es/elasticsearch-6.6.2/bin/elasticsearch -d</span><br><span class="line"></span><br><span class="line"># 加了-d是后台启动，不加是前台启动，第一次不建议后台启动，前台启动可以直观的看到日志信息</span><br></pre></td></tr></table></figure><p>前台启动后，报以下3个错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[1]: max file descriptors [4096] for elasticsearch process is too low, increase to at least [65535]</span><br><span class="line">[2]: max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]</span><br><span class="line">[3]: the default discovery settings are unsuitable for production use; at least one of [discovery.seed_hosts, discovery.seed_providers, cluster.initial_master_nodes] must be configured</span><br></pre></td></tr></table></figure><ul><li>Elasticsearch：max file descriptors [4096] for elasticsearch process is too low, increase to at least [65536]</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@sumo config]# vim /etc/security/limits.conf </span><br><span class="line">增加以下配置：</span><br><span class="line">*               soft    nofile          65536</span><br><span class="line">*               hard    nofile          65536</span><br><span class="line">重新连接服务器，查看配置是否生效：</span><br><span class="line">ulimit -Su</span><br><span class="line">ulimit -Hu</span><br></pre></td></tr></table></figure><ul><li>Elasticsearch：max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]</li></ul><p>elasticsearch用户拥有的内存权限太小，至少需要262144；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@sumo ~]# vim /etc/sysctl.conf</span><br><span class="line"># 添加以下配置：</span><br><span class="line">vm.max_map_count=262144</span><br><span class="line"></span><br><span class="line"># 使配置生效：</span><br><span class="line">[root@sumo ~]# sysctl -p</span><br><span class="line"></span><br><span class="line"># 查看</span><br><span class="line">[root@sumo ~]# sysctl -a|grep vm.max_map_count</span><br></pre></td></tr></table></figure><ul><li>[1]: the default discovery settings are unsuitable for production use; at least one of [discovery.seed_hosts, discovery.seed_providers, cluster.initial_master_nodes] must be configured</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[elsearch@sumo config]$ vim /usr/software/es/elasticsearch-6.6.2/config/elasticsearch.yml </span><br><span class="line"></span><br><span class="line">将 #cluster.initial_master_nodes: [&quot;node-1&quot;, &quot;node-2&quot;] 修改为 cluster.initial_master_nodes: [&quot;node-1&quot;]</span><br></pre></td></tr></table></figure><p>浏览器访问: <a href="http://xxx.xxx.xxx.xxx:9200/" target="_blank" rel="noopener">http://xxx.xxx.xxx.xxx:9200/</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot; : &quot;node-1&quot;,</span><br><span class="line">  &quot;cluster_name&quot; : &quot;ELK&quot;,</span><br><span class="line">  &quot;cluster_uuid&quot; : &quot;1l1qU4KPRqaafaPTrZAy-w&quot;,</span><br><span class="line">  &quot;version&quot; : &#123;</span><br><span class="line">    &quot;number&quot; : &quot;6.6.2&quot;,</span><br><span class="line">    &quot;build_flavor&quot; : &quot;default&quot;,</span><br><span class="line">    &quot;build_type&quot; : &quot;tar&quot;,</span><br><span class="line">    &quot;build_hash&quot; : &quot;e4efcb5&quot;,</span><br><span class="line">    &quot;build_date&quot; : &quot;2019-04-29T12:56:03.145736Z&quot;,</span><br><span class="line">    &quot;build_snapshot&quot; : false,</span><br><span class="line">    &quot;lucene_version&quot; : &quot;8.0.0&quot;,</span><br><span class="line">    &quot;minimum_wire_compatibility_version&quot; : &quot;6.7.0&quot;,</span><br><span class="line">    &quot;minimum_index_compatibility_version&quot; : &quot;6.0.0-beta1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;tagline&quot; : &quot;You Know, for Search&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他可能的报错及解决方案:</p><ul><li>Elasticsearch：Failed to obtain node lock</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 节点被已有的es进程占用，需要杀掉重启</span><br><span class="line">ps aux | grep &apos;java&apos;</span><br><span class="line">kill -9 &lt;属于es的PID&gt;</span><br></pre></td></tr></table></figure><ul><li>elk的3个组件均不能通过ip:port的形式访问</li></ul><p>将各自组件的yml配置文件中的host修改为0.0.0.0。</p><h4 id="Cerebro安装"><a href="#Cerebro安装" class="headerlink" title="Cerebro安装"></a>Cerebro安装</h4><p>Cerebro是一款Elasticsearch监控工具。</p><p><a href="https://github.com/lmenezes/cerebro" target="_blank" rel="noopener">https://github.com/lmenezes/cerebro</a></p><p><img src="/2019/10/30/ELK系统研究/2.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@sumo cerebro]# tar -zvxf cerebro-0.8.3.tgz </span><br><span class="line">[root@sumo cerebro]# cd /usr/software/cerebro/cerebro-0.8.3/conf/</span><br><span class="line">[root@sumo conf]# vim application.conf </span><br><span class="line"></span><br><span class="line">hosts = [</span><br><span class="line">  #&#123;</span><br><span class="line">  #  host = &quot;http://localhost:9200&quot;</span><br><span class="line">  #  name = &quot;Some Cluster&quot;</span><br><span class="line">  #&#125;,</span><br><span class="line">  # Example of host with authentication</span><br><span class="line">  #&#123;</span><br><span class="line">  #  host = &quot;http://some-authenticated-host:9200&quot;</span><br><span class="line">  #  name = &quot;Secured Cluster&quot;</span><br><span class="line">  #  auth = &#123;</span><br><span class="line">  #    username = &quot;username&quot;</span><br><span class="line">  #    password = &quot;secret-password&quot;</span><br><span class="line">  #  &#125;</span><br><span class="line">  #&#125;</span><br><span class="line">  &#123;</span><br><span class="line">    host = &quot;http://xxx.xxx.xxx.xxx:9200&quot;</span><br><span class="line">    name = &quot;elk&quot;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>启动Cerebro:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@sumo bin]# nohup ./cerebro -Dhttp.port=1234 -Dhttp.address=10.194.224.112 &gt; /dev/null &amp;</span><br></pre></td></tr></table></figure><p><img src="/2019/10/30/ELK系统研究/3.jpg" alt=""></p><p><img src="/2019/10/30/ELK系统研究/4.jpg" alt=""></p><h4 id="Kibana安装"><a href="#Kibana安装" class="headerlink" title="Kibana安装"></a>Kibana安装</h4><p><img src="/2019/10/30/ELK系统研究/5.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@sumo kibana]# tar -zvxf kibana-6.6.2-linux-x86_64.tar.gz </span><br><span class="line">[root@sumo kibana]# cd kibana-6.6.2-linux-x86_64/config/</span><br><span class="line">[root@sumo config]# vim kibana.yml </span><br><span class="line"></span><br><span class="line">server.port: 5602</span><br><span class="line">server.host: &quot;0.0.0.0&quot;</span><br><span class="line">elasticsearch.hosts: [&quot;http://10.194.224.83:9200&quot;]</span><br><span class="line"></span><br><span class="line">[root@sumo config]# nohup ../kibana &gt; /dev/null &amp;</span><br><span class="line"></span><br><span class="line"># 如何关闭kibana</span><br><span class="line"># 查询kibana的PID</span><br><span class="line">ps -ef | grep node </span><br><span class="line">netstat -tunlp|grep 5602</span><br><span class="line"></span><br><span class="line">root        777      1  0  2018 ?        00:00:00 /usr/sbin/mcelog --ignorenodev --daemon --syslog</span><br><span class="line">root      11323      1  1 May21 ?        00:17:06 ./../node/bin/node --no-warnings --max-http-header-size=65536 ./../src/cli</span><br><span class="line">root      76232  63850  0 11:48 pts/1    00:00:00 grep --color=auto node</span><br><span class="line"></span><br><span class="line">kill -9 11323</span><br></pre></td></tr></table></figure><h4 id="Logstash安装"><a href="#Logstash安装" class="headerlink" title="Logstash安装"></a>Logstash安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[root@sumo logstash]# tar -zvxf logstash-6.6.2.tar.gz </span><br><span class="line">[root@sumo logstash]# cd /usr/software/logstash/logstash-6.6.2/config</span><br><span class="line">[root@sumo config]# vim std_to_es.conf </span><br><span class="line"></span><br><span class="line"># 安装logstash-codec-json_lines插件</span><br><span class="line"></span><br><span class="line">[root@sumo config]# ../bin/logstash-plugin install logstash-codec-json_lines</span><br><span class="line"></span><br><span class="line">input &#123;</span><br><span class="line">    tcp &#123;</span><br><span class="line">        host =&gt; &quot;xxx.xxx.xxx.xxx&quot;</span><br><span class="line">        port =&gt; 4560</span><br><span class="line">        mode =&gt; &quot;server&quot;</span><br><span class="line">        tags =&gt; [&quot;tags&quot;]</span><br><span class="line">        codec =&gt; json_lines</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output&#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">     action =&gt; &quot;index&quot;</span><br><span class="line">     hosts =&gt; [&quot;xxx.xxx.xxx.xxx:9200&quot;]</span><br><span class="line">     index =&gt; &quot;%&#123;[appname]&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line">  stdout &#123; codec =&gt; rubydebug &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 启动</span><br><span class="line">[root@sumo config]# nohup ../bin/logstash -f ./std_to_es.conf &gt; /dev/null &amp;</span><br></pre></td></tr></table></figure><h4 id="filebeat使用"><a href="#filebeat使用" class="headerlink" title="filebeat使用"></a>filebeat使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@sumo filebeat-6.6.2-linux-x86_64]# vim filebeat.yml</span><br><span class="line"></span><br><span class="line">filebeat.inputs:</span><br><span class="line">- type: log</span><br><span class="line">  paths:</span><br><span class="line">    - /usr/software/data/filebeat-dataset.log</span><br><span class="line">setup.template.name: &quot;tcd&quot;</span><br><span class="line">setup.template.pattern: &quot;tcd-*&quot;</span><br><span class="line">output.elasticsearch:</span><br><span class="line">  hosts: [&quot;xxx.xxx.xxx.xxx:9200&quot;]</span><br><span class="line">  index: &quot;tcd-%&#123;+yyyy.MM.dd&#125;&quot;</span><br><span class="line"></span><br><span class="line">[root@sumo filebeat-6.6.2-linux-x86_64]# ./filebeat -e -c filebeat.yml -d &quot;publish&quot;</span><br></pre></td></tr></table></figure><ul><li>filebeat监控多个文件,并且写入elasticsearch的不同index的中</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">filebeat.inputs:</span><br><span class="line">- type: log</span><br><span class="line">  paths:</span><br><span class="line">    - /usr/software/data/tcd-as.log</span><br><span class="line">  fields:</span><br><span class="line">    index: &apos;tcd-as&apos;</span><br><span class="line">- type: log</span><br><span class="line">  paths:</span><br><span class="line">    - /usr/software/data/tcd-dm.log</span><br><span class="line">  fields:</span><br><span class="line">    index: &apos;tcd-dm&apos;</span><br><span class="line">output.elasticsearch:</span><br><span class="line">  hosts: [&quot;xxx.xxx.xxx.xxx:9200&quot;]</span><br><span class="line">  indices:</span><br><span class="line">    - index: &quot;tcd-as&quot;</span><br><span class="line">      when:</span><br><span class="line">        contains:</span><br><span class="line">          fields.index: &quot;tcd-as&quot;</span><br><span class="line">    - index: &quot;tcd-dm&quot;</span><br><span class="line">      when:</span><br><span class="line">        contains:</span><br><span class="line">          fields.index: &quot;tcd-dm&quot;</span><br></pre></td></tr></table></figure><p>logback.xml:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;appender name=&quot;LOGSTASH&quot; class=&quot;net.logstash.logback.appender.LogstashTcpSocketAppender&quot;&gt;</span><br><span class="line">        &lt;destination&gt;xxx.xxx.xxx.xxx:4560&lt;/destination&gt;</span><br><span class="line">        &lt;encoder charset=&quot;UTF-8&quot; class=&quot;net.logstash.logback.encoder.LogstashEncoder&quot;&gt;</span><br><span class="line">  &lt;!-- 注意：index的名称必须小写，且只允许下划线，中划线会导致消息进入不到es里面 --&gt;</span><br><span class="line">           &lt;customFields&gt;&#123;&quot;appname&quot;:&quot;applog&quot;&#125;&lt;/customFields&gt;</span><br><span class="line">        &lt;/encoder&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line"></span><br><span class="line">    &lt;include resource=&quot;org/springframework/boot/logging/logback/base.xml&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;root level=&quot;INFO&quot;&gt;</span><br><span class="line">        &lt;appender-ref ref=&quot;LOGSTASH&quot; /&gt;</span><br><span class="line">        &lt;appender-ref ref=&quot;CONSOLE&quot; /&gt;</span><br><span class="line">    &lt;/root&gt;</span><br><span class="line"></span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;h3 id=&quot;需求背景&quot;&gt;&lt;a href=&quot;#需求背景&quot; class=&quot;headerlink&quot; title=&quot;需求背景&quot;&gt;&lt;/a&gt;需求背景&lt;/h
      
    
    </summary>
    
      <category term="基础" scheme="http://ruanshubin.top/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="基础" scheme="http://ruanshubin.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="ELK" scheme="http://ruanshubin.top/tags/ELK/"/>
    
  </entry>
  
  <entry>
    <title>Linux服务器配置代理上网</title>
    <link href="http://ruanshubin.top/2019/10/29/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86%E4%B8%8A%E7%BD%91/"/>
    <id>http://ruanshubin.top/2019/10/29/Linux服务器配置代理上网/</id>
    <published>2019-10-29T13:30:00.000Z</published>
    <updated>2019-12-25T03:01:04.613Z</updated>
    
    <content type="html"><![CDATA[<ul><li>代理服务器选择了CCproxy，下载并安装CCProxy，配置所要代理的协议，并选择能够联外网的网卡ip；</li></ul><p><img src="/2019/10/29/Linux服务器配置代理上网/Linux服务器配置代理上网_files/1.jpg" alt=""></p><ul><li>账号管理根据个人需要进行配置，我这边选择的是允许所有（建议最好为虚拟机配置账号，方便以后调试和监控）。</li></ul><p><img src="/2019/10/29/Linux服务器配置代理上网/Linux服务器配置代理上网_files/2.jpg" alt=""></p><ul><li>在CentOS中配置全局代理</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line">export http_proxy=&quot;http://202.169.100.196:8089&quot;</span><br><span class="line">export https_proxy=&quot;http://202.169.100.196:8089&quot;</span><br><span class="line">export ftp_proxy=$http_proxy</span><br><span class="line"></span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><ul><li>配置yum代理</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/yum.conf</span><br><span class="line"></span><br><span class="line">proxy=http://202.169.100.196:8089</span><br></pre></td></tr></table></figure><ul><li>配置wget代理</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/wgetrc</span><br><span class="line"></span><br><span class="line">http_proxy = http://202.169.100.196:8089</span><br><span class="line">ftp_proxy = http://202.169.100.196:8089</span><br><span class="line">https_proxy = http://202.169.100.196:8089</span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -k https://www.baidu.com</span><br><span class="line">wget https://www.baidu.com</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;代理服务器选择了CCproxy，下载并安装CCProxy，配置所要代理的协议，并选择能够联外网的网卡ip；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/2019/10/29/Linux服务器配置代理上网/Linux服务器配置代理上网_files/1.jpg
      
    
    </summary>
    
      <category term="Linux" scheme="http://ruanshubin.top/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://ruanshubin.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Java的线程池</title>
    <link href="http://ruanshubin.top/2019/10/28/Java%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://ruanshubin.top/2019/10/28/Java的线程池/</id>
    <published>2019-10-28T13:30:00.000Z</published>
    <updated>2019-12-25T02:54:40.677Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建线程的方法"><a href="#创建线程的方法" class="headerlink" title="创建线程的方法"></a>创建线程的方法</h2><p>常见的创建线程的方法，主要有以下3种:</p><ul><li>继承Thread类;</li><li>实现Runnable接口;</li><li>实现Callable接口.</li></ul><p>需要有返回值时，可以使用Callable创建多线程，使用FutureTask的get()来取得该返回值。</p><p>上述3种方法创建的线程在运行结束后均会被虚拟机销毁，如果线程数量多的话，频繁的创建和销毁线程会大大浪费时间和效率，更重要的是浪费内存，因为正常来说，线程执行完毕后死亡，线程对象变成垃圾。</p><p>是否有1种方法能让线程运行完不立即销毁，而是让线程重复使用，继续执行其他的任务呢?</p><p>线程池可解决上述问题。</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="线程池参数"><a href="#线程池参数" class="headerlink" title="线程池参数"></a>线程池参数</h3><p>线程池的最上层接口是Executor。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Executor &#123;</span><br><span class="line">    void execute(Runnable command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>execute最后由ThreadPoolExecutor类实现，该方法用于传入任务，而ThreadPoolExecutor是线程池的核心类，此类的构造方法如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,</span><br><span class="line">            BlockingQueue&lt;Runnable&gt; workQueue);</span><br><span class="line"> </span><br><span class="line">public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,</span><br><span class="line">BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory);</span><br><span class="line"></span><br><span class="line">public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,</span><br><span class="line">BlockingQueue&lt;Runnable&gt; workQueue,RejectedExecutionHandler handler);</span><br><span class="line"></span><br><span class="line">public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,</span><br><span class="line">BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler);</span><br></pre></td></tr></table></figure><p>构造方法的参数及意义:</p><ul><li>corePoolSize</li></ul><p>核心线程池的大小，如果核心线程池有空闲位置，新的任务就会被核心线程池新建1个线程执行，执行完毕后不会销毁线程，线程会进入缓存队列等待再次被运行；</p><ul><li>maximumPoolSize</li></ul><p>线程池能创建最大的线程数量，如果核心线程池和缓存队列都已经满了，新的任务进来就会创建新的线程来执行，但是数量不能超过maximumPoolSize，否则会采取拒绝接受任务策略；</p><ul><li>keepAliveTime</li></ul><p>非核心线程能够空闲的最长时间，超过时间，线程终止。该参数默认在线程数量超过核心线程池大小时才会起作用；</p><ul><li>unit</li></ul><p>时间单位，和keepAliveTime配合使用；</p><ul><li>workQueue</li></ul><p>缓存队列，用于存放等待被执行的任务；</p><ul><li>threadFactory</li></ul><p>线程工厂，用于创建线程，一般有3种选择策略；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayBlockingQueue;</span><br><span class="line">LinkedBlockingQueue;</span><br><span class="line">SynchronousQueue;</span><br></pre></td></tr></table></figure><ul><li>handler</li></ul><p>拒绝处理策略，线程数量大于最大线程数就会采用拒绝处理策略，四种策略为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 </span><br><span class="line">ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 </span><br><span class="line">ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</span><br><span class="line">ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</span><br></pre></td></tr></table></figure><p>Executor接口有一个子接口ExecutorService，ExecutorService的实现类为AbstracExecutorService，而ThreadPoolExcutor正是AbstrcExecutorService的子类。</p><p>ThreadPoolExecutor还有两个常用的方法shutdown()和shutdownNow()，两者都用来关闭线程池，但是后者有一个结果返回。</p><h3 id="线程池实现原理"><a href="#线程池实现原理" class="headerlink" title="线程池实现原理"></a>线程池实现原理</h3><ul><li>线程池图:</li></ul><p><img src="/2019/10/28/Java的线程池/1.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// 任务的后备队列</span><br><span class="line">private final BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line">// 锁</span><br><span class="line">private final ReentrantLock mainLock = new ReentrantLock();</span><br><span class="line">// 用来支持等待中断的</span><br><span class="line">private final Condition termination = mainLock.newCondition();</span><br><span class="line">// 存放的工作线程，只有当获取到锁的时候才能访问这个 Set</span><br><span class="line">private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;();</span><br><span class="line">// 线程池最大数量</span><br><span class="line">private int largestPoolSize;</span><br><span class="line">// 完成的线程数，只有在获取锁的时候才能更新这个值</span><br><span class="line">private long completedTaskCount;</span><br><span class="line"></span><br><span class="line">//==============================================================================</span><br><span class="line">// 这里有提到用户自定义的变量我们都是用 volatile 来修饰 以保证获取到最新的值</span><br><span class="line">//==============================================================================</span><br><span class="line">// 线程创建工厂类</span><br><span class="line">private volatile ThreadFactory threadFactory;</span><br><span class="line">// 当任务队列饱和或者线程池关闭后 再往里面提交任务时候的执行策略</span><br><span class="line">private volatile RejectedExecutionHandler handler;</span><br><span class="line">// 默认的执行策略是采用的 AbortPolicy (这是一个函数式接口的子类，里面实现的方法默认是抛异常)</span><br><span class="line">private static final RejectedExecutionHandler defaultHandler = new AbortPolicy();</span><br><span class="line">// 非核心线程的存活时间</span><br><span class="line">private volatile long keepAliveTime;</span><br><span class="line">// 是否允许核心线程具有存活时间，允许则上面的参数也会作用于核心线程</span><br><span class="line">private volatile boolean allowCoreThreadTimeOut;</span><br><span class="line">// 核心线程的大小</span><br><span class="line">private volatile int corePoolSize;</span><br><span class="line">// 最大线程数</span><br><span class="line">private volatile int maximumPoolSize;</span><br><span class="line">// 池控参数  非常重要！！！！</span><br><span class="line">private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));</span><br><span class="line">// ctl 的解包 -&gt; workerCount 和 runState</span><br><span class="line">private static int runStateOf(int c)     &#123; return c &amp; ~CAPACITY; &#125;</span><br><span class="line">private static int workerCountOf(int c)  &#123; return c &amp; CAPACITY; &#125;</span><br><span class="line">// 打包操作 两个变量或一下</span><br><span class="line">private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125;</span><br></pre></td></tr></table></figure><p>其中比较重要的属性有: workQueue(任务队列)、一个Set(线程集合)、池参数、线程工厂类、拒绝策略、池控参数。</p><p>其中池控参数是将两个变量都打包进去，分别是workerCount和runState。</p><p>workerCount为有效线程数，runState表明线程池的状态是否为运行。为了方便表示，我们把 workerCount和runState打包到了1个变量里面就是ctl。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">COUNT_BITS = 29</span><br><span class="line">CAPACITY = 0001 1111 1111 1111 </span><br><span class="line">           1111 1111 1111 1111</span><br><span class="line">RUNNING = 111 0 0000 0000 0000 </span><br><span class="line">          0000 0000 0000 0000</span><br><span class="line">SHUTDOWN = 000 0 0000 0000 0000</span><br><span class="line">           0000 0000 0000 0000</span><br><span class="line">STOP = 001 0 0000 0000 0000 </span><br><span class="line">       0000 0000 0000 0000</span><br><span class="line">TIDYING = 010 0 0000 0000 0000 </span><br><span class="line">          0000 0000 0000 0000</span><br><span class="line">TERMINATED = 011 0 0000 0000 0000 </span><br><span class="line">             0000 0000 0000 0000</span><br></pre></td></tr></table></figure><p>高3位作为状态值，低29位作为工作线程总数。</p><ul><li>线程池状态</li></ul><p>线程池和线程一样拥有自己的状态，在ThreadPoolExecutor类中定义了一个volatile变量runState来表示线程池的状态，线程池有以下状态:</p><ul><li>RUNNING：接受新任务并处理排队的任务</li><li>SHUTDOWN：不接受新任务，但处理排队的任务</li><li>STOP：不接受新任务，不处理排队的任务，并中断正在进行的任务</li><li>TIDYING：所有任务都已终止，workerCount为零，线程转换到状态TIDYING 将运行terminate() 勾子</li><li><p>TERMINATED：terminated()已完成<br>  <br>并且这些值之间顺序很重要，以允许有序的比较。 runState在整个过程中是单调递增的但不需要经过每一个状态，具体规律如下：</p></li><li><p>RUNNING -&gt; SHUTDOWN  在执行 shutdown()的时候</p></li><li>(RUNNING or SHUTDOWN) -&gt; STOP  在执行shutdownNow()</li><li>SHUTDOWN -&gt; TIDYING  当任务队列和线程池为空的时候</li><li>STOP -&gt; TIDYING  当池为空的时候</li><li>TIDYING -&gt; TERMINATED  钩子方法调用完毕</li></ul><h4 id="Excute方法"><a href="#Excute方法" class="headerlink" title="Excute方法"></a>Excute方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public void execute(Runnable command) &#123;</span><br><span class="line">if (command == null)</span><br><span class="line">throw new NullPointerException();</span><br><span class="line">int c = ctl.get();</span><br><span class="line">if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">// 如果工作线程少于corePoolSize，则尝试增加新核心线程处理command</span><br><span class="line">if (addWorker(command, true))</span><br><span class="line">// 新核心线程增加成功，则直接返回</span><br><span class="line">return;</span><br><span class="line">// 新核心线程增加不成功，重新获取池控参数</span><br><span class="line">c = ctl.get();</span><br><span class="line">&#125;</span><br><span class="line">// 如果线程池处于Running，则将当前command增加到任务队列</span><br><span class="line">if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">// 重新获取池化参数</span><br><span class="line">int recheck = ctl.get();</span><br><span class="line">// 如果线程池关闭了，我们需要做回退动作，也就是撤销刚才放入的任务</span><br><span class="line">// 如果撤销成功，执行拒绝策略</span><br><span class="line">if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">reject(command);</span><br><span class="line">// 如果撤销失败，并且没有工作线程不管他</span><br><span class="line">else if (workerCountOf(recheck) == 0)</span><br><span class="line">addWorker(null, false);</span><br><span class="line">&#125;</span><br><span class="line">// 若排队失败，增加非核心线程处理command</span><br><span class="line">// 若线程添加失败，则说明线程池关闭或者处于饱和状态</span><br><span class="line">else if (!addWorker(command, false))</span><br><span class="line">reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="addWorker"><a href="#addWorker" class="headerlink" title="addWorker"></a>addWorker</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">private boolean addWorker(Runnable firstTask, boolean core) &#123;</span><br><span class="line">retry:</span><br><span class="line">for (;;) &#123;</span><br><span class="line">int c = ctl.get();</span><br><span class="line">int rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">// Check if queue empty only if necessary.</span><br><span class="line">if (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">   firstTask == null &amp;&amp;</span><br><span class="line">   ! workQueue.isEmpty()))</span><br><span class="line">return false;</span><br><span class="line"></span><br><span class="line">for (;;) &#123;</span><br><span class="line">int wc = workerCountOf(c);</span><br><span class="line">// 如果工作线程数量大于CAPACITY</span><br><span class="line">// 或者工作线程数量大于最大值(若core为true，最大值为corePoolSize，否则为maximumPoolSize)</span><br><span class="line">if (wc &gt;= CAPACITY ||</span><br><span class="line">wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">return false;</span><br><span class="line">// 若工作线程数目增加成功，退出最外层自旋</span><br><span class="line">if (compareAndIncrementWorkerCount(c))</span><br><span class="line">break retry;</span><br><span class="line">// 重新读取池控参数，若状态发生变化，继续自旋</span><br><span class="line">c = ctl.get();  // Re-read ctl</span><br><span class="line">if (runStateOf(c) != rs)</span><br><span class="line">continue retry;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boolean workerStarted = false;</span><br><span class="line">boolean workerAdded = false;</span><br><span class="line">Worker w = null;</span><br><span class="line">try &#123;</span><br><span class="line">w = new Worker(firstTask);</span><br><span class="line">final Thread t = w.thread;</span><br><span class="line">if (t != null) &#123;</span><br><span class="line">final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">mainLock.lock();</span><br><span class="line">try &#123;</span><br><span class="line">int rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">if (rs &lt; SHUTDOWN ||</span><br><span class="line">(rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123;</span><br><span class="line">if (t.isAlive()) // precheck that t is startable</span><br><span class="line">throw new IllegalThreadStateException();</span><br><span class="line">workers.add(w);</span><br><span class="line">int s = workers.size();</span><br><span class="line">if (s &gt; largestPoolSize)</span><br><span class="line">largestPoolSize = s;</span><br><span class="line">workerAdded = true;</span><br><span class="line">&#125;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">mainLock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">if (workerAdded) &#123;</span><br><span class="line">t.start();</span><br><span class="line">workerStarted = true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">if (! workerStarted)</span><br><span class="line">addWorkerFailed(w);</span><br><span class="line">&#125;</span><br><span class="line">return workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public void shutdown() &#123;</span><br><span class="line">final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">mainLock.lock();</span><br><span class="line">try &#123;</span><br><span class="line">// 调用checkShutdownAccess方法检查每一个线程池的线程是否有可以ShutDown的权限</span><br><span class="line">checkShutdownAccess();</span><br><span class="line">// 调用advanceRunState函数通过自旋的CAS操作来将ctl中的状态变为SHUTDOWN</span><br><span class="line">advanceRunState(SHUTDOWN);</span><br><span class="line">// 调用interruptIdleWorkers方法，将所有Idle状态的线程都调用interrupt方法，中断线程。而判断idle状态使用Worker中的ReentrantLock来调用tryLock尝试加锁，看Worker线程是否已经获取了锁，如果Worker的锁已经被加了的话，那么tryLock返回的就是false</span><br><span class="line">interruptIdleWorkers();</span><br><span class="line">// 通过onShutDown()方法告知子类，线程池要处于ShutDown状态了</span><br><span class="line">onShutdown(); // hook for ScheduledThreadPoolExecutor</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">mainLock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">// 调用tryTermiante的方法尝试终止线程池</span><br><span class="line">tryTerminate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow"></a>shutdownNow</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Runnable&gt; shutdownNow() &#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        interruptWorkers();</span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">    return tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ShutDownNow方法和ShutDown方法差不多，这两个方法的区别有：</p><ul><li>shutDownNow方法会返回未完成的任务队列中的任务列表</li><li>advanceRunState方法中传入的是STOP，而不是SHUTDOWN。</li></ul><h4 id="interruptIdleWorkers"><a href="#interruptIdleWorkers" class="headerlink" title="interruptIdleWorkers"></a>interruptIdleWorkers</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private void interruptIdleWorkers(boolean onlyOne) &#123;</span><br><span class="line">final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">mainLock.lock();</span><br><span class="line">try &#123;</span><br><span class="line">for (Worker w : workers) &#123;</span><br><span class="line">Thread t = w.thread;</span><br><span class="line">// 如果线程未被中断，尝试获取worker的锁</span><br><span class="line">if (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">// 中断线程</span><br><span class="line">t.interrupt();</span><br><span class="line">&#125; catch (SecurityException ignore) &#123;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">w.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 如果onlyOne为True，则只中断1个空闲工作线程</span><br><span class="line">if (onlyOne)</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">mainLock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 默认中断所有空闲工作线程</span><br><span class="line">private void interruptIdleWorkers() &#123;</span><br><span class="line">interruptIdleWorkers(false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="tryTerminate"><a href="#tryTerminate" class="headerlink" title="tryTerminate"></a>tryTerminate</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">final void tryTerminate() &#123;</span><br><span class="line">for (;;) &#123;</span><br><span class="line">int c = ctl.get();</span><br><span class="line">// 判断当前线程池是否正在运行，或者当前线程池的状态比TIDYING（整理中）要大（也就是处于TIDYING或者TERMINATED状态），或者当前线程状态处于SHUTDOWN并且任务队列不为空的话，那么就直接return</span><br><span class="line">if (isRunning(c) ||</span><br><span class="line">runStateAtLeast(c, TIDYING) ||</span><br><span class="line">(runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">return;</span><br><span class="line">// 如果当前的WorkerCount不为0，那么就会调用interruptedIdleWorkers(true)，并且返回</span><br><span class="line">if (workerCountOf(c) != 0) &#123; // Eligible to terminate</span><br><span class="line">interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">mainLock.lock();</span><br><span class="line">// 通过CAS操作将ctl设置成TIDYING，如果设置成功之后就会调用terminated方法， 告知子类，要终止了，终止完之后，就会将ctl的状态设置成TERMINATED，以及workerCount为0</span><br><span class="line">try &#123;</span><br><span class="line">if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">terminated();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">ctl.set(ctlOf(TERMINATED, 0));</span><br><span class="line">termination.signalAll();</span><br><span class="line">&#125;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">mainLock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">// else retry on failed CAS</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="processWorkerExit"><a href="#processWorkerExit" class="headerlink" title="processWorkerExit"></a>processWorkerExit</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private void processWorkerExit(Worker w, boolean completedAbruptly) &#123;</span><br><span class="line">// 如果是意外退出的话，那么就需要把WorkerCount--</span><br><span class="line">    if (completedAbruptly) // If abrupt, then workerCount wasn&apos;t adjusted</span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">    final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">// 加完锁后，同步将completedTaskCount进行增加，表示总共完成的任务数，并且从WorkerSet中将对应的Worker移除</span><br><span class="line">    try &#123;</span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tryTerminate();</span><br><span class="line"></span><br><span class="line">    int c = ctl.get();</span><br><span class="line">// 判断当前的线程池状态，如果当前线程池状态比STOP大的话，就不处理</span><br><span class="line">    if (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">// 判断是否是意外退出，如果不是意外退出的话，那么就会判断最少要保留的核心线程数，如果allowCoreThreadTimeOut被设置为true的话，那么说明核心线程在设置的KeepAliveTime之后，也会被销毁</span><br><span class="line">        if (!completedAbruptly) &#123;</span><br><span class="line">            int min = allowCoreThreadTimeOut ? 0 : corePoolSize;</span><br><span class="line">// 如果最少保留的Worker数为0的话，那么就会判断当前的任务队列是否为空，如果任务队列不为空的话而且线程池没有停止，那么说明至少还需要1个线程继续将任务完成</span><br><span class="line">            if (min == 0 &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min = 1;</span><br><span class="line">// 判断当前的Worker是否大于min，也就是说当前的Worker总数大于最少需要的Worker数的话，那么就直接返回，因为剩下的Worker会继续从WorkQueue中获取任务执行</span><br><span class="line">            if (workerCountOf(c) &gt;= min)</span><br><span class="line">                return; // replacement not needed</span><br><span class="line">        &#125;</span><br><span class="line">// 如果当前运行的Worker数比当前所需要的Worker数少的话，那么就会调用addWorker，添加新的Worker，也就是新开启线程继续处理任务</span><br><span class="line">        addWorker(null, false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="getPoolSize"><a href="#getPoolSize" class="headerlink" title="getPoolSize"></a>getPoolSize</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public int getPoolSize() &#123;</span><br><span class="line">final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">mainLock.lock();</span><br><span class="line">try &#123;</span><br><span class="line">// 若线程池状态大于等于TIDYING，则线程池大小为0，否则为workers.size()</span><br><span class="line">return runStateAtLeast(ctl.get(), TIDYING) ? 0</span><br><span class="line">: workers.size();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">mainLock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="getActiveCount"><a href="#getActiveCount" class="headerlink" title="getActiveCount"></a>getActiveCount</h4><p>获取活跃线程总数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public int getActiveCount() &#123;</span><br><span class="line">final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">mainLock.lock();</span><br><span class="line">try &#123;</span><br><span class="line">int n = 0;</span><br><span class="line">for (Worker w : workers)</span><br><span class="line">// 若该线程被锁定，说明正在处理任务，属于活跃线程</span><br><span class="line">if (w.isLocked())</span><br><span class="line">++n;</span><br><span class="line">return n;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">mainLock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="getTaskCount"><a href="#getTaskCount" class="headerlink" title="getTaskCount"></a>getTaskCount</h4><p>获取任务总数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public long getTaskCount() &#123;</span><br><span class="line">final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">mainLock.lock();</span><br><span class="line">try &#123;</span><br><span class="line">long n = completedTaskCount;</span><br><span class="line">for (Worker w : workers) &#123;</span><br><span class="line">n += w.completedTasks;</span><br><span class="line">if (w.isLocked())</span><br><span class="line">++n;</span><br><span class="line">&#125;</span><br><span class="line">// 各线程已完成的任务之和+当前正在进行的任务+任务队列的大小作为任务总数</span><br><span class="line">return n + workQueue.size();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">mainLock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="getCompletedTaskCount"><a href="#getCompletedTaskCount" class="headerlink" title="getCompletedTaskCount"></a>getCompletedTaskCount</h4><p>获取完成的任务总数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public long getCompletedTaskCount() &#123;</span><br><span class="line">final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">mainLock.lock();</span><br><span class="line">try &#123;</span><br><span class="line">long n = completedTaskCount;</span><br><span class="line">// 遍历工作线程，叠加每个线程的completedTasks</span><br><span class="line">for (Worker w : workers)</span><br><span class="line">n += w.completedTasks;</span><br><span class="line">return n;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">mainLock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;创建线程的方法&quot;&gt;&lt;a href=&quot;#创建线程的方法&quot; class=&quot;headerlink&quot; title=&quot;创建线程的方法&quot;&gt;&lt;/a&gt;创建线程的方法&lt;/h2&gt;&lt;p&gt;常见的创建线程的方法，主要有以下3种:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;继承Thread类;&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="并发编程" scheme="http://ruanshubin.top/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://ruanshubin.top/tags/Java/"/>
    
      <category term="并发" scheme="http://ruanshubin.top/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>日志框架简述</title>
    <link href="http://ruanshubin.top/2019/10/28/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E7%AE%80%E8%BF%B0/"/>
    <id>http://ruanshubin.top/2019/10/28/日志框架简述/</id>
    <published>2019-10-28T13:30:00.000Z</published>
    <updated>2019-12-25T02:58:11.024Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java日志简述"><a href="#Java日志简述" class="headerlink" title="Java日志简述"></a>Java日志简述</h2><p>对于一个应用程序来说日志记录是必不可少的一部分。线上问题追踪，基于日志的业务逻辑统计分析等都离不日志。java领域存在多种日志框架，目前常用的日志框架包括Log4j 1，Log4j 2，Commons Logging，Slf4j，Logback，Jul。</p><ul><li><p>Log4j Apache Log4j是一个基于Java的日志记录工具。它是由Ceki Gülcü首创的，现在则是Apache软件基金会的一个项目。 Log4j是几种Java日志框架之一。</p></li><li><p>Log4j 2 Apache Log4j 2是apache开发的一款Log4j的升级产品。</p></li><li><p>Commons Logging Apache基金会所属的项目，是一套Java日志接口，之前叫Jakarta Commons Logging，后更名为Commons Logging。</p></li><li><p>Slf4j 类似于Commons Logging，是一套简易Java日志门面，本身并无日志的实现。（Simple Logging Facade for Java，缩写Slf4j）。</p></li><li><p>Logback 一套日志组件的实现(Slf4j阵营)。</p></li><li><p>Jul (Java Util Logging),自Java1.4以来的官方日志实现。</p></li></ul><h2 id="Java常用日志框架历史"><a href="#Java常用日志框架历史" class="headerlink" title="Java常用日志框架历史"></a>Java常用日志框架历史</h2><ul><li><p>1996年早期，欧洲安全电子市场项目组决定编写它自己的程序跟踪API(Tracing API)。经过不断的完善，这个API终于成为一个十分受欢迎的Java日志软件包，即Log4j。后来Log4j成为Apache基金会项目中的一员。</p></li><li><p>期间Log4j近乎成了Java社区的日志标准。据说Apache基金会还曾经建议Sun引入Log4j到java的标准库中，但Sun拒绝了。</p></li><li><p>2002年Java1.4发布，Sun推出了自己的日志库JUL(Java Util Logging),其实现基本模仿了Log4j的实现。在JUL出来以前，Log4j就已经成为一项成熟的技术，使得Log4j在选择上占据了一定的优势。</p></li><li><p>接着，Apache推出了Jakarta Commons Logging，JCL只是定义了一套日志接口(其内部也提供一个Simple Log的简单实现)，支持运行时动态加载日志组件的实现，也就是说，在你应用代码里，只需调用Commons Logging的接口，底层实现可以是Log4j，也可以是Java Util Logging。</p></li><li><p>后来(2006年)，Ceki Gülcü不适应Apache的工作方式，离开了Apache。然后先后创建了Slf4j(日志门面接口，类似于Commons Logging)和Logback(Slf4j的实现)两个项目，并回瑞典创建了QOS公司，QOS官网上是这样描述Logback的：The Generic，Reliable Fast&amp;Flexible Logging Framework(一个通用，可靠，快速且灵活的日志框架)。</p></li><li><p>现今，Java日志领域被划分为两大阵营：Commons Logging阵营和Slf4j阵营。</p></li><li><p>Commons Logging在Apache大树的笼罩下，有很大的用户基数。但有证据表明，形式正在发生变化。2013年底有人分析了GitHub上30000个项目，统计出了最流行的100个Libraries，可以看出Slf4j的发展趋势更好：</p></li></ul><p><img src="/2019/10/28/日志框架简述/1.jpg" alt=""></p><ul><li>Apache眼看有被Logback反超的势头，于2012-07重写了Log4j 1.x，成立了新的项目Log4j 2, Log4j 2具有Logback的所有特性。</li></ul><h2 id="Java常用日志框架之间的关系"><a href="#Java常用日志框架之间的关系" class="headerlink" title="Java常用日志框架之间的关系"></a>Java常用日志框架之间的关系</h2><ul><li><p>Log4j 2与Log4j 1发生了很大的变化，Log4j 2不兼容Log4j 1。</p></li><li><p>Commons Logging和Slf4j是日志门面(门面模式是软件工程中常用的一种软件设计模式，也被称为正面模式、外观模式。它为子系统中的一组接口提供一个统一的高层接口，使得子系统更容易使用)。Log4j和Logback则是具体的日志实现方案。可以简单的理解为接口与接口的实现，调用者只需要关注接口而无需关注具体的实现，做到解耦。</p></li><li><p>比较常用的组合使用方式是Slf4j与Logback组合使用，Commons Logging与Log4j组合使用。</p></li><li><p>Logback必须配合Slf4j使用。由于Logback和Slf4j是同一个作者，其兼容性不言而喻。</p></li></ul><h2 id="选择日志框架"><a href="#选择日志框架" class="headerlink" title="选择日志框架"></a>选择日志框架</h2><p>如果是在一个新的项目中建议使用Slf4j与Logback组合，这样有如下的几个优点。</p><ul><li><p>Slf4j实现机制决定Slf4j限制较少，使用范围更广。由于Slf4j在编译期间，静态绑定本地的LOG库使得通用性要比Commons Logging要好。</p></li><li><p>Logback拥有更好的性能。Logback声称：某些关键操作，比如判定是否记录一条日志语句的操作，其性能得到了显著的提高。这个操作在Logback中需要3纳秒，而在Log4J中则需要30纳秒。LogBack创建记录器（logger）的速度也更快：13毫秒，而在Log4J中需要23毫秒。更重要的是，它获取已存在的记录器只需94纳秒，而Log4J需要2234纳秒，时间减少到了1/23。跟JUL相比的性能提高也是显著的。</p></li><li><p>Commons Logging开销更高</p></li><li><p>Logback文档免费。Logback的所有文档是全面免费提供的，不象Log4J那样只提供部分免费文档而需要用户去购买付费文档。</p></li></ul><h2 id="SLF4J用法"><a href="#SLF4J用法" class="headerlink" title="SLF4J用法"></a>SLF4J用法</h2><h3 id="Slf4j与其它日志组件的关系说明"><a href="#Slf4j与其它日志组件的关系说明" class="headerlink" title="Slf4j与其它日志组件的关系说明"></a>Slf4j与其它日志组件的关系说明</h3><ul><li>Slf4j的设计思想比较简洁，使用了Facade设计模式，Slf4j本身只提供了一个slf4j-api-version.jar包，这个jar中主要是日志的抽象接口，jar中本身并没有对抽象出来的接口做实现。</li><li>对于不同的日志实现方案(例如Logback，Log4j…)，封装出不同的桥接组件(例如logback-classic-version.jar，slf4j-log4j12-version.jar)，这样使用过程中可以灵活的选取自己项目里的日志实现。</li></ul><h3 id="Slf4j与其它日志组件调用关系图"><a href="#Slf4j与其它日志组件调用关系图" class="headerlink" title="Slf4j与其它日志组件调用关系图"></a>Slf4j与其它日志组件调用关系图</h3><p><img src="/2019/10/28/日志框架简述/2.jpg" alt=""></p><h3 id="Slf4j与其他各种日志组件的桥接说明"><a href="#Slf4j与其他各种日志组件的桥接说明" class="headerlink" title="Slf4j与其他各种日志组件的桥接说明"></a>Slf4j与其他各种日志组件的桥接说明</h3><p><img src="/2019/10/28/日志框架简述/3.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Java日志简述&quot;&gt;&lt;a href=&quot;#Java日志简述&quot; class=&quot;headerlink&quot; title=&quot;Java日志简述&quot;&gt;&lt;/a&gt;Java日志简述&lt;/h2&gt;&lt;p&gt;对于一个应用程序来说日志记录是必不可少的一部分。线上问题追踪，基于日志的业务逻辑统计分析等都
      
    
    </summary>
    
      <category term="Java" scheme="http://ruanshubin.top/categories/Java/"/>
    
    
      <category term="Java" scheme="http://ruanshubin.top/tags/Java/"/>
    
      <category term="日志" scheme="http://ruanshubin.top/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Java的持久化</title>
    <link href="http://ruanshubin.top/2019/10/26/Java%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>http://ruanshubin.top/2019/10/26/Java的持久化/</id>
    <published>2019-10-26T13:30:00.000Z</published>
    <updated>2019-12-25T02:52:23.376Z</updated>
    
    <content type="html"><![CDATA[<h2 id="持久化方案发展过程"><a href="#持久化方案发展过程" class="headerlink" title="持久化方案发展过程"></a>持久化方案发展过程</h2><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>当断电或者系统故障宕机时，内存中Java创建的对象将荡然无存，解决该问题的初始方式为—序列化。</p><ul><li>序列化</li></ul><p>将内存中的对象转换为二进制文件存储到硬盘。</p><ul><li>反序列化</li></ul><p>将二进制文件加载为内存中的对象。</p><p>序列化的缺点是效率低，对象少的时候还可以，如果需要对大规模的对象进行存储、查询则就捉襟见肘了。</p><p>比如想选取age&gt;26的所有Person对象，则需要把所有序列化之后的Person对象都装入内存，然后逐个比对年龄，效率慢到爆炸。</p><p>解决上述问题的方式为—使用关系型数据库存储大规模数据。</p><h3 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h3><p>关系型数据库用类似二维表格的形式来存储数据。并提供中间层SQL来支持关系代数、关系演算等，屏蔽了具体的实现细节和各个数据库之间的差异。</p><p>为了将Java对象映射到数据库的二维表格上去，需要将对象的属性变成数据库的行/列，该种过程称之为Object-Relational Mapping，实现该种过程的一系列框架称之为ORM框架。</p><p>对象映射到数据库的表上之后，需要建立与数据库的连接，由于各种数据库的底层实现千差万别，所以Java仅提供接口，然后由各数据库厂商去各自实现该接口，该接口即为Java Database Connectivity，简称JDBC。</p><h3 id="EJB时代"><a href="#EJB时代" class="headerlink" title="EJB时代"></a>EJB时代</h3><p>JDBC是一个非常”低级”的接口。程序员需要处理太多的细节，冗余代码太多，写一个简单的查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、打开Connection</span><br><span class="line">2、创建Statement</span><br><span class="line">3、执行SQL</span><br><span class="line">4、遍历ResultSet</span><br><span class="line">5、关闭Connection</span><br></pre></td></tr></table></figure><p>在安全、事务、分布式、可伸缩性、高可用等高级功能场景下，操作系统及应用程序均不想承接这些脏活累活。</p><p>那交给谁呢？</p><p>答案是—中间件(Middleware)，它专门负责底层操作系统和上层应用程序都不愿意做的事情。</p><p>Java充分发挥制定标准的特长，制订了J2EE规范，其涵盖了大部分企业开发的需求，把通用、复杂的服务交给中间件提供商去搞定，让开发人员集中精力在业务逻辑的开发上。</p><p>其中一个标准就是EJB，使用EJB即可不用写繁琐的JDBC代码了，数据的创建、读取、查询均可以用面向对象的风格搞定，并且EJB实例可以在一个集群上分布式的运行。</p><p>当然，EJB的缺点也非常明显，它过于笨重了，且开发繁琐、难以测试、性能低下。</p><p>是到了变革的时候了！</p><h3 id="轻量级ORM框架"><a href="#轻量级ORM框架" class="headerlink" title="轻量级ORM框架"></a>轻量级ORM框架</h3><p>2001年，Gavin King发明了Hibernate，意为冬眠。</p><p>冬眠？冬天让内存中的数据进入数据库冬眠，春天来了从冬眠中醒来，进入内存工作。</p><p>同年，iBatis也出现了。</p><p>2004年，Rod Johnson给了EJB致命一击，他编写了Export One-on-One J2EE Development without EJB一书,公开宣扬抛弃笨重的EJB，使用由他开发出的轻量框架Spring。</p><p>Spring不但自己提供了轻量级的访问数据库的方法JdbcTemplate，还可轻松集成Hibernate、IBatis等一系列ORM框架，所以受到越来越多Java开发者的欢迎，EJB已名存实亡。</p><h3 id="JPA"><a href="#JPA" class="headerlink" title="JPA"></a>JPA</h3><p>后面出现的EJB3.0虽然兼收并蓄，融合了Hibernate的优点，但其笨重的底子是难以被改变的，最终还是被Java开发者无情地抛弃了。</p><p>EJB3.0定义的ORM标准却神奇地活了下来，也就是Java Persistence API(JPA)，Hibernate、EclipseLink、OpenJPA等明星框架均提供了针对JPA的实现，由于其简便性，收到了一部分开发者的喜爱。</p><h2 id="JDBC发展过程"><a href="#JDBC发展过程" class="headerlink" title="JDBC发展过程"></a>JDBC发展过程</h2><ul><li>Socket</li></ul><p>最开始数据库仅能支持网络访问，即通过Socket的方式获取数据库中的数据。</p><p>这种方式可以实现业务功能，但是业务层需要更换数据库时，由于各个数据库提供的接口不统一，则需要将业务代码的相关部分重写，统一接口迫在眉睫。</p><ul><li>JDBC</li></ul><p>继续抽象，用Connection来代表与数据库的连接，Statement中书写SQL代码，返回的结果统一用ResultSet来表示。</p><p>接口的具体实现由各数据库完成。</p><ul><li>Driver</li></ul><p>但还不够彻底，由于各数据库的实现类不同，更换数据库的时候还是需要更改相应代码。</p><p>继续抽象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Driver&#123;</span><br><span class="line">public static Connection getConnection(String dbType, Properties info)&#123;</span><br><span class="line">if(&quot;mysql&quot;.equals(dbType))&#123;</span><br><span class="line">return new MySqlConnentionImpl(info);</span><br><span class="line">&#125;</span><br><span class="line">if(&quot;oracle&quot;.equals(dbType))&#123;</span><br><span class="line">return new OracleConnentionImpl(info);</span><br><span class="line">&#125;</span><br><span class="line">if(&quot;db2&quot;.equals(dbType))&#123;</span><br><span class="line">return new DB2ConnentionImpl(info);</span><br><span class="line">&#125;</span><br><span class="line">throw new RuntimeException(&quot;unsupport db type: &quot; + dbType);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但还是存在问题，比如需要增加新的数据库，则需要频繁修改Driver代码，如果Driver已经打包到JDK里，则就无法修改了。</p><p>解决的方式也很简单，基于反射的方式从外部读取配置，然后创建相应的Connection实现类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// Connection-type.properties</span><br><span class="line">// mysql = com.mysql.jdbc.MySqlConnectionImpl</span><br><span class="line"></span><br><span class="line">public class Driver&#123;</span><br><span class="line">public static Connection getConnection(String dbType, Properties info)&#123;</span><br><span class="line">Class&lt;?&gt; clz = getConnectionImplClass(dbType);</span><br><span class="line">try&#123;</span><br><span class="line">Constructor&lt;?&gt; c = clz.getConstructor(Properties.class);</span><br><span class="line">return (Connection) c.newInstance(info);</span><br><span class="line">&#125;catch(Exception e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static Class&lt;?&gt; getConnectionImplClass(String dbType)&#123;</span><br><span class="line">// 读取配置文件，从中根据dbType来读取相应的Connection实现类，过程略</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，创建实现类的过程不应该被暴露出来。应该让各个厂商在各自的.jar中去创建各自的Connection实例对象。</p><p>使用工厂方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 属于JDK的Driver类</span><br><span class="line">public interface Driver&#123;</span><br><span class="line">public Connection getConnection(Properties info);</span><br><span class="line">&#125;</span><br><span class="line">// 属于mysql-jdbc.jar的MySqlDriver类</span><br><span class="line">public class MySqlDriver implements Driver&#123;</span><br><span class="line">@override</span><br><span class="line">public Connection getConnection(Properties info)&#123;</span><br><span class="line">return new MySqlConnentionImpl(info);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，Driver变成了接口，由各数据库厂商去具体实现。</p><p>业务层调用的时候通过反射的方式来进行Connection实现类的加载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clz = Class.forName(&quot;com.mysql.MySqlDriver&quot;);</span><br><span class="line">Driver driver = (Driver)clz.newInstance();</span><br><span class="line">Connection conn = driver.getConnection(info);</span><br></pre></td></tr></table></figure><p>进一步简化，将上面的脏活累活交给DriverManager。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class DriverManager&#123;</span><br><span class="line">private static List&lt;Driver&gt; registeredDrivers = new ArrayList&lt;&gt;();</span><br><span class="line">public static Connection getConnection(String url, String user, String password)&#123;</span><br><span class="line">Properties info = new Properties();</span><br><span class="line">info.put(&quot;user&quot;, user);</span><br><span class="line">info.put(&quot;password&quot;, password);</span><br><span class="line">for(Driver driver : registeredDrivers)&#123;</span><br><span class="line">Connection conn = driver.getConnection(url, info);</span><br><span class="line">if(conn != null)&#123;</span><br><span class="line">return conn;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">thow new RuntimeExecption(&quot;can&apos;t create a connection&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void register(Driver driver)&#123;</span><br><span class="line">if(!registeredDrivers.contains(driver))&#123;</span><br><span class="line">registeredDrivers.add(driver);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如，MySqlDriver的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class MySqlDriver implements Driver&#123;</span><br><span class="line">static&#123;</span><br><span class="line">DriverManager.register(new MySqlDriver())</span><br><span class="line">&#125;</span><br><span class="line">public Connection getConnection(String url, Properties info)&#123;</span><br><span class="line">if(acceptsURL(url))&#123;</span><br><span class="line">return new MySqlConnectionImpl(info);</span><br><span class="line">&#125;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean acceptURL(String url)&#123;</span><br><span class="line">return url.startsWith(&quot;jdbc:mysql&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;持久化方案发展过程&quot;&gt;&lt;a href=&quot;#持久化方案发展过程&quot; class=&quot;headerlink&quot; title=&quot;持久化方案发展过程&quot;&gt;&lt;/a&gt;持久化方案发展过程&lt;/h2&gt;&lt;h3 id=&quot;序列化&quot;&gt;&lt;a href=&quot;#序列化&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="Java" scheme="http://ruanshubin.top/categories/Java/"/>
    
    
      <category term="Java" scheme="http://ruanshubin.top/tags/Java/"/>
    
      <category term="基础" scheme="http://ruanshubin.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ是什么</title>
    <link href="http://ruanshubin.top/2019/10/25/RabbitMQ%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>http://ruanshubin.top/2019/10/25/RabbitMQ是什么/</id>
    <published>2019-10-25T13:30:00.000Z</published>
    <updated>2019-12-25T02:47:47.319Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>首先，明确一下MQ是啥？</p><p>MQ是Message Queue的简称，意即消息队列，队列可以理解成管道，即通过管道来进行消息的传递，</p><p>接着想一下MQ可以用来解决什么问题？</p><p>双十一秒杀场景，瞬间来了海量请求，服务器短时间处理不过来，可以先给用户一个返回结果，然后将未处理的请求先放入消息队列，后台慢慢处理队列中的消息，整个过程是异步的。</p><p>MQ既然很有用，各大厂商们便开始考虑构建符合自己业务需求的MQ组件。</p><p>如同TCP协议、HTTP协议一样，业界也存在MQ协议，我们将其称之为AMQP，即Advanced Message Queuing Protocol，高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。</p><p>AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全，其基本架构如下：</p><p><img src="/2019/10/25/RabbitMQ是什么/1.jpg" alt=""></p><p>可以看出，AMQP协议主要分为3大部分：</p><ul><li>Producer: 消息生产者；</li><li>Broker: 消息队列的服务实体；<ul><li>Exchange: 消息交换机，相当于消息的转发中心；</li><li>Binding: 关系绑定，作用是建立Exchange与Queue的映射；</li><li>Queue: 队列，消息的队列载体，每条消息都会由Exchange投递到一个或多个Queue中；</li></ul></li><li>Consumer: 消息消费者。</li></ul><p>由于，RabbitMQ是AMQP的标准实现，下面我们通过RabbitMQ来具体讲解上述协议的各个组件。</p><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>Queue（队列）是RabbitMQ的内部对象，用于存储消息，用下图表示：</p><p><img src="/2019/10/25/RabbitMQ是什么/2.jpg" alt=""></p><p>RabbitMQ中的消息都只能存储在Queue中，生产者（下图中的P）生产消息并最终投递到Queue中，消费者（下图中的C）可以从Queue中获取消息并消费。</p><p><img src="/2019/10/25/RabbitMQ是什么/3.jpg" alt=""></p><p>多个消费者可以订阅同一个Queue，这时Queue中的消息会被平均分摊给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理。 </p><p><img src="/2019/10/25/RabbitMQ是什么/4.jpg" alt=""></p><p>这里可能会存在一个问题，就是假设同一个Queue的多个消费者对消息的处理速度不一致，就会出现有的消费者忙的不堪重负，而有的消费者则闲的一直喝茶，造成消费速度缓慢、系统资源浪费等问题。</p><p>为解决上述问题，RabbitMQ引入了Prefetch count参数，可以通过设置prefetchCount来限制Queue每次发送给每个消费者的消息数，比如我们设置prefetchCount=1，则Queue每次给每个消费者发送一条消息；消费者处理完这条消息后，Queue再给该消费者发送一条消息，从而实现了“能者多劳”。</p><p><img src="/2019/10/25/RabbitMQ是什么/5.jpg" alt=""></p><p>可以看到，上面Producer将消息直接投递到Queue，然后Consumer去相应Queue去取数据，看起来问题不大，但上述模式下的生产者和消费者存在严重的耦合。</p><p>比如以下场景：</p><p>ConsumerA和ConsumerB均想获取ProducerA发送的全部消息，由于Queue的特性，必须构建2个队列QueueA及QueueB，然后由Producer将数据分别投递到QueueA及QueueB。</p><p>假设后面又有一个ConsumerC想获取ProducerA发送的全部消息，此时，我们不但要创建一个QueueC，而且要修改Producer端的代码，使其将数据分别投递到QueueA、QueueB、QueueC。</p><p>此时，每来一个消费者，我们就得修改一次Producer端的代码，生产和消费紧耦合。</p><p>如何解耦呢，套用软件界有名的一句话：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决！</span><br><span class="line">Any problem in computer science can be solved by another layer of indirection！</span><br></pre></td></tr></table></figure><p>所以，AMQP引入Exchange来将消息的Producer和Consumer解耦。</p><h2 id="Exchange"><a href="#Exchange" class="headerlink" title="Exchange"></a>Exchange</h2><p>AMQP 协议中的核心思想就是生产者和消费者的解耦，生产者从不直接将消息发送给队列。生产者通常不知道是否一个消息会被发送到队列中，只是将消息发送到一个交换机。先由 Exchange 来接收，然后 Exchange 按照特定的策略转发到 Queue 进行存储。Exchange 就类似于一个交换机，将各个消息分发到相应的队列中。</p><p><img src="/2019/10/25/RabbitMQ是什么/6.jpg" alt=""></p><p>在实际应用中我们只需要定义好 Exchange 的路由策略，而生产者则不需要关心消息会发送到哪个 Queue 或被哪些 Consumer 消费。在这种模式下生产者只面向 Exchange 发布消息，消费者只面向 Queue 消费消息，Exchange 定义了消息路由到 Queue 的规则，将各个层面的消息传递隔离开，使每一层只需要关心自己面向的下一层，降低了整体的耦合度。</p><h2 id="Binding及RoutingKey"><a href="#Binding及RoutingKey" class="headerlink" title="Binding及RoutingKey"></a>Binding及RoutingKey</h2><p>Binding负责建立Exchange与Queue之间的映射，绑定需要依赖一个额外的参数:RoutingKey，Exchange根据RoutingKey与当前所有绑定的Binding匹配，若满足匹配，则往Exchange所绑定的Queue发送消息。</p><p>向RabbitMQ发送一次消息，可以将其分发到不同的Queue，而RoutingKey的意义依赖于Exchange的类型。</p><p>Exchange主要有三种类型：Fanout、Direct 和Topic。</p><h3 id="Direct-Exchange"><a href="#Direct-Exchange" class="headerlink" title="Direct Exchange"></a>Direct Exchange</h3><p><img src="/2019/10/25/RabbitMQ是什么/7.jpg" alt=""></p><p>Direct Exchange是RabbitMQ默认的Exchange，完全根据RoutingKey来路由消息。设置Exchange和Queue的Binding时需指定RoutingKey（一般为Queue Name），发消息时也指定一样的RoutingKey，消息就会被路由到对应的Queue。</p><p>现在我们考虑只把重要的日志消息写入磁盘文件，例如只把Error级别的日志发送给负责记录写入磁盘文件的Queue。这种场景下我们可以使用指定的RoutingKey（例如 error）将写入磁盘文件的Queue绑定到Direct Exchange上。</p><h3 id="Fanout-Exchange"><a href="#Fanout-Exchange" class="headerlink" title="Fanout Exchange"></a>Fanout Exchange</h3><p><img src="/2019/10/25/RabbitMQ是什么/8.jpg" alt=""></p><p>Fanout Exchange会忽略RoutingKey的设置，直接将Message广播到所有绑定的Queue中。</p><p>以日志系统为例：假设我们定义了一个Exchange来接收日志消息，同时定义了两个Queue来存储消息：一个记录将被打印到控制台的日志消息；另一个记录将被写入磁盘文件的日志消息。我们希望Exchange接收到的每一条消息都会同时被转发到两个Queue，这种场景下就可以使用FanoutExchange来广播消息到所有绑定的Queue。</p><h3 id="Topic-Exchange"><a href="#Topic-Exchange" class="headerlink" title="Topic Exchange"></a>Topic Exchange</h3><p><img src="/2019/10/25/RabbitMQ是什么/9.jpg" alt=""></p><p>Topic Exchange和Direct Exchange类似，也需要通过RoutingKey来路由消息，区别在于Direct Exchange对Routing Key是精确匹配，而Topic Exchange支持模糊匹配。分别支持<em>和#通配符，</em>表示匹配一个单词，#则表示匹配没有或者多个单词。</p><p>假设我们的消息路由规则除了需要根据日志级别来分发之外还需要根据消息来源分发，可以将RoutingKey定义为消息来源.级别如 order.info、user.error等。处理所有来源为user的Queue就可以通过user.<em> 绑定到Topic Exchange上，而处理所有日志级别为info的Queue可以通过 </em>.info 绑定到Exchange上。</p><p>除此以外，还有2种特殊的Exchange。</p><h3 id="Headers-Exchange"><a href="#Headers-Exchange" class="headerlink" title="Headers Exchange"></a>Headers Exchange</h3><p>Headers Exchange会忽略RoutingKey而根据消息中的Headers和创建绑定关系时指定的Arguments来匹配决定路由到哪些Queue。</p><p>Headers Exchange的性能比较差，而且Direct Exchange完全可以代替它，所以不建议使用。</p><h3 id="Default-Exchange"><a href="#Default-Exchange" class="headerlink" title="Default Exchange"></a>Default Exchange</h3><p>Default Exchange是一种特殊的Direct Exchange。当你手动创建一个队列时，后台会自动将这个队列绑定到一个名称为空的Direct Exchange 上，绑定RoutingKey与队列名称相同。有了这个默认的交换机和绑定，使我们只关心队列这一层即可，这个比较适合做一些简单的应用。</p><p>相当于<strong>直接往Queue里发送消息</strong>。</p><p><strong>参考文献：</strong></p><p>1.<a href="https://www.sojson.com/blog/48.html" target="_blank" rel="noopener">https://www.sojson.com/blog/48.html</a><br>2.<a href="https://blog.csdn.net/y4x5M0nivSrJaY3X92c/article/details/80416996#" target="_blank" rel="noopener">https://blog.csdn.net/y4x5M0nivSrJaY3X92c/article/details/80416996#</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;首先，明确一下MQ是啥？&lt;/p&gt;
&lt;p&gt;MQ是Message Queue的简称，意即消息队列，队列可以理解成管道，即通过管道来进行消息的传递
      
    
    </summary>
    
      <category term="基础" scheme="http://ruanshubin.top/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="基础" scheme="http://ruanshubin.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="消息队列" scheme="http://ruanshubin.top/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>如何正确使用RabbitMQ</title>
    <link href="http://ruanshubin.top/2019/10/25/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8RabbitMQ/"/>
    <id>http://ruanshubin.top/2019/10/25/如何正确使用RabbitMQ/</id>
    <published>2019-10-25T13:30:00.000Z</published>
    <updated>2019-12-25T02:49:03.793Z</updated>
    
    <content type="html"><![CDATA[<p>在介绍RabbitMQ的使用之前，我们再具体阐述RabbitMQ里面的一些相关参数，有利于以后使用过程中排坑。</p><p>首先，深入聊一下Queues:</p><h2 id="Queues"><a href="#Queues" class="headerlink" title="Queues"></a>Queues</h2><p>RabbitMQ的Queue存储着Consumer待消费的消息，其与Exchange基于Binding Key进行绑定，除了Binding相关参数外，Queue还有以下重要属性：</p><ul><li>name</li></ul><p>队列名支持最多255字节的UTF-8字符。应用程序在声明队列的时候可以自己指定队列名，或者当应用程序指定name属性为空时，代理（broker）会自动地为其生成一个唯一的队列名。</p><p>需要注意的是，<strong>以”amq.”开头的队列名是由AMQP内部使用的命名前缀，请开发者不要使用</strong>，否则将抛出403异常。</p><ul><li>durability</li></ul><p>durability属性对应两种情况，分别是durable（持久的）和transient（短暂的）。durable类型的队列会持久化至硬盘上，所以当代理（broker）重启之后，它依然存在。相反地，当代理重启之后，transient类型的队列就消失了。</p><p>需要注意的是，队列的持久化是相对队列而言，对存储在持久化队列中的消息来说，当代理重启之后：队列还存在、消息则不存在。</p><p>所以，当broker重启之后，如果想让消息仍然存在，这就是消息持久化机制干的事了，后面再说消息属性的相关内容。</p><h3 id="Queue创建"><a href="#Queue创建" class="headerlink" title="Queue创建"></a>Queue创建</h3><p>需要注意的是，<strong>队列在使用之前必须先声明</strong>。声明之前，如果该队列不存在，那么声明之后就会创建一个队列；如果该队列已经存在了，并且声明的队列与存在的队列属性相同，则不产生任何影响；如果该队列已经存在了，但是声明的队列与存在的队列属性不同，则会抛出一个错误码为406（PRECONDITION_FAILED）的异常。</p><h3 id="Binding"><a href="#Binding" class="headerlink" title="Binding"></a>Binding</h3><p>队列获取来自交换器的消息的前提是该队列必须先与交换器进行绑定。绑定之后，交换器才能将消息按照特定的规则，路由至相应的队列中去。随后，消费者才能从队列中消费消息。</p><p>如果生产者生产的某条消息，没有与之匹配的任何一个队列可供路由（比如，没有任何队列与交换器绑定）。那么，根据该条消息的属性，该消息要么丢弃，要么返回至生产者。</p><h2 id="连接及通道"><a href="#连接及通道" class="headerlink" title="连接及通道"></a>连接及通道</h2><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>AMQP是一个应用层协议，并且是基于TCP可靠传输的应用层协议。除此之外，AMQP也提供了加密传输的机制（使用TSL或SSL），让消息传递更加安全。</p><p>当需要断开AMQP代理时，正确的做法是关闭AMQP连接，而不是粗鲁的直接断开其底层的TCP连接。</p><h3 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h3><p>有的应用程序需要与AMQP broker建立多个连接。在AMQP模型中，我们不需要通过建立太多的TCP连接来实现。假如针对每一个AMQP连接都建立一个TCP连接的话，会占用大量的系统资源。对此，AMQP提供了通道（channel）机制。即，共享一个TCP连接，可创建多个通道。</p><p>在多线程/进程的应用程序中正确做法是，对于每一个线程/进程，应分别建立一个通道，而不是多个线程/进程之间去共享一个通道。</p><h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><p>AMQP使用了虚拟机的概念，在一个broker上面划分出多个隔离的环境（各环境下的用户、交换器以及队列等互不影响）。这样一来，AMQP客户端们在进行连接的时候，需要协商指定同一个vhost才能进行正常的往来业务。</p><h2 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h2><p>接下来，看一下消息的生产、传输、消费相关的机制。</p><h3 id="Message-acknowledgements"><a href="#Message-acknowledgements" class="headerlink" title="Message acknowledgements"></a>Message acknowledgements</h3><p>试想一下这个问题：如果消费者应用程序在处理某个消息的时候突然奔溃了，那么这条消息该何去何从？再进一步的说，AMQP消息代理要在什么时候将某条消息从队列中移除？对此，AMQP给出了两种处理办法：一是，当消息代理（broker）将一条消息发送给消费者应用程序之后就将其从队列中移除；二是，当消费者应用程序返还一条确认信息之后（类似于TCP三次握手中的ack确认）就将其从队列中移除。</p><p>第一种处理方法是自动确认的，称为automatic acknowledgement；第二种处理方法则需要由消费者进行确认操作，称为explicit acknowledgement。针对第二种处理方法，消费者在何时返回ack也是比较灵活的。比如，消费者可以在接收到消息的第一时间就返回一个ack，或者在将消息持久化到硬盘之后返回ack，又或者在消息完全处理完之后返回ack。</p><p>如果一个接收到消息的消费者在没有返回ack之前就挂掉了，那么，AMQP消息代理将会将这条消息发送给其他能匹配上的消费者。但是，若没有任何消费者能够匹配上这条消息，AMQP代理将会一直等待，直到有能匹配上的消费者出现，再将该消息投递给它。</p><h3 id="Rejecting-messages"><a href="#Rejecting-messages" class="headerlink" title="Rejecting messages"></a>Rejecting messages</h3><p>消费者应用程序在处理消息失败时，应用程序可以通知broker：消息处理失败，拒绝消息。当拒绝消息时，消费者应用程序可以要求broker丢弃或重新发送该消息。</p><h3 id="Prefetching-messages"><a href="#Prefetching-messages" class="headerlink" title="Prefetching messages"></a>Prefetching messages</h3><p>多个消费者从一个队列中消费消息时，可以指定每个消费者在返回下一个ack之前，每次发送给他们的消息数量，即预取消息的数量。这可以当做一个简单的负载均衡技术来使用，</p><p>也可以在批量生产消息的情景下提高吞吐量。</p><h3 id="Message-attributes-and-payload"><a href="#Message-attributes-and-payload" class="headerlink" title="Message attributes and payload"></a>Message attributes and payload</h3><p>AMQP模型中的消息实体各种属性，比如：</p><ul><li>content type</li><li>content encoding</li><li>routing key</li><li>delivery mode(persistent or not)</li><li>message priority</li><li>message publish timestamp</li><li>expiration period</li><li>publisher application id等。</li></ul><p>消息的属性是在消息被生产时设置的。</p><p>AMQP消息除了属性之外还有一个有效负载（可以理解为消息体，即它携带的数据），AMQP视这些负载数据为一个不透明的字节数组。并且，AMQP代理不会去窥探和改变这些负载的数据。对于这些负载的数据，你可以使用例如JSON这样的序列化格式来存储。</p><p>如果将消息属性设置为持久化，AMQP代理将会将这些持久化的消息写入磁盘，这可以保证当服务重启之后，消息不会丢失。</p><p>仍需要啰嗦的一点是：如果仅仅将一个消息生产到一个持久化的交换器，或者将这条消息路由到一个持久化的队列中去，并不能使这个消息本身变成持久化消息。消息的持久化与否主要取决于消息本身的属性设置。</p><p><strong>参考资料：</strong></p><ol><li><a href="http://dulishu.top/rabbitmq-amqp/" target="_blank" rel="noopener">http://dulishu.top/rabbitmq-amqp/</a></li><li><a href="http://www.rabbitmq.com/tutorials/amqp-concepts.html" target="_blank" rel="noopener">http://www.rabbitmq.com/tutorials/amqp-concepts.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在介绍RabbitMQ的使用之前，我们再具体阐述RabbitMQ里面的一些相关参数，有利于以后使用过程中排坑。&lt;/p&gt;
&lt;p&gt;首先，深入聊一下Queues:&lt;/p&gt;
&lt;h2 id=&quot;Queues&quot;&gt;&lt;a href=&quot;#Queues&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
      <category term="基础" scheme="http://ruanshubin.top/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="基础" scheme="http://ruanshubin.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="消息队列" scheme="http://ruanshubin.top/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Centos下安装MongoDB</title>
    <link href="http://ruanshubin.top/2019/10/24/Centos%E4%B8%8B%E5%AE%89%E8%A3%85MongoDB/"/>
    <id>http://ruanshubin.top/2019/10/24/Centos下安装MongoDB/</id>
    <published>2019-10-24T13:30:00.000Z</published>
    <updated>2019-12-25T02:44:08.314Z</updated>
    
    <content type="html"><![CDATA[<p>查看MongoDB的版本，到<a href="https://www.mongodb.com/download-center#community下，选择Community" target="_blank" rel="noopener">https://www.mongodb.com/download-center#community下，选择Community</a> Server后选择linux，之后再选择对应版本。</p><p>如果装的是Amazon的，启动mongodb时会出现Error parsing INI config file: unrecognised option ‘nohttpinterface’ 错误，所以选择RHEL版本。</p><p><img src="/2019/10/24/Centos下安装MongoDB/1.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">weget http://downloads.mongodb.org/linux/mongodb-linux-x86_64-rhel70-latest.tgz</span><br></pre></td></tr></table></figure><ul><li>解压</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zvxf mongodb-linux-x86_64-rhel70-latest.tgz</span><br></pre></td></tr></table></figure><ul><li>创建数据库目录</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /usr/local/software/mongodb/db</span><br><span class="line">mkdir -p /usr/local/software/mongodb/log</span><br></pre></td></tr></table></figure><ul><li>创建配置文件mongodb.conf</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">设置数据文件的存放目录 </span><br><span class="line">dbpath = /usr/local/software/mongodb/db </span><br><span class="line">设置日志文件的存放目录及其日志文件名 </span><br><span class="line">logpath = /usr/local/software/mongodb/log/mongodb.log </span><br><span class="line">设置端口号（默认的端口号是 27017） </span><br><span class="line">port = 27017 </span><br><span class="line">设置为以守护进程的方式运行，即在后台运行 </span><br><span class="line">fork = true </span><br><span class="line">关闭http接口，默认关闭27018端口访问 </span><br><span class="line">nohttpinterface = true</span><br></pre></td></tr></table></figure><ul><li>启动</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 命令行启动</span><br><span class="line">mongod --dbpath=/usr/local/software/mongodb/db --logpath=/usr/local/software/mongodb/log/mongodb.log &amp;</span><br><span class="line"># 配置文件启动</span><br><span class="line">./mongod --config mongodb.conf</span><br><span class="line"># 守护进程启动</span><br><span class="line">mongod --dbpath=/usr/local/software/mongodb/db --logpath=/usr/local/software/mongodb/log/mongodb.log --fork --port 27017</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;查看MongoDB的版本，到&lt;a href=&quot;https://www.mongodb.com/download-center#community下，选择Community&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.mongodb
      
    
    </summary>
    
      <category term="基础" scheme="http://ruanshubin.top/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="数据库" scheme="http://ruanshubin.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="基础" scheme="http://ruanshubin.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch入门</title>
    <link href="http://ruanshubin.top/2019/10/24/Elasticsearch%E5%85%A5%E9%97%A8/"/>
    <id>http://ruanshubin.top/2019/10/24/Elasticsearch入门/</id>
    <published>2019-10-24T13:30:00.000Z</published>
    <updated>2019-12-25T02:45:44.022Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h2><p>一个文档不仅仅包含它的数据 ，也包含元数据——有关文档的信息。 三个必须的元数据元素如下：</p><ul><li>_index</li></ul><p>文档在哪存放 。一个索引应该是因共同的特性被分组到一起的文档集合。索引名必须小写，不能以下划线开头，不能包含逗号；</p><ul><li>_type </li></ul><p>文档表示的对象类别；</p><ul><li>_id </li></ul><p>文档唯一标识。</p><p>Elasticsearch 支持 RESTFUL 风格 API，其 API 基本格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://&lt;ip&gt;:&lt;port&gt;/&lt;索引&gt;/&lt;类型&gt;/&lt;文档id&gt;</span><br></pre></td></tr></table></figure><h3 id="创建-删除索引"><a href="#创建-删除索引" class="headerlink" title="创建/删除索引"></a>创建/删除索引</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">post http://&lt;ip&gt;:&lt;port&gt;/index/type/id # 手动指定id</span><br><span class="line">或者</span><br><span class="line">post http://&lt;ip&gt;:&lt;port&gt;/index/type # es自动生成id</span><br></pre></td></tr></table></figure><p>请记住， _index 、 _type 和 _id 的组合可以唯一标识一个文档。所以，确保创建一个新文档的最简单办法是，使用索引请求的 POST 形式让 Elasticsearch 自动生成唯一 _id :</p><p>如果已经有自己的 _id ，那么我们必须告诉 Elasticsearch ，只有在相同的 _index 、 _type 和 _id 不存在时才接受我们的索引请求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">post http://&lt;ip&gt;:&lt;port&gt;/index/type/id?op_type=create</span><br><span class="line"></span><br><span class="line">post http://&lt;ip&gt;:&lt;port&gt;/index/type/id/_create</span><br></pre></td></tr></table></figure><p>如果创建新文档的请求成功执行，Elasticsearch 会返回元数据和一个 201 Created 的 HTTP 响应码。</p><p>另一方面，如果具有相同的 _index 、 _type 和 _id 的文档已经存在，Elasticsearch 将会返回 409 Conflict 响应码，以及如下的错误信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;error&quot;: &#123;</span><br><span class="line">        &quot;root_cause&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;type&quot;: &quot;version_conflict_engine_exception&quot;,</span><br><span class="line">                &quot;reason&quot;: &quot;[employee][1]: version conflict, document already exists (current version [4])&quot;,</span><br><span class="line">                &quot;index_uuid&quot;: &quot;lo-6VdTHQWKAYVuMu3djQg&quot;,</span><br><span class="line">                &quot;shard&quot;: &quot;3&quot;,</span><br><span class="line">                &quot;index&quot;: &quot;megacorp&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        &quot;type&quot;: &quot;version_conflict_engine_exception&quot;,</span><br><span class="line">        &quot;reason&quot;: &quot;[employee][1]: version conflict, document already exists (current version [4])&quot;,</span><br><span class="line">        &quot;index_uuid&quot;: &quot;lo-6VdTHQWKAYVuMu3djQg&quot;,</span><br><span class="line">        &quot;shard&quot;: &quot;3&quot;,</span><br><span class="line">        &quot;index&quot;: &quot;megacorp&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;status&quot;: 409</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除一个索引，需要使用 DELETE 请求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete http://&lt;ip&gt;:&lt;port&gt;/index/type/id</span><br></pre></td></tr></table></figure><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>put请求。</p><h3 id="查找数据"><a href="#查找数据" class="headerlink" title="查找数据"></a>查找数据</h3><ul><li>GET方式简单搜索</li></ul><p>查询指定ID的数据，使用 GET 请求。</p><p>查询id是1的雇员信息，执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[GET] http://39.106.195.92:9200/megacorp/employee/1</span><br></pre></td></tr></table></figure><p>返回结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;_index&quot;: &quot;megacorp&quot;,</span><br><span class="line">    &quot;_type&quot;: &quot;employee&quot;,</span><br><span class="line">    &quot;_id&quot;: &quot;1&quot;,</span><br><span class="line">    &quot;_version&quot;: 2,</span><br><span class="line">    &quot;found&quot;: true,    //表示文档被找到</span><br><span class="line">    &quot;_source&quot;: &#123;</span><br><span class="line">        &quot;first_name&quot;: &quot;Douglas&quot;,</span><br><span class="line">        &quot;last_name&quot;: &quot;Fir&quot;,</span><br><span class="line">        &quot;age&quot;: 35,</span><br><span class="line">        &quot;about&quot;: &quot;I like to build cabinets&quot;,</span><br><span class="line">        &quot;interests&quot;: [</span><br><span class="line">            &quot;forestry&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询文档的一部分（只查询名字）:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[GET] http://39.106.195.92:9200/megacorp/employee/1?_source=first_name,last_name</span><br></pre></td></tr></table></figure><p>查询所有信息，不指定id，使用_search,执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[GET] http://39.106.195.92:9200/megacorp/employee/_search</span><br></pre></td></tr></table></figure><p>按条件查询，仍然在请求路径中使用 _search 端点，并将查询本身赋值给参数 q= ，执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[GET] http://39.106.195.92:9200/megacorp/employee/_search?q=last_name:Smith</span><br></pre></td></tr></table></figure><p>查询文档是否存在，把GET方式换位HEAD方式就可以了，HEAD 请求没有返回体，只返回一个 HTTP 请求报头： 存在返回200，否在返回404。</p><ul><li>POST方式搜索</li></ul><p>GET条件查询的方式虽然方便，但有很大的局限性，ES提供了POST的方式查询语言–查询表达式，它支持构建更加复杂和健壮的查询。 POST方式的搜索url都相同，只是body不同:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[POST] http://39.106.195.92:9200/megacorp/employee/_search</span><br></pre></td></tr></table></figure><p>请求参数：使用 JSON 构造，并使用了一个 match 查询（属于查询类型之一,这里match不能匹配多个字段。匹配多个字段要使用multi_match ）</p><p>查找 last_name= “Smith”：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;query&quot; : &#123;</span><br><span class="line">        &quot;match&quot; : &#123;</span><br><span class="line">            &quot;last_name&quot; : &quot;Smith&quot;   //只能写一个</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>复杂的搜索</li></ul><p>使用过滤器filter搜索姓氏为 Smith 的雇员 且年龄大于30，使用的是range过滤器，其中 gt 表示_大于 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;query&quot; : &#123;</span><br><span class="line">        &quot;bool&quot;: &#123;</span><br><span class="line">            &quot;must&quot;: &#123;</span><br><span class="line">                &quot;match&quot; : &#123;</span><br><span class="line">                    &quot;last_name&quot; : &quot;smith&quot; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;filter&quot;: &#123;</span><br><span class="line">                &quot;range&quot; : &#123;</span><br><span class="line">                    &quot;age&quot; : &#123; &quot;gt&quot; : 30 &#125; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>全文搜索</li></ul><p>使用match全文搜索，Elasticsearch 默认按照相关性得分排序，即每个文档跟查询的匹配程度:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;query&quot; : &#123;</span><br><span class="line">        &quot;match&quot; : &#123;</span><br><span class="line">            &quot;about&quot; : &quot;rock climbing&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>短语搜索</li></ul><p>使用match_phrase短语搜索（准确搜索）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;query&quot; : &#123;</span><br><span class="line">        &quot;match_phrase&quot; : &#123;</span><br><span class="line">            &quot;about&quot; : &quot;rock climbing&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>高亮搜索</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;query&quot; : &#123;</span><br><span class="line">        &quot;match_phrase&quot; : &#123;</span><br><span class="line">            &quot;about&quot; : &quot;rock climbing&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;highlight&quot;: &#123;</span><br><span class="line">        &quot;fields&quot; : &#123;</span><br><span class="line">            &quot;about&quot; : &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>分析</li></ul><p>Elasticsearch 有一个功能叫聚合（aggregations），允许我们基于数据生成一些精细的分析结果。聚合与 SQL 中的 GROUP BY 类似但更强大。</p><p>挖掘出雇员中最受欢迎的兴趣爱好：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;all_interests&quot;: &#123;</span><br><span class="line">      &quot;terms&quot;: &#123; &quot;field&quot;: &quot;interests&quot; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>mget批量查询</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[POST] http://39.106.195.92:9200/_mget</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   &quot;docs&quot; : [</span><br><span class="line">      &#123;</span><br><span class="line">         &quot;_index&quot; : &quot;megacorp&quot;,</span><br><span class="line">         &quot;_type&quot; :  &quot;employee&quot;,</span><br><span class="line">         &quot;_id&quot; :    2</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         &quot;_index&quot; : &quot;website&quot;,    //没有索引的话，会报错搜索不到该索引的内容</span><br><span class="line">         &quot;_type&quot; :  &quot;employee&quot;,</span><br><span class="line">         &quot;_id&quot; :    1,</span><br><span class="line">         &quot;_source&quot;: &quot;age&quot;</span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><ul><li>文档全部更新</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[PUT] http://39.106.195.92:9200/megacorp/employee/1</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;_index&quot;: &quot;megacorp&quot;,</span><br><span class="line">    &quot;_type&quot;: &quot;employee&quot;,</span><br><span class="line">    &quot;_id&quot;: &quot;1&quot;,</span><br><span class="line">    &quot;_version&quot;: 3,</span><br><span class="line">    &quot;result&quot;: &quot;updated&quot;,</span><br><span class="line">    &quot;_shards&quot;: &#123;</span><br><span class="line">        &quot;total&quot;: 2,</span><br><span class="line">        &quot;successful&quot;: 1,</span><br><span class="line">        &quot;failed&quot;: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;created&quot;: false    //这里变成了false,表示是更新</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>文档部分更新</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[POST] http://39.106.195.92:9200/megacorp/employee/1/_update</span><br></pre></td></tr></table></figure><p>请求参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;doc&quot;: &#123;</span><br><span class="line">        &quot;age&quot;: &quot;88&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="es的并发控制"><a href="#es的并发控制" class="headerlink" title="es的并发控制"></a>es的并发控制</h2><p>在数据库领域中，有两种方法通常被用来确保并发更新时变更不会丢失：</p><ul><li>悲观并发控制 </li></ul><p>这种方法被关系型数据库广泛使用，它假定有变更冲突可能发生，因此阻塞访问资源以防止冲突。 一个典型的例子是读取一行数据之前先将其锁住，确保只有放置锁的线程能够对这行数据进行修改。</p><ul><li>乐观并发控制 </li></ul><p>Elasticsearch 中使用的这种方法假定冲突是不可能发生的，并且不会阻塞正在尝试的操作。 然而，如果源数据在读写当中被修改，更新将会失败。应用程序接下来将决定该如何解决冲突。 例如，可以重试更新、使用新的数据、或者将相关情况报告给用户。</p><p>lasticsearch 是分布式的。当文档创建、更新或删除时， 新版本的文档必须复制到集群中的其他节点。Elasticsearch 也是异步和并发的，这意味着这些复制请求被并行发送，并且到达目的地时也许 顺序是乱的 。 Elasticsearch 需要一种方法确保文档的旧版本不会覆盖新的版本。</p><p>当我们之前讨论 index ， GET 和 delete 请求时，我们指出每个文档都有一个 _version （版本）号，当文档被修改时版本号递增。 Elasticsearch 使用这个 _version 号来确保变更以正确顺序得到执行。如果旧版本的文档在新版本之后到达，它可以被简单的忽略。</p><p>我们可以利用 _version 号来确保 应用中相互冲突的变更不会导致数据丢失。我们通过指定想要修改文档的 version 号来达到这个目的。 如果该版本不是当前版本号，我们的请求将会失败。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据对象&quot;&gt;&lt;a href=&quot;#数据对象&quot; class=&quot;headerlink&quot; title=&quot;数据对象&quot;&gt;&lt;/a&gt;数据对象&lt;/h2&gt;&lt;p&gt;一个文档不仅仅包含它的数据 ，也包含元数据——有关文档的信息。 三个必须的元数据元素如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;_in
      
    
    </summary>
    
      <category term="基础" scheme="http://ruanshubin.top/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="数据库" scheme="http://ruanshubin.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="基础" scheme="http://ruanshubin.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Spark与Springboot的集成</title>
    <link href="http://ruanshubin.top/2019/10/23/Spark%E4%B8%8ESpringboot%E7%9A%84%E9%9B%86%E6%88%90/"/>
    <id>http://ruanshubin.top/2019/10/23/Spark与Springboot的集成/</id>
    <published>2019-10-23T13:30:00.000Z</published>
    <updated>2019-12-25T02:40:43.568Z</updated>
    
    <content type="html"><![CDATA[<h2 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h2><h3 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;spark-springboot&lt;/artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.ruanshubin.spark&lt;/groupId&gt;</span><br><span class="line">        &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;spark-demo&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">            &lt;exclusions&gt;</span><br><span class="line">                &lt;exclusion&gt;</span><br><span class="line">                    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                    &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;</span><br><span class="line">                &lt;/exclusion&gt;</span><br><span class="line">            &lt;/exclusions&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--ELK系统--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;net.logstash.logback&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;logstash-logback-encoder&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.3&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;log4j-over-slf4j&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;logback-core&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span><br><span class="line">            &lt;exclusions&gt;</span><br><span class="line">                &lt;exclusion&gt;</span><br><span class="line">                    &lt;artifactId&gt;log4j-to-slf4j&lt;/artifactId&gt;</span><br><span class="line">                    &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;</span><br><span class="line">                &lt;/exclusion&gt;</span><br><span class="line">            &lt;/exclusions&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--kafka--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--ElasticSearch--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--服务监控--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.postgresql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;postgresql&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--spark--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spark-core_2.11&lt;/artifactId&gt;</span><br><span class="line">            &lt;exclusions&gt;</span><br><span class="line">                &lt;exclusion&gt;</span><br><span class="line">                    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">                    &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</span><br><span class="line">                &lt;/exclusion&gt;</span><br><span class="line">            &lt;/exclusions&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spark-sql_2.11&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spark-catalyst_2.11&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--test--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;id&gt;copy-resources&lt;/id&gt;</span><br><span class="line">                        &lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;copy-resources&lt;/goal&gt;</span><br><span class="line">                        &lt;/goals&gt;</span><br><span class="line">                        &lt;configuration&gt;</span><br><span class="line">                            &lt;outputDirectory&gt;$&#123;project.build.directory&#125;/conf&lt;/outputDirectory&gt;</span><br><span class="line">                            &lt;resources&gt;</span><br><span class="line">                                &lt;resource&gt;</span><br><span class="line">                                    &lt;directory&gt;src/main/resources&lt;/directory&gt;</span><br><span class="line">                                    &lt;filtering&gt;false&lt;/filtering&gt;</span><br><span class="line">                                &lt;/resource&gt;</span><br><span class="line">                            &lt;/resources&gt;</span><br><span class="line">                        &lt;/configuration&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">                &lt;/executions&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;id&gt;copy&lt;/id&gt;</span><br><span class="line">                        &lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;copy-dependencies&lt;/goal&gt;</span><br><span class="line">                        &lt;/goals&gt;</span><br><span class="line">                        &lt;configuration&gt;</span><br><span class="line">                            &lt;includeScope&gt;runtime&lt;/includeScope&gt;</span><br><span class="line">                            &lt;excludeScope&gt;provided,test&lt;/excludeScope&gt;</span><br><span class="line">                            &lt;excludeArtifactIds&gt;junit,dbunit,mockito-all&lt;/excludeArtifactIds&gt;</span><br><span class="line">                            &lt;excludeTransitive&gt;false&lt;/excludeTransitive&gt;</span><br><span class="line">                            &lt;outputDirectory&gt;</span><br><span class="line">                                $&#123;project.build.directory&#125;/lib</span><br><span class="line">                            &lt;/outputDirectory&gt;</span><br><span class="line">                        &lt;/configuration&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">                &lt;/executions&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;dependencies&gt;</span><br><span class="line">                    &lt;dependency&gt;</span><br><span class="line">                        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                        &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">                        &lt;version&gt;$&#123;spring.boot.version&#125;&lt;/version&gt;</span><br><span class="line">                    &lt;/dependency&gt;</span><br><span class="line">                &lt;/dependencies&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;finalName&gt;tcd-data-manager-1.0-jar-with-dependencies&lt;/finalName&gt;</span><br><span class="line">                    &lt;keepDependenciesWithProvidedScope&gt;true&lt;/keepDependenciesWithProvidedScope&gt;</span><br><span class="line">                    &lt;createDependencyReducedPom&gt;true&lt;/createDependencyReducedPom&gt;</span><br><span class="line">                    &lt;filters&gt;</span><br><span class="line">                        &lt;filter&gt;</span><br><span class="line">                            &lt;artifact&gt;*:*&lt;/artifact&gt;</span><br><span class="line">                            &lt;excludes&gt;</span><br><span class="line">                                &lt;exclude&gt;META-INF/*.SF&lt;/exclude&gt;</span><br><span class="line">                                &lt;exclude&gt;META-INF/*.DSA&lt;/exclude&gt;</span><br><span class="line">                                &lt;exclude&gt;META-INF/*.RSA&lt;/exclude&gt;</span><br><span class="line">                            &lt;/excludes&gt;</span><br><span class="line">                        &lt;/filter&gt;</span><br><span class="line">                    &lt;/filters&gt;</span><br><span class="line">                    &lt;artifactSet&gt;</span><br><span class="line">                        &lt;excludes&gt;</span><br><span class="line">                            &lt;exclude&gt;org.apache.spark:*&lt;/exclude&gt;</span><br><span class="line">                        &lt;/excludes&gt;</span><br><span class="line">                    &lt;/artifactSet&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;shade&lt;/goal&gt;</span><br><span class="line">                        &lt;/goals&gt;</span><br><span class="line">                        &lt;configuration&gt;</span><br><span class="line">                            &lt;transformers&gt;</span><br><span class="line">                                &lt;transformer implementation=&quot;org.springframework.boot.maven.PropertiesMergingResourceTransformer&quot;&gt;</span><br><span class="line">                                    &lt;resource&gt;META-INF/spring.factories&lt;/resource&gt;</span><br><span class="line">                                &lt;/transformer&gt;</span><br><span class="line">                                &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.AppendingTransformer&quot;&gt;</span><br><span class="line">                                    &lt;resource&gt;META-INF/spring.handlers&lt;/resource&gt;</span><br><span class="line">                                &lt;/transformer&gt;</span><br><span class="line">                                &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.AppendingTransformer&quot;&gt;</span><br><span class="line">                                    &lt;resource&gt;META-INF/spring.schemas&lt;/resource&gt;</span><br><span class="line">                                &lt;/transformer&gt;</span><br><span class="line">                                &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.AppendingTransformer&quot;&gt;</span><br><span class="line">                                    &lt;resource&gt;META-INF/spring.tooling&lt;/resource&gt;</span><br><span class="line">                                &lt;/transformer&gt;</span><br><span class="line">                                &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ServicesResourceTransformer&quot;/&gt;</span><br><span class="line">                                &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&gt;</span><br><span class="line">                                    &lt;mainClass&gt;xxx.xxx.xxx.Application&lt;/mainClass&gt;</span><br><span class="line">                                &lt;/transformer&gt;</span><br><span class="line">                            &lt;/transformers&gt;</span><br><span class="line">                        &lt;/configuration&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">                &lt;/executions&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;appendAssemblyId&gt;false&lt;/appendAssemblyId&gt;</span><br><span class="line">                    &lt;descriptors&gt;</span><br><span class="line">                        &lt;descriptor&gt;src/assembly/assembly.xml&lt;/descriptor&gt;</span><br><span class="line">                    &lt;/descriptors&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;id&gt;make-assembly&lt;/id&gt;</span><br><span class="line">                        &lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;single&lt;/goal&gt;</span><br><span class="line">                        &lt;/goals&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">                &lt;/executions&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><h3 id="assembly-xml"><a href="#assembly-xml" class="headerlink" title="assembly.xml"></a>assembly.xml</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;assembly xmlns=&quot;http://maven.apache.org/ASSEMBLY/2.0.0&quot;</span><br><span class="line">          xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">          xsi:schemaLocation=&quot;http://maven.apache.org/ASSEMBLY/2.0.0 http://maven.apache.org/xsd/assembly-2.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;id&gt;build&lt;/id&gt;</span><br><span class="line">    &lt;formats&gt;</span><br><span class="line">        &lt;format&gt;tar.gz&lt;/format&gt;</span><br><span class="line">    &lt;/formats&gt;</span><br><span class="line">    &lt;includeBaseDirectory&gt;false&lt;/includeBaseDirectory&gt;</span><br><span class="line">    &lt;fileSets&gt;</span><br><span class="line">        &lt;fileSet&gt;</span><br><span class="line">            &lt;directory&gt;target&lt;/directory&gt;</span><br><span class="line">            &lt;includes&gt;</span><br><span class="line">                &lt;include&gt;*dependencies.jar&lt;/include&gt;</span><br><span class="line">                &lt;include&gt;/conf/**&lt;/include&gt;</span><br><span class="line">            &lt;/includes&gt;</span><br><span class="line">            &lt;outputDirectory&gt;/&lt;/outputDirectory&gt;</span><br><span class="line">            &lt;directoryMode&gt;0755&lt;/directoryMode&gt;</span><br><span class="line">        &lt;/fileSet&gt;</span><br><span class="line">    &lt;/fileSets&gt;</span><br><span class="line">&lt;/assembly&gt;</span><br></pre></td></tr></table></figure><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><h3 id="自定义Spark的依赖包"><a href="#自定义Spark的依赖包" class="headerlink" title="自定义Spark的依赖包"></a>自定义Spark的依赖包</h3><blockquote><p>启动Spark任务时，在没有配置spark.yarn.archive或者spark.yarn.jars时， 会看到不停地上传jar，非常耗时；使用spark.yarn.archive可以大大地减少任务的启动时间；同时，也可以在不污染原有spark环境的前提下，解决包冲突的问题。整个处理过程如下:</p></blockquote><ul><li>在本地创建zip文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hzlishuming@hadoop691:~/env/spark$ cd jars/</span><br><span class="line">hzlishuming@hadoop691:~/env/spark$ zip spark2.1.1-hadoop2.7.3.zip ./*</span><br></pre></td></tr></table></figure><ul><li>上传至HDFS并更改权限</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hzlishuming@hadoop691:~/env/spark$ /usr/ndp/current/hdfs_client/bin/hdfs dfs -mkdir /tmp/spark-archive</span><br><span class="line">hzlishuming@hadoop691:~/env/spark$ /usr/ndp/current/hdfs_client/bin/hdfs dfs -put ./spark2.1.1-hadoop2.7.3.zip /tmp/spark-archive</span><br><span class="line">hzlishuming@hadoop691:~/env/spark$ /usr/ndp/current/hdfs_client/bin/hdfs dfs -chmod 775 /tmp/spark-archive/spark2.1.1-hadoop2.7.3.zip</span><br></pre></td></tr></table></figure><ul><li>配置spark-defaut.conf</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spark.yarn.archive hdfs:///tmp/spark-archive/spark2.1.1-hadoop2.7.3.zip</span><br></pre></td></tr></table></figure><p>也可以在提交任务的时候指定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">./bin/spark-submit \</span><br><span class="line">--class xxx.xxx.xxx.Application \</span><br><span class="line">--name XXXApplication \</span><br><span class="line">--master yarn \</span><br><span class="line">--deploy-mode cluster \</span><br><span class="line">--queue root.root \</span><br><span class="line">--driver-cores 1 \</span><br><span class="line">--driver-memory 2g \</span><br><span class="line">--executor-cores 4 \</span><br><span class="line">--executor-memory 2g \</span><br><span class="line">--num-executors 4 \</span><br><span class="line">--driver-java-options &apos;-XX:MaxDirectMemorySize=128M -XX:NewRatio=1 -XX:SurvivorRatio=8 -XX:TargetSurvivorRatio=90 -XX:MaxTenuringThreshold=8 -XX:+UseConcMarkSweepGC -XX:ConcGCThreads=4 -XX:ParallelGCThreads=4 -XX:+CMSScavengeBeforeRemark -XX:PretenureSizeThreshold=64m -XX:+UseCMSInitiatingOccupancyOnly -XX:CMSInitiatingOccupancyFraction=50 -XX:CMSMaxAbortablePrecleanTime=6000 -XX:+CMSParallelRemarkEnabled -XX:+ParallelRefProcEnabled -XX:-OmitStackTraceInFastThrow&apos; \</span><br><span class="line">--files hdfs://&#123;ip&#125;:&#123;port&#125;/xxx/xxx/xxx/bootstrap.yml,hdfs://&#123;ip&#125;:&#123;port&#125;/xxx/xxx/xxx/logback.xml \</span><br><span class="line">--conf spark.yarn.driver.memoryOverhead=1024  \</span><br><span class="line">--conf spark.yarn.executor.memoryOverhead=384  \</span><br><span class="line">--conf spark.yarn.archive=hdfs://&#123;ip&#125;:&#123;port&#125;/spark/yarn/spark2.4.0-hadoop2.6.0.zip \</span><br><span class="line">hdfs://&#123;ip&#125;:&#123;port&#125;/apps/xxx-jar-with-dependencies.jar</span><br></pre></td></tr></table></figure><h3 id="冲突包解决"><a href="#冲突包解决" class="headerlink" title="冲突包解决"></a>冲突包解决</h3><p>当Spark的jars目录下的相关jar包与应用中的依赖jar包冲突时，程序会报类找不到的Error。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># spark中需要替换的jar包</span><br><span class="line">snakeyaml-1.15.jar --&gt; snakeyaml-1.19.jar</span><br><span class="line">validation-api-1.1.0.Final.jar --&gt; validation-api-2.0.1.Final.jar</span><br><span class="line">gson-2.2.4.jar --&gt; gson-2.8.5.jar</span><br><span class="line"># 日志相关</span><br><span class="line">apache-log4j-extras-1.2.17.jar --&gt; log4j-over-slf4j-1.7.23.jar</span><br><span class="line">commons-logging-1.1.3.jar --&gt; logback-access-1.2.1.jar</span><br><span class="line">log4j-1.2.17.jar --&gt; logback-classic-1.2.1.jar</span><br><span class="line">slf4j-log4j12-1.7.16.jar --&gt; logback-core-1.2.1.jar</span><br><span class="line"># Swagger相关</span><br><span class="line">guava-14.0.1.jar --&gt; guava-20.0.jar</span><br><span class="line"></span><br><span class="line"># hadoop需要替换的包(不一定需要)</span><br><span class="line">rm -rf /usr/lib/LOCALCLUSTER/hadoop/share/hadoop/common/lib/slf4j-log4j12-1.7.5.jar</span><br><span class="line"></span><br><span class="line">Swagger上yarn的话，需要将SwaggerHeaderFilter的配置删除掉，否则拉取不到配置。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;项目配置&quot;&gt;&lt;a href=&quot;#项目配置&quot; class=&quot;headerlink&quot; title=&quot;项目配置&quot;&gt;&lt;/a&gt;项目配置&lt;/h2&gt;&lt;h3 id=&quot;pom-xml&quot;&gt;&lt;a href=&quot;#pom-xml&quot; class=&quot;headerlink&quot; title=&quot;pom
      
    
    </summary>
    
      <category term="大数据" scheme="http://ruanshubin.top/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="大数据" scheme="http://ruanshubin.top/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Spark" scheme="http://ruanshubin.top/tags/Spark/"/>
    
  </entry>
  
  <entry>
    <title>Hive入门</title>
    <link href="http://ruanshubin.top/2019/10/22/Hive%E5%85%A5%E9%97%A8/"/>
    <id>http://ruanshubin.top/2019/10/22/Hive入门/</id>
    <published>2019-10-22T13:30:00.000Z</published>
    <updated>2019-12-25T02:36:00.995Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="Mysql安装"><a href="#Mysql安装" class="headerlink" title="Mysql安装"></a>Mysql安装</h3><ul><li>处理系统环境</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep mariadb</span><br><span class="line">rpm -e --nodeps mariadb-libs-5.5.56-2.el7.x86_64</span><br><span class="line"></span><br><span class="line"># 暂时没有用到</span><br><span class="line">groupadd mysql</span><br><span class="line">useradd -g mysql mysql -d /home/mysql</span><br><span class="line">passwd mysql</span><br><span class="line"></span><br><span class="line">mkdir /home/mysql/3306/data</span><br><span class="line">mkdir -p /home/mysql/3306/log</span><br><span class="line">mkdir -p /home/mysql/3306/tmp</span><br></pre></td></tr></table></figure><ul><li>Mysql安装</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf mysql-8.0.13-1.el7.x86_64.rpm-bundle.tar </span><br><span class="line">rpm -ivh mysql-community-common-8.0.13-1.el7.x86_64.rpm </span><br><span class="line">rpm -ivh mysql-community-libs-8.0.13-1.el7.x86_64.rpm </span><br><span class="line">rpm -ivh mysql-community-client-8.0.13-1.el7.x86_64.rpm </span><br><span class="line">rpm -ivh mysql-community-server-8.0.13-1.el7.x86_64.rpm </span><br><span class="line"></span><br><span class="line">service mysqld status</span><br><span class="line">service mysqld start</span><br><span class="line"></span><br><span class="line"># 获取初始密码</span><br><span class="line">grep &apos;temporary password&apos; /var/log/mysqld.log</span><br><span class="line"># 若在log文件中找不到初始密码</span><br><span class="line"># 说明原来的mysql未删除干净</span><br><span class="line">rm -rf /var/lib/mysql</span><br><span class="line">systemctl restart mysqld</span><br><span class="line"></span><br><span class="line"># 修改密码等级 + 修改密码</span><br><span class="line">[root@tcd-test ~]# mysql -u root -p</span><br><span class="line">Enter password: 初始密码</span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 8</span><br><span class="line">Server version: 8.0.13</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.</span><br><span class="line"></span><br><span class="line">mysql&gt; set global validate_password.policy=0;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set global validate_password.length=6;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; ALTER USER root@localhost IDENTIFIED BY &apos;123456&apos;;</span><br><span class="line">Query OK, 0 rows affected (0.11 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show global variables like &apos;%validate_password%&apos;;</span><br><span class="line">+--------------------------------------+-------+</span><br><span class="line">| Variable_name                        | Value |</span><br><span class="line">+--------------------------------------+-------+</span><br><span class="line">| validate_password.check_user_name    | ON    |</span><br><span class="line">| validate_password.dictionary_file    |       |</span><br><span class="line">| validate_password.length             | 6     |</span><br><span class="line">| validate_password.mixed_case_count   | 1     |</span><br><span class="line">| validate_password.number_count       | 1     |</span><br><span class="line">| validate_password.policy             | LOW   |</span><br><span class="line">| validate_password.special_char_count | 1     |</span><br><span class="line">+--------------------------------------+-------+</span><br><span class="line">7 rows in set (0.08 sec)</span><br><span class="line"></span><br><span class="line"># 此时，只支持host为localhost连接，需要修改远程连接权限</span><br><span class="line">mysql&gt; use mysql;</span><br><span class="line">Reading table information for completion of table and column names</span><br><span class="line">You can turn off this feature to get a quicker startup with -A</span><br><span class="line"></span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; select user, host, authentication_string from user;</span><br><span class="line">+------------------+-----------+------------------------------------------------------------------------+</span><br><span class="line">| user             | host      | authentication_string                                                  |</span><br><span class="line">+------------------+-----------+------------------------------------------------------------------------+</span><br><span class="line">| mysql.infoschema | localhost | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED |</span><br><span class="line">| mysql.session    | localhost | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED |</span><br><span class="line">| mysql.sys        | localhost | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED |</span><br><span class="line">| root             | localhost | $A$005$MBKK=R,oircXwk~2HHEqJ6ko9c/Lx1iVMERob7DXAoWi6bXyC0w19dJLnQx9 |</span><br><span class="line">+------------------+-----------+------------------------------------------------------------------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; update user set host = &quot;%&quot; where user=&apos;root&apos;;</span><br><span class="line">Query OK, 1 row affected (0.09 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; select user, host, authentication_string from user;</span><br><span class="line">+------------------+-----------+------------------------------------------------------------------------+</span><br><span class="line">| user             | host      | authentication_string                                                  |</span><br><span class="line">+------------------+-----------+------------------------------------------------------------------------+</span><br><span class="line">| root             | %         | $A$005$MBKK=R,oircXwk~2HHEqJ6ko9c/Lx1iVMERob7DXAoWi6bXyC0w19dJLnQx9 |</span><br><span class="line">| mysql.infoschema | localhost | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED |</span><br><span class="line">| mysql.session    | localhost | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED |</span><br><span class="line">| mysql.sys        | localhost | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED |</span><br><span class="line">+------------------+-----------+------------------------------------------------------------------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; grant all privileges on *.* to &apos;root&apos;@&apos;%&apos; with grant option;</span><br><span class="line">Query OK, 0 rows affected (0.13 sec)</span><br><span class="line"></span><br><span class="line">或者：GRANT ALL ON *.* TO &apos;root&apos;@&apos;%&apos;;  # 两个在不同机器上都成功过，但是不能同时成功，都试一下吧。</span><br><span class="line"></span><br><span class="line"># Navicat连接linux上的mysql报2059 Authentication plugin &apos;caching_sha2_password&apos;cannot be loaded</span><br><span class="line"># 从mysql5.7版本之后，默认采用了caching_sha2_password验证方式。</span><br><span class="line"># 在linux服务器中，开启mysql，并进入连接的数据库执行如下语句，表示采用原来的身份验证机制。</span><br><span class="line">mysql&gt; ALTER USER &apos;root&apos;@&apos;%&apos; IDENTIFIED WITH mysql_native_password BY &apos;123456&apos;;</span><br><span class="line"></span><br><span class="line">mysql&gt; use mysql;</span><br><span class="line">Reading table information for completion of table and column names</span><br><span class="line">You can turn off this feature to get a quicker startup with -A</span><br><span class="line"></span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; select user, host, authentication_string , plugin from user;</span><br><span class="line">+------------------+-----------+------------------------------------------------------------------------+-----------------------+</span><br><span class="line">| user             | host      | authentication_string                                                  | plugin                |</span><br><span class="line">+------------------+-----------+------------------------------------------------------------------------+-----------------------+</span><br><span class="line">| root             | %         | *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9                              | mysql_native_password |</span><br><span class="line">| mysql.infoschema | localhost | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED | caching_sha2_password |</span><br><span class="line">| mysql.session    | localhost | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED | caching_sha2_password |</span><br><span class="line">| mysql.sys        | localhost | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED | caching_sha2_password |</span><br><span class="line">+------------------+-----------+------------------------------------------------------------------------+-----------------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h3 id="Hive安装"><a href="#Hive安装" class="headerlink" title="Hive安装"></a>Hive安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line">export HIVE_HOME=/usr/software/hive/apache-hive-2.3.4-bin</span><br><span class="line">export PATH=$PATH:$HIVE_HOME/bin</span><br><span class="line"></span><br><span class="line">source /etc/profile</span><br><span class="line"></span><br><span class="line"># 此时执行hive的show databases会报错，是从Hive 2.1版本开始,我们需要先运行schematool 命令来执行初始化操作</span><br><span class="line">schematool -dbType derby -initSchema</span><br><span class="line"></span><br><span class="line"># 启动hive之前请确保hadoop启动起来</span><br><span class="line"></span><br><span class="line"># 使用默认数据库derby，执行hive的show databases仍然会报错，未解决。</span><br><span class="line"></span><br><span class="line"># 试着用mysql数据库</span><br><span class="line"></span><br><span class="line">cp hive-env.sh.template hive-env.sh</span><br><span class="line">cp hive-default.xml.template hive-site.xml</span><br><span class="line"></span><br><span class="line">vim hive-site.xml</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;</span><br><span class="line">&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;hive.default.fileformat&lt;/name&gt;</span><br><span class="line">&lt;value&gt;TextFile&lt;/value&gt;</span><br><span class="line">&lt;description&gt;Default file format for CREATE TABLE statement. Options are TextFile and SequenceFile. Users can explicitly say CREATE TABLE ... STORED AS &amp;lt;TEXTFILE|SEQUENCEFILE&amp;gt; to override&lt;/description&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt;</span><br><span class="line">&lt;value&gt;jdbc:mysql://localhost:3306/hive?createDatabaseIfNotExist=true&amp;amp;useSSL=false&lt;/value&gt;</span><br><span class="line">&lt;description&gt;JDBC connect string for a JDBC metastore&lt;/description&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;/name&gt;</span><br><span class="line">&lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt;</span><br><span class="line">&lt;description&gt;Driver class name for a JDBC metastore&lt;/description&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;javax.jdo.option.ConnectionUserName&lt;/name&gt;</span><br><span class="line">&lt;value&gt;root&lt;/value&gt;</span><br><span class="line">&lt;description&gt;username to use against metastore database&lt;/description&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;javax.jdo.option.ConnectionPassword&lt;/name&gt;</span><br><span class="line">&lt;value&gt;123456&lt;/value&gt;</span><br><span class="line">&lt;description&gt;password to use against metastore database&lt;/description&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">  </span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line"></span><br><span class="line">vim hive-env.sh</span><br><span class="line"></span><br><span class="line">HADOOP_HOME=/usr/software/hadoop2.8.5/hadoop-2.8.5</span><br><span class="line">export HIVE_CONF_DIR=/usr/software/hive/apache-hive-2.3.4-bin/conf</span><br><span class="line">export HIVE_AUX_JARS_PATH=/usr/software/hive/apache-hive-2.3.4-bin/lib</span><br><span class="line"></span><br><span class="line"># 将mysql连接jar放到/hive/lib下</span><br><span class="line"></span><br><span class="line"># 初始化mysql数据库</span><br><span class="line">schematool -dbType mysql -initSchema</span><br><span class="line">schematool -dbType postgres -initSchema</span><br><span class="line"></span><br><span class="line">hive&gt; show databases;</span><br><span class="line">Loading class `com.mysql.jdbc.Driver&apos;. This is deprecated. The new driver class is `com.mysql.cj.jdbc.Driver&apos;. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary.</span><br><span class="line">OK</span><br><span class="line">default</span><br><span class="line">Time taken: 9.951 seconds, Fetched: 1 row(s)</span><br><span class="line"></span><br><span class="line"># 存在一个默认数据库default,但是在hdfs中并没有/user/hive/warehouse，这个目录属于顶层目录，即数据仓库；</span><br><span class="line"># 此时，在hive shell中</span><br><span class="line">create database test;</span><br><span class="line"># 此时，/user/hive/warehouse会被创建，并有test.db文件</span><br></pre></td></tr></table></figure><h3 id="hive-in-spark"><a href="#hive-in-spark" class="headerlink" title="hive in spark"></a>hive in spark</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">配置步骤：</span><br><span class="line"></span><br><span class="line">1.复制postgresql-42.2.5.jar文件到spark home路径下jars文件夹中</span><br><span class="line"></span><br><span class="line">2. 使用hadoop fs命令创建hive数仓目录</span><br><span class="line">/usr/lib/LOCALCLUSTER/SERVICE-HADOOP-ec48e21ba173412995c6eff698cca573/bin/hadoop fs -mkdir -p /hive/warehouse</span><br><span class="line"></span><br><span class="line">3. spark 配置路径下配置hive-site.xml文件</span><br><span class="line">配置内容参考当前目录下hive-site.xml</span><br><span class="line"></span><br><span class="line">3.在postgresql中新建名为hivedb的数据库；（hivedb是在hive-site.xml文件中配置的）</span><br><span class="line"></span><br><span class="line">验证配置是否正确</span><br><span class="line">1. 以yran-client模式启动hive thriftserver：</span><br><span class="line">$Spark-Home/sbin/start-thriftserver.sh \</span><br><span class="line">--master yarn-client \</span><br><span class="line">--driver-cores 1 \</span><br><span class="line">--conf spark.driver.memory=2G \</span><br><span class="line">--queue root.jobs \</span><br><span class="line">--num-executors 2 \</span><br><span class="line">--executor-memory 2g \</span><br><span class="line">--conf spark.yarn.executor.memoryOverhead=1024</span><br><span class="line"></span><br><span class="line">./start-thriftserver.sh \</span><br><span class="line">--master yarn-client \</span><br><span class="line">--driver-cores 2 \</span><br><span class="line">--conf spark.driver.memory=1G \</span><br><span class="line">--queue root.jobs \</span><br><span class="line">--num-executors 2 \</span><br><span class="line">--executor-memory 1g \</span><br><span class="line">--conf spark.yarn.executor.memoryOverhead=1024</span><br><span class="line"></span><br><span class="line">2. 使用beeline工具操作数据库：</span><br><span class="line">$Spark-Home/bin/beeline</span><br><span class="line"></span><br><span class="line">3. 之后执行：</span><br><span class="line">!connect jdbc:hive2://10.194.224.112:10000</span><br><span class="line">连续回车即可</span><br><span class="line"></span><br><span class="line">----------------------------------------------</span><br><span class="line">SQL 建表操作</span><br><span class="line"></span><br><span class="line">1. 使用CSV等文本格式存储</span><br><span class="line">create table test (id int , name string) ROW FORMAT DELIMITED FIELDS TERMINATED BY &apos;|&apos; STORED AS TEXTFILE ;</span><br><span class="line">INSERT INTO test VALUES(1,&apos;a&apos;);</span><br><span class="line"></span><br><span class="line">2. 使用ORC格式存储数据</span><br><span class="line">create table if not exists test_orc(</span><br><span class="line">  id string,</span><br><span class="line">  name string,</span><br><span class="line">  comment string</span><br><span class="line">) STORED AS ORC;</span><br><span class="line"></span><br><span class="line">INSERT INTO test_orc VALUES(1,&apos;a&apos;,&apos;abc&apos;);</span><br><span class="line"></span><br><span class="line">3. 使用parquet格式存储数据</span><br><span class="line">create table if not exists test_parquet(</span><br><span class="line">  id string,</span><br><span class="line">  name string,</span><br><span class="line">  comment string</span><br><span class="line">) STORED AS PARQUET;</span><br><span class="line"></span><br><span class="line">INSERT INTO test_parquet VALUES(1,&apos;a&apos;,&apos;abc&apos;);</span><br><span class="line"></span><br><span class="line">--------------------------------------------</span><br><span class="line">使用insert语句添加数据，一句insert语句就会生成一个文件，大量的小文件会严重拖慢sparkSQL的查询性能，因此需要定期对文件进行合并。</span><br><span class="line"></span><br><span class="line">创建表后hdfs会生成相应目录，外部程序通过将规定格式的文件写入hdfs对应目录下，hive就可以查询到对应数据。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">上面的方式创建的是hive内部表，当执行drop table table_name;语句时，hdfs上关联的数据目录将会被删除。</span><br><span class="line">如果创建外部表则在drop table后hdfs数据目录不会被删除。</span><br><span class="line">创建外部表方式如下：</span><br><span class="line"></span><br><span class="line">create external table if not exists external_test_parquet(</span><br><span class="line">  id string,</span><br><span class="line">  name string,</span><br><span class="line">  comment string</span><br><span class="line">) stored as parquet location &apos;/hive/warehouse/external_test_parquet&apos;;</span><br><span class="line"></span><br><span class="line">其中指定的目录为hdfs路径。</span><br></pre></td></tr></table></figure><h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><h3 id="表类型"><a href="#表类型" class="headerlink" title="表类型"></a>表类型</h3><ul><li>Hive 是一个建立在hadoop文件系统上的数据仓库架构，可以用其对hdfs上数据进行分析与管理；</li><li>实际上是将hdfs上的文件映射成table（按文件格式创建table,然后hive的数据仓库会生成对应的目录，默认的仓库路径：user/hive/warehouse/tablename，目录名与这个表名相同，这时只要将符合table定义的文件加载到该目录便可通过Hql对整个目录的文件进行查询；</li><li>将数据加载到该目录可以用hdfs dfs -put 命令直接添加到该目录；</li><li>也可以通过load data local inpath ‘user/test.txt’ into table tableName,通过load命令加载数据与通过put命令加载文件的结果是一样的，即在user/hive/warehouse/tablename 目录下都会有加载进来的文件，如果用load命令加载的是hdfs上的文件则会将原hdfs目录下对应的文件移动至hive的仓库目录下）,并将这些元数据保存到关系型数据库中，元数据存储着表所对应的文件路径，表的列与分区，表创建时间，文件大小等属性；</li><li>同时支持用户运用类sql对文件进行操作，这个操作主要是查询。</li></ul><p>hive的数据模型中有4种表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Table内部表 </span><br><span class="line">External Table 外部表</span><br><span class="line">Partition分区表 </span><br><span class="line">Bucket Table 桶表</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;环境搭建&quot;&gt;&lt;a href=&quot;#环境搭建&quot; class=&quot;headerlink&quot; title=&quot;环境搭建&quot;&gt;&lt;/a&gt;环境搭建&lt;/h2&gt;&lt;h3 id=&quot;Mysql安装&quot;&gt;&lt;a href=&quot;#Mysql安装&quot; class=&quot;headerlink&quot; title=&quot;Mys
      
    
    </summary>
    
      <category term="大数据" scheme="http://ruanshubin.top/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="大数据" scheme="http://ruanshubin.top/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Hive" scheme="http://ruanshubin.top/tags/Hive/"/>
    
  </entry>
  
  <entry>
    <title>基于Zeppline进行hive表的查询</title>
    <link href="http://ruanshubin.top/2019/10/22/%E5%9F%BA%E4%BA%8EZeppline%E8%BF%9B%E8%A1%8Chive%E8%A1%A8%E7%9A%84%E6%9F%A5%E8%AF%A2/"/>
    <id>http://ruanshubin.top/2019/10/22/基于Zeppline进行hive表的查询/</id>
    <published>2019-10-22T13:30:00.000Z</published>
    <updated>2019-12-25T02:37:58.434Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>zeppelin是一个让交互式数据分析变得可行的基于网页的notebook;<br>前端提供了精美的数据可视化功能;<br>后台提供各种大数据组件的解析器，可以操作hive、sparkSQL、rdbms、es等大数据组件。</p></blockquote><p>hive数据仓库数据无法使用传统数据库连接工具查看，因此可以借助zeppelin查看hive数仓数据。</p><h2 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h2><ul><li><p>下载zeppelin： <a href="https://mirrors.tuna.tsinghua.edu.cn/apache/zeppelin/zeppelin-0.8.0/zeppelin-0.8.0-bin-all.tgz" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/apache/zeppelin/zeppelin-0.8.0/zeppelin-0.8.0-bin-all.tgz</a></p></li><li><p>修改配置文件</p></li></ul><p>解压后修改配置文件:</p><p>conf目录中:</p><ol><li><p>cp zeppelin-site.xml.template zeppelin-site.xml</p></li><li><p>cp zeppelin-env.sh.template zeppelin-env.sh</p></li><li><p>cp shiro.ini.template shiro.ini</p></li><li><p>将hive的依赖包拷贝到 interpreter/jdbc 目录下:</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp $Spark-Home/jars /tools/zeppeline/zeppelin-0.8.0-bin-all/interpreter/jdbc</span><br></pre></td></tr></table></figure><ol><li><p>启动<br>bin/zeppelin-daemon.sh start</p></li><li><p>浏览器访问 8080</p></li></ol><p>使用shiro.ini中配置的用户名密码登录</p><ol><li>创建hive interpreter</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># create--填写Interpreter Name--Interpreter group选择jdbc</span><br><span class="line"># 在配置里增加两项内容</span><br><span class="line">default.driver：org.apache.hive.jdbc.HiveDriver</span><br><span class="line">default.url：jdbc:hive2://&#123;ip&#125;:10000</span><br></pre></td></tr></table></figure><ol><li>创建notebook并使用hive interpreter</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;zeppelin是一个让交互式数据分析变得可行的基于网页的notebook;&lt;br&gt;前端提供了精美的数据可视化功能;&lt;br&gt;后台提供各种大数据组件的解析器，可以操作hive、sparkSQL、rdbms、es等大数据组件。&lt;/p&gt;
&lt;/blockq
      
    
    </summary>
    
      <category term="大数据" scheme="http://ruanshubin.top/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="大数据" scheme="http://ruanshubin.top/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Hive" scheme="http://ruanshubin.top/tags/Hive/"/>
    
  </entry>
  
  <entry>
    <title>Yarn的基本架构</title>
    <link href="http://ruanshubin.top/2019/10/21/Yarn%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84/"/>
    <id>http://ruanshubin.top/2019/10/21/Yarn基本架构/</id>
    <published>2019-10-21T13:30:00.000Z</published>
    <updated>2019-12-25T02:29:44.054Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><p>1.应用程序通client类向ResourceManager提交程序，Application运行所需要的入口类，出口类，运行的命令，运行所需要的cpu资源和内存资源，jar包资源。</p><p>2.ResourceManager通过内部的调度器，去集群中寻找资源，找到资源后与NodeManager进行通信，去启动相应的ApplicationMaster,AM会按照事先的规划将任务切分为许多的task任务。</p><p>3.ApplicationMaster之后向ResourceManager进行申请资源，RM会将资源进行动态的分配。</p><p>4.ApplicationMaster获得资源后会再将资源进一步分配给内部的task.</p><p>5.之后，ApplicationMaster会向NodeManager进行请求，让NM给启动起来Task,NM会把Task封装到Container中允许。</p><p><img src="/2019/10/21/Yarn基本架构/1.jpg" alt=""></p><h3 id="ResourceManager"><a href="#ResourceManager" class="headerlink" title="ResourceManager"></a>ResourceManager</h3><p>整个集群只有一个，负责集群资源的统一管理和调度。</p><ul><li>处理客户端请求</li><li>启动监控ApplicationMaster</li><li>监控NodeManager</li><li>资源分配与调度</li></ul><p><img src="/2019/10/21/Yarn基本架构/2.jpg" alt=""></p><h4 id="用户交互"><a href="#用户交互" class="headerlink" title="用户交互"></a>用户交互</h4><p>YARN分别针对普通用户，管理员和Web提供了三种对外服务，分别对应ClientRMService、AdminService和WebApp：</p><ul><li>ClientRMService</li></ul><p>ClientRMService是为普通用户提供的服务，它会处理来自客户端各种RPC请求，比如提交应用程序、终止应用程序，获取应用程序运行状态等。</p><ul><li>AdminService</li></ul><p>YARN为管理员提供了一套独立的服务接口，以防止大量的普通用户请求使管理员发送的管理命令饿死，管理员可通过这些接口管理集群，比如动态更新节点列表，更新ACL列表，更新队列信息等。</p><ul><li>WebApp</li></ul><p>为了更加友好地展示集群资源使用情况和应用程序运行状态等信息，YARN对外提供了一个Web 界面，这一部分是YARN仿照haml（<a href="http://haml.info/" target="_blank" rel="noopener">http://haml.info/</a>）开发的一个轻量级嵌入式Web框架。具体讨论见：<a href="https://issues.apache.org/jira/browse/MAPREDUCE-2399" target="_blank" rel="noopener">https://issues.apache.org/jira/browse/MAPREDUCE-2399</a></p><h4 id="NM管理"><a href="#NM管理" class="headerlink" title="NM管理"></a>NM管理</h4><ul><li>NMLivelinessMonitor</li></ul><p>监控NM是否活着，如果一个NodeManager在一定时间（默认为10min）内未汇报心跳信息，则认为它死掉了，会将其从集群中移除。</p><ul><li>NodesListManager</li></ul><p>维护正常节点和异常节点列表，管理exlude（类似于黑名单）和inlude（类似于白名单）节点列表，这两个列表均是在配置文件中设置的，可以动态加载。</p><ul><li>ResourceTrackerService</li></ul><p>处理来自NodeManager的请求，主要包括两种请求：注册和心跳，其中，注册是NodeManager启动时发生的行为，请求包中包含节点ID，可用的资源上限等信息，而心跳是周期性 行为，包含各个Container运行状态，运行的Application列表、节点健康状况（可通过一个脚本设置），而ResourceTrackerService则为NM返回待释放的Container列表、Application列表等。</p><h4 id="AM管理"><a href="#AM管理" class="headerlink" title="AM管理"></a>AM管理</h4><ul><li>AMLivelinessMonitor</li></ul><p>监控AM是否活着，如果一个ApplicationMaster在一定时间（默认为10min）内未汇报心跳信息，则认为它死掉了，它上面所有正在运行的Container将被认为死亡，AM本身会被重新分配到另外一个节点上（用户可指定每个ApplicationMaster的尝试次数，默认是1次）执行。</p><ul><li>ApplicationMasterLauncher</li></ul><p>与NodeManager通信，要求它为某个应用程序启动ApplicationMaster。</p><ul><li>ApplicationMasterService</li></ul><p>处理来自ApplicationMaster的请求，主要包括两种请求：注册和心跳，其中，注册是ApplicationMaster启动时发生的行为，包括请求包中包含所在节点，RPC端口号和tracking URL等信息，而心跳是周期性 行为，包含请求资源的类型描述、待释放的Container列表等，而AMS则为之返回新分配的Container、失败的Container等信息。</p><h4 id="Application管理"><a href="#Application管理" class="headerlink" title="Application管理"></a>Application管理</h4><ul><li>ApplicationACLsManager</li></ul><p>管理应用程序访问权限，包含两部分权限：查看和修改，查看主要指查看应用程序基本信息，而修改则主要是修改应用程序优先级、杀死应用程序等。</p><ul><li>RMAppManager</li></ul><p>管理应用程序的启动和关闭。</p><ul><li>ContainerAllocationExpirer</li></ul><p>YARN不允许AM获得Container后长时间不对其使用，因为这会降低整个集群的利用率。当AM收到RM新分配的一个Container后，必须在一定的时间（默认为10min）内在对应的NM上启动该Container， 否则，RM会回收该Container。</p><h4 id="安全管理"><a href="#安全管理" class="headerlink" title="安全管理"></a>安全管理</h4><p>ResourceManage自带了非常全面的权限管理机制，主要由ClientToAMSecretManager、ContainerTokenSecretManager、ApplicationTokenSecretManager等模块完成。</p><h4 id="资源分配"><a href="#资源分配" class="headerlink" title="资源分配"></a>资源分配</h4><p>ResourceScheduler是资源调度器，它按照一定的约束条件（比如队列容量限制等）将集群中的资源分配给各个应用程序，当前主要考虑内存资源，在3.0版本中将会考虑CPU（<a href="https://issues.apache.org/jira/browse/YARN-2" target="_blank" rel="noopener">https://issues.apache.org/jira/browse/YARN-2</a>）。ResourceScheduler是一个插拔式模块，默认是FIFO实现，YARN还提供了Fair Scheduler和Capacity Scheduler两个多租户调度器。</p><p>参考资料：<a href="http://hortonworks.com/blog/apache-hadoop-yarn-resourcemanager/" target="_blank" rel="noopener">http://hortonworks.com/blog/apache-hadoop-yarn-resourcemanager/</a></p><h3 id="NodeManager"><a href="#NodeManager" class="headerlink" title="NodeManager"></a>NodeManager</h3><p>整个集群存在多个，负责单节点资源管理与使用。</p><ul><li>处理来自ResourceManager的命令</li><li>处理来自ApplicationMaster的命令</li></ul><h3 id="ApplicationMaster"><a href="#ApplicationMaster" class="headerlink" title="ApplicationMaster"></a>ApplicationMaster</h3><p>每一个应用有一个，负责应用程序的管理。</p><p>数据切分，申请资源，任务监控，任务容错。</p><h3 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h3><p>对任务环境的抽象。</p><p>封装了CPU、Memory等资源的一个容器，相当于是一个任务运行环境的抽象。</p><h2 id="Yarn的容错性"><a href="#Yarn的容错性" class="headerlink" title="Yarn的容错性"></a>Yarn的容错性</h2><p>ResourceManager存在单点故障，基于Zookeeper实现HA,通常任务失败后，RM将失败的任务告诉AM,RM负责任务的重启,AM来决定如何处理失败的任务。RMAppMaster会保存已经运行完成的Task,重启后无需重新运行。</p><h2 id="Yarn资源调度框架与调度器"><a href="#Yarn资源调度框架与调度器" class="headerlink" title="Yarn资源调度框架与调度器"></a>Yarn资源调度框架与调度器</h2><p>Yarn采用的双层调度框架，RM将资源分配给AM,AM再将资源进一步分配给Task,资源不够时会为TASK预留，直到资源充足。在Hadoop1.0中我们分配资源通过slot实现，但是在Yarn中，直接分配资源。</p><p>资源调度器有：FIFO,Fair scheduler,Capacity scheduler</p><p>Yarn支持CPU和内存两种资源隔离，内存是决定生死的资源，CPU是影响快慢的资源，内存隔离采用的是基于线程监控和基于Cgroup的方案。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本流程&quot;&gt;&lt;a href=&quot;#基本流程&quot; class=&quot;headerlink&quot; title=&quot;基本流程&quot;&gt;&lt;/a&gt;基本流程&lt;/h2&gt;&lt;p&gt;1.应用程序通client类向ResourceManager提交程序，Application运行所需要的入口类，出口类，运行
      
    
    </summary>
    
      <category term="大数据" scheme="http://ruanshubin.top/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="大数据" scheme="http://ruanshubin.top/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Yarn" scheme="http://ruanshubin.top/tags/Yarn/"/>
    
  </entry>
  
  <entry>
    <title>Yarn的调度器--Scheduler探究</title>
    <link href="http://ruanshubin.top/2019/10/21/Yarn%E7%9A%84%E8%B0%83%E5%BA%A6%E5%99%A8--Scheduler%E6%8E%A2%E7%A9%B6/"/>
    <id>http://ruanshubin.top/2019/10/21/Yarn的调度器--Scheduler探究/</id>
    <published>2019-10-21T13:30:00.000Z</published>
    <updated>2019-12-25T02:28:49.062Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在Yarn体系中，Scheduler负责为Application分配资源，按照调度策略可分为以下3种：</p><ul><li>FIFO Scheduler</li><li>Capacity Scheduler</li><li>Fair Scheduler</li></ul><p><img src="/2019/10/21/Yarn的调度器--Scheduler探究/1.jpg" alt=""></p><p>下面具体介绍上述3种调度器：</p><h2 id="FIFO-Scheduler"><a href="#FIFO-Scheduler" class="headerlink" title="FIFO Scheduler"></a>FIFO Scheduler</h2><p>顾名思义，该调度器是按照应用的提交顺序分配资源的，先进先出，优先满足先到达的应用，待前面的应用所需资源满足后再分配后面的应用。</p><p>在共享集群模式下，该模式会存在应用饥饿问题，即小应用会被前面的大应用阻塞，当前面存在某个大应用耗尽所有资源，会导致后续的应用永远得不到执行。</p><h2 id="Capacity-Scheduler"><a href="#Capacity-Scheduler" class="headerlink" title="Capacity Scheduler"></a>Capacity Scheduler</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>由引言中的图易知，Capacity调度器将整个集群的资源分为多个Queue，每个Queue可占用一定的集群资源，应用可提交到指定的Queue上，在每个Queue内部，执行的仍然是FIFO策略。</p><p>当某个Queue因为被提交了多个Application而导致资源告急时，Capacity调度器扔可能分配部分资源给当前队列，但前提是其他队列有剩余，或其他队列释放了某些Container资源。</p><p>为避免某队列占用过多的空闲资源，导致其他队列无法使用这些空闲资源，建议设置队列的最大资源使用量。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>Capacity Schduler是YARN中默认的资源调度器。</p><p>在Capacity Scheduler的配置文件中，队列queueX的参数Y的配置名称为yarn.scheduler.capacity.queueX.Y，为了简单起见，我们记为Y，则每个队列可以配置的参数如下：</p><h4 id="资源分配相关参数"><a href="#资源分配相关参数" class="headerlink" title="资源分配相关参数"></a>资源分配相关参数</h4><ul><li>capacity</li></ul><p>队列的资源容量（百分比）。 当系统非常繁忙时，应保证每个队列的容量得到满足，而如果每个队列应用程序较少，可将剩余资源共享给其他队列。注意，所有队列的容量之和应小于100。</p><ul><li>maximum-capacity</li></ul><p>队列的资源使用上限（百分比）。由于存在资源共享，因此一个队列使用的资源量可能超过其容量，而最多使用资源量可通过该参数限制。</p><ul><li>minimum-user-limit-percent</li></ul><p>每个用户最低资源保障（百分比）。任何时刻，一个队列中每个用户可使用的资源量均有一定的限制。当一个队列中同时运行多个用户的应用程序时中，每个用户的使用资源量在一个最小值和最大值之间浮动，其中，最小值取决于正在运行的应用程序数目，而最大值则由minimum-user-limit-percent决定。比如，假设minimum-user-limit-percent为25。当两个用户向该队列提交应用程序时，每个用户可使用资源量不能超过50%，如果三个用户提交应用程序，则每个用户可使用资源量不能超多33%，如果四个或者更多用户提交应用程序，则每个用户可用资源量不能超过25%。</p><ul><li>user-limit-factor</li></ul><p>每个用户最多可使用的资源量（百分比）。比如，假设该值为30，则任何时刻，每个用户使用的资源量不能超过该队列容量的30%。</p><h4 id="限制应用程序数目相关参数"><a href="#限制应用程序数目相关参数" class="headerlink" title="限制应用程序数目相关参数"></a>限制应用程序数目相关参数</h4><ul><li>maximum-applications</li></ul><p>集群或者队列中同时处于等待和运行状态的应用程序数目上限，这是一个强限制，一旦集群中应用程序数目超过该上限，后续提交的应用程序将被拒绝，默认值为10000。所有队列的数目上限可通过参数yarn.scheduler.capacity.maximum-applications设置（可看做默认值），而单个队列可通过参数yarn.scheduler.capacity.<queue-path>.maximum-applications设置适合自己的值。</queue-path></p><ul><li>maximum-am-resource-percent</li></ul><p>集群中用于运行应用程序ApplicationMaster的资源比例上限，该参数通常用于限制处于活动状态的应用程序数目。该参数类型为浮点型，默认是0.1，表示10%。所有队列的ApplicationMaster资源比例上限可通过参数yarn.scheduler.capacity. maximum-am-resource-percent设置（可看做默认值），而单个队列可通过参数yarn.scheduler.capacity.<queue-path>. maximum-am-resource-percent设置适合自己的值。</queue-path></p><h4 id="队列访问和权限控制参数"><a href="#队列访问和权限控制参数" class="headerlink" title="队列访问和权限控制参数"></a>队列访问和权限控制参数</h4><ul><li>state</li></ul><p>队列状态可以为STOPPED或者RUNNING，如果一个队列处于STOPPED状态，用户不可以将应用程序提交到该队列或者它的子队列中，类似的，如果ROOT队列处于STOPPED状态，用户不可以向集群中提交应用程序，但正在运行的应用程序仍可以正常运行结束，以便队列可以优雅地退出。</p><ul><li>acl_submit_applications</li></ul><p>限定哪些用户/用户组可向给定队列中提交应用程序。需要注意的是，该属性具有继承性，即如果一个用户可以向某个队列中提交应用程序，则它可以向它的所有子队列中提交应用程序。</p><ul><li>acl_administer_queue</li></ul><p>为队列指定一个管理员，该管理员可控制该队列的所有应用程序，比如杀死任意一个应用程序等。同样，该属性具有继承性，如果一个用户可以向某个队列中提交应用程序，则它可以向它的所有子队列中提交应用程序。</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;yarn.scheduler.capacity.maximum-applications&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;10000&lt;/value&gt;</span><br><span class="line">    &lt;description&gt;最多可同时处于等待和运行状态的应用程序数目&lt;/description&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line"> </span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;yarn.scheduler.capacity.maximum-am-resource-percent&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;0.1&lt;/value&gt;</span><br><span class="line">    &lt;description&gt;集群中可用于运行application master的资源比例上限，这通常用于限制并发运行的应用程序数目。&lt;/description&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line"> </span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;yarn.scheduler.capacity.root.queues&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;default&lt;/value&gt;</span><br><span class="line">    &lt;description&gt;root队列的所有子队列，该实例中只有一个&lt;/description&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line"> </span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;yarn.scheduler.capacity.root.default.capacity&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;100&lt;/value&gt;</span><br><span class="line">    &lt;description&gt;default队列的资源容量&lt;/description&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line"> </span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;yarn.scheduler.capacity.root.default.user-limit-factor&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;1&lt;/value&gt;</span><br><span class="line">    &lt;description&gt;</span><br><span class="line">     每个用户可使用的资源限制</span><br><span class="line">    &lt;/description&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line"> </span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;yarn.scheduler.capacity.root.default.maximum-capacity&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;100&lt;/value&gt;</span><br><span class="line">    &lt;description&gt;</span><br><span class="line">      Default队列可使用的资源上限. </span><br><span class="line">    &lt;/description&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line"> </span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;yarn.scheduler.capacity.root.default.state&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;RUNNING&lt;/value&gt;</span><br><span class="line">    &lt;description&gt;</span><br><span class="line">     Default队列的状态，可以是RUNNING或者STOPPED.</span><br><span class="line">    &lt;/description&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line"> </span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;yarn.scheduler.capacity.root.default.acl_submit_applications&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;*&lt;/value&gt;</span><br><span class="line">    &lt;description&gt;</span><br><span class="line">      限制哪些用户可向default队列中提交应用程序.</span><br><span class="line">    &lt;/description&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line"> </span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;yarn.scheduler.capacity.root.default.acl_administer_queue&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;*&lt;/value&gt;</span><br><span class="line">    &lt;description&gt;</span><br><span class="line">  限制哪些用户可管理default队列中的应用程序，“*”表示任意用户</span><br><span class="line">&lt;/description&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line"> </span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;yarn.scheduler.capacity.node-locality-delay&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;-1&lt;/value&gt;</span><br><span class="line">    &lt;description&gt;调度器尝试调度一个rack-local container之前，最多跳过的调度机会，通常而言，该值被设置成集群中机架数目，默认情况下为-1，表示不启用该功能。</span><br><span class="line">    &lt;/description&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><h2 id="Fair-Scheduler"><a href="#Fair-Scheduler" class="headerlink" title="Fair Scheduler"></a>Fair Scheduler</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>Fair调度器的设计目标是为所有的应用分配公平的资源（对公平的定义可以通过参数来设置），用户在各自队列运行中逐渐资源变得平分。</p><p>假如现在存在大、小2个任务，当提交大任务时，其会获取所有的系统资源，大任务执行期间，当小任务提交时，大任务会释放出一半数量的Container供小任务使用，待小任务执行完毕后，小任务会释放其所占有的资源，此时大任务重新获取到系统的所有资源。</p><p>因为小任务需要等待大任务释放出Container，所以从小任务提交到获取到资源会有一定的延迟，但确实值得的。</p><p>该种模式下，即保证了资源的高利用率又使得晚提交的小任务获得执行的机会，不至于饿死。</p><h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><p>首先在yarn-site.xml中，将配置参数yarn.resourcemanager.scheduler.class设置为org.apache.hadoop.yarn.server.resourcemanager.scheduler.fair.FairScheduler。</p><p>Fair Scheduler的配置选项包括两部分，其中一部分在yarn-site.xml中，主要用于配置调度器级别的参数，另外一部分在一个自定义配置文件（默认是fair-scheduler.xml）中，主要用于配置各个队列的资源量、权重等信息。</p><h4 id="yarn-site-xml"><a href="#yarn-site-xml" class="headerlink" title="yarn-site.xml"></a>yarn-site.xml</h4><ul><li>yarn.scheduler.fair.allocation.file </li></ul><p>自定义XML配置文件所在位置，该文件主要用于描述各个队列的属性，比如资源量、权重等，具体配置格式将在后面介绍。</p><ul><li>yarn.scheduler.fair.user-as-default-queue</li></ul><p>当应用程序未指定队列名时，是否指定用户名作为应用程序所在的队列名。如果设置为false或者未设置，所有未知队列的应用程序将被提交到default队列中，默认值为true。</p><ul><li>yarn.scheduler.fair.preemption</li></ul><p>是否启用抢占机制，默认值是false。</p><ul><li>yarn.scheduler.fair.sizebasedweight</li></ul><p>在一个队列内部分配资源时，默认情况下，采用公平轮询的方法将资源分配各各个应用程序，而该参数则提供了另外一种资源分配方式：按照应用程序资源需求数目分配资源，即需求资源数量越多，分配的资源越多。默认情况下，该参数值为false。</p><ul><li>yarn.scheduler.assignmultiple</li></ul><p>是否启动批量分配功能。当一个节点出现大量资源时，可以一次分配完成，也可以多次分配完成。默认情况下，该参数值为false。</p><ul><li>yarn.scheduler.fair.max.assign</li></ul><p>如果开启批量分配功能，可指定一次分配的container数目。默认情况下，该参数值为-1，表示不限制。</p><ul><li>yarn.scheduler.fair.locality.threshold.node</li></ul><p>当应用程序请求某个节点上资源时，它可以接受的可跳过的最大资源调度机会。当按照分配策略，可将一个节点上的资源分配给某个应用程序时，如果该节点不是应用程序期望的节点，可选择跳过该分配机会暂时将资源分配给其他应用程序，直到出现满足该应用程序需的节点资源出现。通常而言，一次心跳代表一次调度机会，而该参数则表示跳过调度机会占节点总数的比例，默认情况下，该值为-1.0，表示不跳过任何调度机会。</p><ul><li>yarn.scheduler.fair.locality.threshold.rack</li></ul><p>当应用程序请求某个机架上资源时，它可以接受的可跳过的最大资源调度机会。</p><ul><li>yarn.scheduler.increment-allocation-mb</li></ul><p>内存规整化单位，默认是1024，这意味着，如果一个Container请求资源是1.5GB，则将被调度器规整化为ceiling(1.5 GB / 1GB) * 1G=2GB。</p><ul><li>yarn.scheduler.increment-allocation-vcores</li></ul><p>虚拟CPU规整化单位，默认是1，含义与内存规整化单位类似。</p><h3 id="自定义配置文件"><a href="#自定义配置文件" class="headerlink" title="自定义配置文件"></a>自定义配置文件</h3><p>Fair Scheduler允许用户将队列信息专门放到一个配置文件（默认是fair-scheduler.xml），对于每个队列，管理员可配置以下选项：</p><ul><li>minResources</li></ul><p>最少资源保证量，设置格式为“X mb, Y vcores”，当一个队列的最少资源保证量未满足时，它将优先于其他同级队列获得资源，对于不同的调度策略（后面会详细介绍），最少资源保证量的含义不同，对于fair策略，则只考虑内存资源，即如果一个队列使用的内存资源超过了它的最少资源量，则认为它已得到了满足；对于drf策略，则考虑主资源使用的资源量，即如果一个队列的主资源量超过它的最少资源量，则认为它已得到了满足。</p><ul><li>maxResources</li></ul><p>最多可以使用的资源量，fair scheduler会保证每个队列使用的资源量不会超过该队列的最多可使用资源量。</p><ul><li>maxRunningApps</li></ul><p>最多同时运行的应用程序数目。通过限制该数目，可防止超量Map Task同时运行时产生的中间输出结果撑爆磁盘。</p><ul><li>minSharePreemptionTimeout</li></ul><p>最小共享量抢占时间。如果一个资源池在该时间内使用的资源量一直低于最小资源量，则开始抢占资源。</p><ul><li>schedulingMode/schedulingPolicy</li></ul><p>队列采用的调度模式，可以是fifo、fair或者drf。</p><ul><li>aclSubmitApps</li></ul><p>可向队列中提交应用程序的用户列表，默认情况下为”*”，表示任何用户均可以向该队列提交应用程序。需要注意的是，该属性具有继承性，即子队列的列表会继承父队列的列表。</p><ul><li>aclAdministerApps</li></ul><p>该队列的管理员列表。一个队列的管理员可管理该队列中的资源和应用程序，比如可杀死任意应用程序。</p><p>管理员也可为单个用户添加maxRunningJobs属性限制其最多同时运行的应用程序数目。此外，管理员也可通过以下参数设置以上属性的默认值：</p><ul><li>userMaxJobsDefault</li></ul><p>用户的maxRunningJobs属性的默认值。</p><ul><li>defaultMinSharePreemptionTimeout</li></ul><p>队列的minSharePreemptionTimeout属性的默认值。</p><ul><li>defaultPoolSchedulingMode</li></ul><p>队列的schedulingMode属性的默认值。</p><ul><li>fairSharePreemptionTimeout</li></ul><p>公平共享量抢占时间。如果一个资源池在该时间内使用资源量一直低于公平共享量的一半，则开始抢占资源。</p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>假设要为一个Hadoop集群设置三个队列queueA、queueB和queueC，其中，queueB和queueC为queueA的子队列，且规定普通用户最多可同时运行40个应用程序，但用户userA最多可同时运行400个应用程序，那么可在自定义配置文件中进行如下设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;allocations&gt;</span><br><span class="line">  &lt;queue name=”queueA”&gt;</span><br><span class="line">    &lt;minResources&gt;100 mb, 100 vcores&lt;/minResources&gt;</span><br><span class="line">    &lt;maxResources&gt;150 mb, 150 vcores&lt;/maxResources&gt;</span><br><span class="line">    &lt;maxRunningApps&gt;200&lt;/maxRunningApps&gt;</span><br><span class="line">    &lt;minSharePreemptionTimeout&gt;300&lt;/minSharePreemptionTimeout&gt;</span><br><span class="line">    &lt;weight&gt;1.0&lt;/weight&gt;</span><br><span class="line">    &lt;queue name=”queueB”&gt;</span><br><span class="line">      &lt;minResources&gt;30 mb, 30 vcores&lt;/minResources&gt;</span><br><span class="line">      &lt;maxResources&gt;50 mb, 50 vcores&lt;/maxResources&gt;</span><br><span class="line">&lt;/queue&gt;</span><br><span class="line">&lt;queue name=”queueC”&gt;</span><br><span class="line">       &lt;minResources&gt;50 mb, 50 vcores&lt;/minResources&gt;</span><br><span class="line">       &lt;maxResources&gt;50 mb, 50 vcores&lt;/maxResources&gt;</span><br><span class="line">&lt;/queue&gt;</span><br><span class="line">  &lt;/queue&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;user name=”userA”&gt;</span><br><span class="line">    &lt;maxRunningApps&gt;400&lt;/maxRunningApps&gt;</span><br><span class="line">  &lt;/user&gt;</span><br><span class="line">  &lt;userMaxAppsDefault&gt;40&lt;/userMaxAppsDefault&gt;</span><br><span class="line">  &lt;fairSharePreemptionTimeout&gt;6000&lt;/fairSharePreemptionTimeout&gt;</span><br><span class="line">&lt;/allocations&gt;</span><br></pre></td></tr></table></figure><h2 id="配置Example"><a href="#配置Example" class="headerlink" title="配置Example"></a>配置Example</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;allocations&gt;</span><br><span class="line">  &lt;queue name=&quot;sample_queue&quot;&gt;</span><br><span class="line">    &lt;minResources&gt;10000 mb,0vcores&lt;/minResources&gt;</span><br><span class="line">    &lt;maxResources&gt;90000 mb,0vcores&lt;/maxResources&gt;</span><br><span class="line">    &lt;maxRunningApps&gt;50&lt;/maxRunningApps&gt;</span><br><span class="line">    &lt;maxAMShare&gt;0.1&lt;/maxAMShare&gt;</span><br><span class="line">&lt;!--设置权重 40%--&gt;</span><br><span class="line">    &lt;weight&gt;2.0&lt;/weight&gt;</span><br><span class="line">&lt;!--调度策略--&gt;</span><br><span class="line">    &lt;schedulingPolicy&gt;fair&lt;/schedulingPolicy&gt;</span><br><span class="line">    &lt;queue name=&quot;sample_sub_queue&quot;&gt;</span><br><span class="line">      &lt;aclSubmitApps&gt;charlie&lt;/aclSubmitApps&gt;</span><br><span class="line">      &lt;minResources&gt;5000 mb,0vcores&lt;/minResources&gt;</span><br><span class="line">    &lt;/queue&gt;</span><br><span class="line">    &lt;queue name=&quot;sample_reservable_queue&quot;&gt;</span><br><span class="line">      &lt;reservation&gt;&lt;/reservation&gt;</span><br><span class="line">    &lt;/queue&gt;</span><br><span class="line">  &lt;/queue&gt;</span><br><span class="line"></span><br><span class="line">  &lt;queueMaxAMShareDefault&gt;0.5&lt;/queueMaxAMShareDefault&gt;</span><br><span class="line">  &lt;queueMaxResourcesDefault&gt;40000 mb,0vcores&lt;/queueMaxResourcesDefault&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- Queue &apos;secondary_group_queue&apos; is a parent queue and may have</span><br><span class="line">       user queues under it --&gt;</span><br><span class="line">  &lt;queue name=&quot;secondary_group_queue&quot; type=&quot;parent&quot;&gt;</span><br><span class="line">  &lt;!--设置权重 60%--&gt;</span><br><span class="line">  &lt;weight&gt;3.0&lt;/weight&gt;</span><br><span class="line">  &lt;maxChildResources&gt;4096 mb,4vcores&lt;/maxChildResources&gt;</span><br><span class="line">  &lt;/queue&gt;</span><br><span class="line"></span><br><span class="line">  &lt;user name=&quot;sample_user&quot;&gt;</span><br><span class="line">    &lt;maxRunningApps&gt;30&lt;/maxRunningApps&gt;</span><br><span class="line">  &lt;/user&gt;</span><br><span class="line">  &lt;userMaxAppsDefault&gt;5&lt;/userMaxAppsDefault&gt;</span><br><span class="line"></span><br><span class="line">  &lt;queuePlacementPolicy&gt;</span><br><span class="line">    &lt;!--若提交的任务指定了队列名，则放入指定队列--&gt;</span><br><span class="line">    &lt;rule name=&quot;specified&quot; /&gt;</span><br><span class="line">&lt;!--尝试将任务提交到名称为用户名的队列，若不存在与当前用户名相同的队列，则转入下一个规则--&gt;</span><br><span class="line">    &lt;rule name=&quot;primaryGroup&quot; create=&quot;false&quot; /&gt;</span><br><span class="line">    &lt;rule name=&quot;nestedUserQueue&quot;&gt;</span><br><span class="line">        &lt;rule name=&quot;secondaryGroupExistingQueue&quot; create=&quot;false&quot; /&gt;</span><br><span class="line">    &lt;/rule&gt;</span><br><span class="line">&lt;!--前面均不匹配，则放入默认队列sample_queue--&gt;</span><br><span class="line">    &lt;rule name=&quot;default&quot; queue=&quot;sample_queue&quot;/&gt;</span><br><span class="line">  &lt;/queuePlacementPolicy&gt;</span><br><span class="line">&lt;/allocations&gt;</span><br></pre></td></tr></table></figure><h2 id="抢占"><a href="#抢占" class="headerlink" title="抢占"></a>抢占</h2><p>Fair调度器支持抢占，抢占就是允许调度器杀掉占用超过其应占份额资源队列的containers，这些containers资源便可被分配到应该享有这些份额资源的队列中。需要注意抢占会降低集群的执行效率，因为被终止的containers需要被重新执行。</p><p>可以通过设置一个全局的参数yarn.scheduler.fair.preemption=true来启用抢占功能。</p><p><strong>参考文献:</strong></p><ol><li><a href="https://www.jianshu.com/p/8738acc89bd4" target="_blank" rel="noopener">https://www.jianshu.com/p/8738acc89bd4</a></li><li><a href="http://www.imooc.com/article/253999" target="_blank" rel="noopener">http://www.imooc.com/article/253999</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;在Yarn体系中，Scheduler负责为Application分配资源，按照调度策略可分为以下3种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;FIFO 
      
    
    </summary>
    
      <category term="大数据" scheme="http://ruanshubin.top/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="大数据" scheme="http://ruanshubin.top/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Yarn" scheme="http://ruanshubin.top/tags/Yarn/"/>
    
  </entry>
  
  <entry>
    <title>Yarn的资源配置参数</title>
    <link href="http://ruanshubin.top/2019/10/21/Yarn%E7%9A%84%E8%B5%84%E6%BA%90%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0/"/>
    <id>http://ruanshubin.top/2019/10/21/Yarn的资源配置参数/</id>
    <published>2019-10-21T13:30:00.000Z</published>
    <updated>2019-12-25T02:29:04.443Z</updated>
    
    <content type="html"><![CDATA[<p>YARN的资源调度主要针对的是内存(Memory)和CPU，并将其组合抽象成Container来管理分配。</p><p>在YARN中，资源管理由ResourceManager和NodeManager共同完成，其中，ResourceManager中的调度器负责资源的分配，而NodeManager则负责资源的供给和隔离。ResourceManager将某个NodeManager上资源分配给任务（这就是所谓的“资源调度”）后，NodeManager需按照要求为任务提供相应的资源，甚至保证这些资源应具有独占性，为任务运行提供基础的保证，这就是所谓的资源隔离。</p><p>在正式介绍具体的资源调度和隔离之前，先品味一下内存和CPU这两种资源的特点，这是两种性质不同的资源。内存资源的多少会会决定任务的生死，如果内存不够，任务可能会运行失败；相比之下，CPU资源则不同，它只会决定任务运行的快慢，不会对生死产生影响。</p><h2 id="Memory配置"><a href="#Memory配置" class="headerlink" title="Memory配置"></a>Memory配置</h2><h3 id="计算单台机器的Container上限值"><a href="#计算单台机器的Container上限值" class="headerlink" title="计算单台机器的Container上限值"></a>计算单台机器的Container上限值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">containers = min (2*CORES, 1.8*DISKS, (Total available RAM) / MIN_CONTAINER_SIZE)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>CORES: 机器CPU核数</li><li>DISKS: 机器上挂载的磁盘个数</li><li>Total available RAM: 机器总内存</li><li>MIN_CONTAINER_SIZE: Container最小的容量大小</li></ul><p>MIN_CONTAINER_SIZE主要与机器可用的RAM有关：</p><div class="table-container"><table><thead><tr><th style="text-align:center">单台机器可用RAM</th><th style="text-align:center">Container最小值</th></tr></thead><tbody><tr><td style="text-align:center">&lt;4GB</td><td style="text-align:center">256MB</td></tr><tr><td style="text-align:center">4GB-8GB</td><td style="text-align:center">512MB</td></tr><tr><td style="text-align:center">8GB-24GB</td><td style="text-align:center">1024MB</td></tr><tr><td style="text-align:center">&gt;24GB</td><td style="text-align:center">2048MB</td></tr></tbody></table></div><h3 id="YARN配置-内存相关"><a href="#YARN配置-内存相关" class="headerlink" title="YARN配置(内存相关)"></a>YARN配置(内存相关)</h3><ul><li>yarn.nodemanager.resource.memory-mb</li></ul><p>表示该节点上YARN可使用的物理内存总量，默认是8192（MB）。</p><p>注意，如果你的节点内存资源不够8GB，则需要调减小这个值，而YARN不会智能的探测节点的物理内存总量。</p><ul><li>yarn.nodemanager.vmem-pmem-ratio</li></ul><p>任务每使用1MB物理内存，最多可使用虚拟内存量，默认是2.1。</p><ul><li>yarn.nodemanager.pmem-check-enabled</li></ul><p>是否启动一个线程检查每个任务正使用的物理内存量，如果任务超出分配值，则直接将其杀掉，默认是true。</p><ul><li>yarn.nodemanager.vmem-check-enabled</li></ul><p>是否启动一个线程检查每个任务正使用的虚拟内存量，如果任务超出分配值，则直接将其杀掉，默认是true。</p><ul><li>yarn.scheduler.minimum-allocation-mb</li></ul><p>单个container可申请的最少物理内存量，默认是1024（MB），如果一个任务申请的物理内存量少于该值，则该对应的值改为这个数。</p><ul><li>yarn.scheduler.maximum-allocation-mb</li></ul><p>单个container可申请的最少物理内存量，默认是1024（MB），如果一个任务申请的物理内存量少于该值，则该对应的值改为这个数。</p><blockquote><p>默认情况下，YARN采用了线程监控的方法判断任务是否超量使用内存，一旦发现超量，则直接将其杀死。由于Cgroups对内存的控制缺乏灵活性（即任务任何时刻不能超过内存上限，如果超过，则直接将其杀死或者报OOM），而Java进程在创建瞬间内存将翻倍，之后骤降到正常值，这种情况下，采用线程监控的方式更加灵活（当发现进程树内存瞬间翻倍超过设定值时，可认为是正常现象，不会将任务杀死），因此YARN未提供Cgroups内存隔离机制。</p></blockquote><h2 id="CPU配置"><a href="#CPU配置" class="headerlink" title="CPU配置"></a>CPU配置</h2><p>在YARN中使用的是虚拟CPU，虚拟CPU是YARN自己引入的概念，初衷是，考虑到不同节点的CPU性能可能不同，每个CPU具有的计算能力也是不一样的，比如某个物理CPU的计算能力可能是另外一个物理CPU的2倍，这时候，你可以通过为第一个物理CPU多配置几个虚拟CPU弥补这种差异。用户提交作业时，可以指定每个任务需要的虚拟CPU个数。在YARN中，CPU相关配置参数如下：</p><h3 id="YARN配置-CPU相关"><a href="#YARN配置-CPU相关" class="headerlink" title="YARN配置(CPU相关)"></a>YARN配置(CPU相关)</h3><ul><li>yarn.nodemanager.resource.cpu-vcores</li></ul><p>表示该节点上YARN可使用的虚拟CPU个数，默认是8，注意，目前推荐将该值设值为与物理CPU核数数目相同。</p><p>如果你的节点CPU核数不够8个，则需要调减小这个值，而YARN不会智能的探测节点的物理CPU总数。</p><ul><li>yarn.scheduler.minimum-allocation-vcores</li></ul><p>单个任务可申请的最小虚拟CPU个数，默认是1，如果一个任务申请的CPU个数少于该数，则该对应的值改为这个数。</p><ul><li>yarn.scheduler.maximum-allocation-vcores</li></ul><p>单个任务可申请的最多虚拟CPU个数，默认是32。</p><p>默认情况下，<strong>YARN是不会对CPU资源进行调度的，你需要配置相应的资源调度器来支持</strong>。</p><h3 id="资源划分方式"><a href="#资源划分方式" class="headerlink" title="资源划分方式"></a>资源划分方式</h3><p>默认情况下，NodeManager不会对CPU资源进行任何隔离，你可以通过启用Cgroups让你支持CPU隔离。</p><p>由于CPU资源的独特性，目前这种CPU分配方式仍然是粗粒度的。举个例子，很多任务可能是IO密集型的，消耗的CPU资源非常少，如果此时你为它分配一个CPU，则是一种严重浪费，你完全可以让他与其他几个任务公用一个CPU，也就是说，我们需要支持更粒度的CPU表达方式。</p><p>借鉴亚马逊EC2中CPU资源的划分方式，即提出了CPU最小单位为EC2 Compute Unit（ECU），一个ECU代表相当于1.0-1.2 GHz 2007 Opteron or 2007 Xeon处理器的处理能力。YARN提出了CPU最小单位YARN Compute Unit（YCU），目前这个数是一个整数，默认是720，由参数yarn.nodemanager.resource.cpu-ycus-per-core设置，表示一个CPU core具备的计算能力（该feature在2.2.0版本中并不存在，可能增加到2.3.0版本中），这样，用户提交作业时，直接指定需要的YCU即可，比如指定值为360，表示用1/2个CPU core，实际表现为，只使用一个CPU core的1/2计算时间。注意，在操作系统层，CPU资源是按照时间片分配的，你可以说，一个进程使用1/3的CPU时间片，或者1/5的时间片。</p><p><strong>参考文献：</strong></p><ol><li><a href="http://dongxicheng.org/mapreduce-nextgen/hadoop-yarn-memory-cpu-scheduling/" target="_blank" rel="noopener">http://dongxicheng.org/mapreduce-nextgen/hadoop-yarn-memory-cpu-scheduling/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;YARN的资源调度主要针对的是内存(Memory)和CPU，并将其组合抽象成Container来管理分配。&lt;/p&gt;
&lt;p&gt;在YARN中，资源管理由ResourceManager和NodeManager共同完成，其中，ResourceManager中的调度器负责资源的分配，而
      
    
    </summary>
    
      <category term="大数据" scheme="http://ruanshubin.top/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="大数据" scheme="http://ruanshubin.top/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Yarn" scheme="http://ruanshubin.top/tags/Yarn/"/>
    
  </entry>
  
  <entry>
    <title>Lambda架构</title>
    <link href="http://ruanshubin.top/2019/10/20/Lambda%E6%9E%B6%E6%9E%84/"/>
    <id>http://ruanshubin.top/2019/10/20/Lambda架构/</id>
    <published>2019-10-20T13:30:00.000Z</published>
    <updated>2019-12-25T02:26:45.459Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Lambda架构是由Storm的作者Nathan Marz提出的一个实时大数据处理框架。Marz在Twitter工作期间开发了著名的实时大数据处理框架Storm，Lambda架构是其根据多年进行分布式大数据系统的经验总结提炼而成。</p><p>Lambda架构的目标是设计出一个能满足实时大数据系统关键特性的架构，包括有：高容错、低延时和可扩展等。Lambda架构整合离线计算和实时计算，融合不可变性（Immunability），读写分离和复杂性隔离等一系列架构原则，可集成Hadoop，Kafka，Storm，Spark，Hbase等各类大数据组件。</p><h2 id="Lambda架构"><a href="#Lambda架构" class="headerlink" title="Lambda架构"></a>Lambda架构</h2><p>如何实时地在任意大数据集上进行查询？大数据再加上实时计算，问题的难度比较大。</p><p>最简单的方法是，根据前述的查询等式Query = Function(All Data)，在全体数据集上在线运行查询函数得到结果。但如果数据量比较大，该方法的计算代价太大了，所以不现实。</p><p>Lambda架构通过分解的三层架构来解决该问题：Batch Layer，Speed Layer和Serving Layer。 </p><p><img src="/2019/10/20/Lambda架构/1.jpg" alt=""></p><h3 id="Batch-Layer"><a href="#Batch-Layer" class="headerlink" title="Batch Layer"></a>Batch Layer</h3><p>Batch Layer的功能主要有两点：</p><ul><li>存储数据集</li><li>在数据集上预先计算查询函数，构建查询所对应的View</li></ul><h4 id="储存数据集"><a href="#储存数据集" class="headerlink" title="储存数据集"></a>储存数据集</h4><p>根据前述对数据When&amp;What特性的讨论，Batch Layer采用不可变模型存储所有的数据。因为数据量比较大，可以采用HDFS之类的大数据储存方案。如果需要按照数据产生的时间先后顺序存放数据，可以考虑如InfluxDB之类的时间序列数据库（TSDB）存储方案。</p><h4 id="构建查询View"><a href="#构建查询View" class="headerlink" title="构建查询View"></a>构建查询View</h4><p>上面说到根据等式Query = Function(All Data)，在全体数据集上在线运行查询函数得到结果的代价太大。但如果我们预先在数据集上计算并保存查询函数的结果，查询的时候就可以直接返回结果（或通过简单的加工运算就可得到结果）而无需重新进行完整费时的计算了。这儿可以把Batch Layer看成是一个数据预处理的过程。我们把针对查询预先计算并保存的结果称为View，View是Lamba架构的一个核心概念，它是针对查询的优化，通过View即可以快速得到查询结果。 </p><p><img src="/2019/10/20/Lambda架构/2.jpg" alt=""></p><p>如果采用HDFS来储存数据，我们就可以使用MapReduce来在数据集上构建查询的View。Batch Layer的工作可以简单的用如下伪码表示： </p><p><img src="/2019/10/20/Lambda架构/3.jpg" alt=""></p><p>该工作看似简单，实质非常强大。任何人为或机器发生的错误，都可以通过修正错误后重新计算来恢复得到正确结果。</p><p>View是一个和业务关联性比较大的概念，View的创建需要从业务自身的需求出发。一个通用的数据库查询系统，查询对应的函数千变万化，不可能穷举。但是如果从业务自身的需求出发，可以发现业务所需要的查询常常是有限的。Batch Layer需要做的一件重要的工作就是根据业务的需求，考察可能需要的各种查询，根据查询定义其在数据集上对应的Views。</p><h3 id="Speed-Layer"><a href="#Speed-Layer" class="headerlink" title="Speed Layer"></a>Speed Layer</h3><p>Batch Layer可以很好的处理离线数据，但有很多场景数据不断实时生成，并且需要实时查询处理。Speed Layer正是用来处理增量的实时数据。</p><p>Speed Layer和Batch Layer比较类似，对数据进行计算并生成Realtime View，其主要区别在于：</p><ul><li><p>Speed Layer处理的数据是最近的增量数据流，Batch Layer处理的全体数据集</p></li><li><p>Speed Layer为了效率，接收到新数据时不断更新Realtime View，而Batch Layer根据全体离线数据集直接得到Batch View。</p></li></ul><p>Lambda架构将数据处理分解为Batch Layer和Speed Layer有如下优点：</p><ul><li>容错性</li></ul><p>Speed Layer中处理的数据也不断写入Batch Layer，当Batch Layer中重新计算的数据集包含Speed Layer处理的数据集后，当前的Realtime View就可以丢弃，这也就意味着Speed Layer处理中引入的错误，在Batch Layer重新计算时都可以得到修正。这点也可以看成是CAP理论中的最终一致性（Eventual Consistency）的体现。</p><p><img src="/2019/10/20/Lambda架构/4.jpg" alt=""></p><ul><li>复杂性隔离</li></ul><p>Batch Layer处理的是离线数据，可以很好的掌控。Speed Layer采用增量算法处理实时数据，复杂性比Batch Layer要高很多。通过分开Batch Layer和Speed Layer，把复杂性隔离到Speed Layer，可以很好的提高整个系统的鲁棒性和可靠性。</p><h3 id="Serving-Layer"><a href="#Serving-Layer" class="headerlink" title="Serving Layer"></a>Serving Layer</h3><p>Lambda架构的Serving Layer用于响应用户的查询请求，合并Batch View和Realtime View中的结果数据集到最终的数据集。</p><p>这儿涉及到数据如何合并的问题。前面我们讨论了查询函数的Monoid性质，如果查询函数满足Monoid性质，即满足结合率，只需要简单的合并Batch View和Realtime View中的结果数据集即可。否则的话，可以把查询函数转换成多个满足Monoid性质的查询函数的运算，单独对每个满足Monoid性质的查询函数进行Batch View和Realtime View中的结果数据集合并，然后再计算得到最终的结果数据集。另外也可以根据业务自身的特性，运用业务自身的规则来对Batch View和Realtime View中的结果数据集合并。 </p><p><img src="/2019/10/20/Lambda架构/5.jpg" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面分别讨论了Lambda架构的三层：Batch Layer，Speed Layer和Serving Layer。下图给出了Lambda架构的一个完整视图和流程。 </p><p><img src="/2019/10/20/Lambda架构/6.jpg" alt=""></p><p>数据流进入系统后，同时发往Batch Layer和Speed Layer处理。Batch Layer以不可变模型离线存储所有数据集，通过在全体数据集上不断重新计算构建查询所对应的Batch Views。Speed Layer处理增量的实时数据流，不断更新查询所对应的Realtime Views。Serving Layer响应用户的查询请求，合并Batch View和Realtime View中的结果数据集到最终的数据集。</p><p>下图给出了Lambda架构中各个层常用的组件。数据流存储可选用基于不可变日志的分布式消息系统Kafka；Batch Layer数据集的存储可选用Hadoop的HDFS，或者是阿里云的ODPS；Batch View的预计算可以选用MapReduce或Spark；Batch View自身结果数据的存储可使用MySQL（查询少量的最近结果数据），或HBase（查询大量的历史结果数据）。Speed Layer增量数据的处理可选用Storm或Spark Streaming；Realtime View增量结果数据集为了满足实时更新的效率，可选用Redis等内存NoSQL。 </p><p><img src="/2019/10/20/Lambda架构/7.jpg" alt=""></p><p>Lambda架构是个通用框架，各个层选型时不要局限时上面给出的组件，特别是对于View的选型。从我对Lambda架构的实践来看，因为View是个和业务关联性非常大的概念，View选择组件时关键是要根据业务的需求，来选择最适合查询的组件。不同的View组件的选择要深入挖掘数据和计算自身的特点，从而选择出最适合数据和计算自身特点的组件，同时不同的View可以选择不同的组件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;Lambda架构是由Storm的作者Nathan Marz提出的一个实时大数据处理框架。Marz在Twitter工作期间开发了著名的实时大数
      
    
    </summary>
    
      <category term="大数据" scheme="http://ruanshubin.top/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="大数据" scheme="http://ruanshubin.top/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="基础" scheme="http://ruanshubin.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
