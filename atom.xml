<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>阮树斌 | 技术改变生活</title>
  
  <subtitle>交通 | 数据 | 算法 &lt;br&gt; Java | Python | Scala | Matlab | GIS</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ruanshubin.top/"/>
  <updated>2019-12-25T05:50:40.812Z</updated>
  <id>http://ruanshubin.top/</id>
  
  <author>
    <name>Ruan Shubin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>逐行分析AQS源码1--独占锁的获取</title>
    <link href="http://ruanshubin.top/2019/11/08/%E9%80%90%E8%A1%8C%E5%88%86%E6%9E%90AQS%E6%BA%90%E7%A0%811%E2%80%94%E2%80%94%E7%8B%AC%E5%8D%A0%E9%94%81%E7%9A%84%E8%8E%B7%E5%8F%96/"/>
    <id>http://ruanshubin.top/2019/11/08/逐行分析AQS源码1——独占锁的获取/</id>
    <published>2019-11-08T13:30:00.000Z</published>
    <updated>2019-12-25T05:50:40.812Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>AQS（AbstractQueuedSynchronizer）是JAVA中众多锁以及并发工具的基础，其底层采用乐观锁，大量使用了CAS操作， 并且在冲突时，采用自旋方式重试，以实现轻量级和高效地获取锁。</p><p>AQS虽然被定义为抽象类，但事实上它并不包含任何抽象方法。这是因为AQS是被设计来支持多种用途的，如果定义抽象方法，则子类在继承时必须要覆写所有的抽象方法，这显然是不合理的。所以AQS将一些需要子类覆写的方法都设计成protect方法，将其默认实现为抛出UnsupportedOperationException异常。如果子类使用到这些方法，但是没有覆写，则会抛出异常；如果子类没有使用到这些方法，则不需要做任何操作。</p><p>AQS中实现了锁的获取框架，锁的实际获取逻辑交由子类去实现，就锁的获取操作而言，子类必须重写 tryAcquire方法。</p><p>本篇我们将以ReentrantLock的公平锁为例来详细看看使用AQS获取独占锁的流程。</p><p>本文中的源码基于JDK1.8 。</p><h2 id="Java并发工具类的三板斧"><a href="#Java并发工具类的三板斧" class="headerlink" title="Java并发工具类的三板斧"></a>Java并发工具类的三板斧</h2><p>在开始看AQS源码之前，我们先来了解以下java并发工具的设计套路，我把它总结成三板斧：</p><blockquote><p>状态，队列，CAS</p></blockquote><p>每当我们学习一个java并发编程工具的时候，我们首先要抓住这三点。</p><ul><li><strong>状态</strong>：一般是一个state属性，它基本是整个工具的核心，通常整个工具都是在<strong>设置和修改状态</strong>，很多方法的操作都依赖于当前状态是什么。由于状态是全局共享的，一般会被设置成volatile类型，以保证其修改的可见性；</li><li><strong>队列</strong>：队列通常是一个等待的集合，大多数以链表的形式实现。队列采用的是悲观锁的思想，表示当前所等待的资源，状态或者条件短时间内可能无法满足。因此，它会将当前线程包装成某种类型的数据结构，扔到一个等待队列中，当一定条件满足后，再从等待队列中取出。</li><li>CAS: CAS操作是最轻量的并发处理，通常我们对于状态的修改都会用到CAS操作，因为状态可能被多个线程同时修改，CAS操作保证了同一个时刻，只有一个线程能修改成功，从而保证了线程安全，CAS操作基本是由Unsafe工具类的compareAndSwapXXX来实现的；CAS采用的是乐观锁的思想，因此常常伴随着自旋，如果发现当前无法成功地执行CAS，则不断重试，直到成功为止，自旋的的表现形式通常是一个死循环for(;;)。</li></ul><h2 id="AQS核心实现"><a href="#AQS核心实现" class="headerlink" title="AQS核心实现"></a>AQS核心实现</h2><p>上面我们已经总结了java并发编程的套路，下面我们就以这个套路为切入点来分析AQS的实现。</p><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p>首先是找状态。</p><p>在AQS中，状态是由state属性来表示的，不出所料，它是volatile类型的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private volatile int state;</span><br></pre></td></tr></table></figure><p>该属性的值即表示了锁的状态，state为0表示锁没有被占用，state大于0表示当前已经有线程持有该锁，这里之所以说大于0而不说等于1是因为可能存在可重入的情况。你可以把state变量当做是当前持有该锁的线程数量。</p><p>由于本篇我们分析的是独占锁，同一时刻，锁只能被一个线程所持有。通过state变量是否为0，我们可以分辨当前锁是否被占用，但光知道锁是不是被占用是不够的，我们并不知道占用锁的线程是哪一个。在监视器锁中，我们用ObjectMonitor对象的_owner属性记录了当前拥有监视器锁的线程，而在AQS中，我们将通过exclusiveOwnerThread属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private transient Thread exclusiveOwnerThread; //继承自AbstractOwnableSynchronizer</span><br></pre></td></tr></table></figure><p>exclusiveOwnerThread属性的值即为当前持有锁的线程，它就是我们在分析监视器锁的原理的时候所说的“铁王座”。</p><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>接着我们来看队列，AQS中，队列的实现是一个双向链表，被称为sync queue，它表示所有等待锁的线程的集合，有点类似于我们前面介绍synchronized原理的时候说的wait set。</p><p>我们前面说过，在并发编程中使用队列通常是将当前线程包装成某种类型的数据结构扔到等待队列中，我们先来看看队列中的每一个节点是怎么个结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">static final class Node &#123;</span><br><span class="line">    /** Marker to indicate a node is waiting in shared mode */</span><br><span class="line">    static final Node SHARED = new Node();</span><br><span class="line">    /** Marker to indicate a node is waiting in exclusive mode */</span><br><span class="line">    static final Node EXCLUSIVE = null;</span><br><span class="line"></span><br><span class="line">    /** waitStatus value to indicate thread has cancelled */</span><br><span class="line">    static final int CANCELLED =  1;</span><br><span class="line">    /** waitStatus value to indicate successor&apos;s thread needs unparking */</span><br><span class="line">    static final int SIGNAL    = -1;</span><br><span class="line">    /** waitStatus value to indicate thread is waiting on condition */</span><br><span class="line">    static final int CONDITION = -2;</span><br><span class="line">    /**</span><br><span class="line">     * waitStatus value to indicate the next acquireShared should</span><br><span class="line">     * unconditionally propagate</span><br><span class="line">     */</span><br><span class="line">    static final int PROPAGATE = -3;</span><br><span class="line"></span><br><span class="line">    volatile int waitStatus;</span><br><span class="line"></span><br><span class="line">    volatile Node prev;</span><br><span class="line"></span><br><span class="line">    volatile Node next;</span><br><span class="line"></span><br><span class="line">    volatile Thread thread;</span><br><span class="line"></span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line">    final boolean isShared() &#123;</span><br><span class="line">        return nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final Node predecessor() throws NullPointerException &#123;</span><br><span class="line">        Node p = prev;</span><br><span class="line">        if (p == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        else</span><br><span class="line">            return p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node() &#123;    // Used to establish initial head or SHARED marker</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, Node mode) &#123;     // Used by addWaiter</span><br><span class="line">        this.nextWaiter = mode;</span><br><span class="line">        this.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, int waitStatus) &#123; // Used by Condition</span><br><span class="line">        this.waitStatus = waitStatus;</span><br><span class="line">        this.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个结构看起来很复杂，其实属性只有4类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/ 节点所代表的线程</span><br><span class="line">volatile Thread thread;</span><br><span class="line"></span><br><span class="line">// 双向链表，每个节点需要保存自己的前驱节点和后继节点的引用</span><br><span class="line">volatile Node prev;</span><br><span class="line">volatile Node next;</span><br><span class="line"></span><br><span class="line">// 线程所处的等待锁的状态，初始化时，该值为0</span><br><span class="line">volatile int waitStatus;</span><br><span class="line">static final int CANCELLED =  1;</span><br><span class="line">static final int SIGNAL    = -1;</span><br><span class="line">static final int CONDITION = -2;</span><br><span class="line">static final int PROPAGATE = -3;</span><br><span class="line"></span><br><span class="line">// 该属性用于条件队列或者共享锁</span><br><span class="line">Node nextWaiter;</span><br></pre></td></tr></table></figure><p>注意，在这个Node类中也有一个状态变量waitStatus，它表示了当前Node所代表的线程的等待锁的状态，在独占锁模式下，我们只需要关注CANCELLED SIGNAL两种状态即可。这里还有一个nextWaiter属性，它在独占锁模式下永远为null，仅仅起到一个标记作用，没有实际意义。这么一分析，这个Node类是不是就简单了好多？&lt;(￣︶￣)&gt;</p><p>说完队列中的节点，我们接着说回这个sync queue，AQS是怎么使用这个队列的呢，既然是双向链表，操纵它自然只需要一个头结点和一个尾节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 头结点，不代表任何线程，是一个哑结点</span><br><span class="line">private transient volatile Node head;</span><br><span class="line"></span><br><span class="line">// 尾节点，每一个请求锁的线程会加到队尾</span><br><span class="line">private transient volatile Node tail;</span><br></pre></td></tr></table></figure><p>到这里，我们就了解到了这个sync queue的全貌：</p><p><img src="/2019/11/08/逐行分析AQS源码1——独占锁的获取/1.jpg" alt=""></p><p>不过这里有一点我们提前说一下，在AQS中的队列是一个CLH队列，它的head节点永远是一个哑结点（dummy node), 它不代表任何线程（某些情况下可以看做是代表了当前持有锁的线程），<strong>因此head所指向的Node的thread属性永远是null</strong>。只有从次头节点往后的所有节点才代表了所有等待锁的线程。也就是说，在当前线程没有抢到锁被包装成Node扔到队列中时，<strong>即使队列是空的，它也会排在第二个</strong>，我们会在它的前面新建一个dummy节点(具体的代码我们在后面分析源码时再详细讲)。为了便于描述，下文中我们把除去head节点的队列称作是等待队列，在这个队列中的节点才代表了所有等待锁的线程：</p><p><img src="/2019/11/08/逐行分析AQS源码1——独占锁的获取/2.jpg" alt=""></p><p>在继续往下之前我们再对着上图总结一下Node节点各个参数的含义：</p><ul><li>thread：表示当前Node所代表的线程</li><li>waitStatus：表示节点所处的等待状态，共享锁模式下只需关注三种状态：SIGNAL CANCELLED 初始态(0)</li><li>prev next：节点的前驱和后继</li><li>nextWaiter：仅作为标记，值永远为null，表示当前处于独占锁模式</li></ul><h3 id="CAS操作"><a href="#CAS操作" class="headerlink" title="CAS操作"></a>CAS操作</h3><p>前面我们提到过，CAS操作大对数是用来改变状态的，在AQS中也不例外。我们一般在静态代码块中初始化需要CAS操作的属性的偏移量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private static final Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">private static final long stateOffset;</span><br><span class="line">private static final long headOffset;</span><br><span class="line">private static final long tailOffset;</span><br><span class="line">private static final long waitStatusOffset;</span><br><span class="line">private static final long nextOffset;</span><br><span class="line"></span><br><span class="line">static &#123;</span><br><span class="line">try &#123;</span><br><span class="line">stateOffset = unsafe.objectFieldOffset</span><br><span class="line">(AbstractQueuedSynchronizer.class.getDeclaredField(&quot;state&quot;));</span><br><span class="line">headOffset = unsafe.objectFieldOffset</span><br><span class="line">(AbstractQueuedSynchronizer.class.getDeclaredField(&quot;head&quot;));</span><br><span class="line">tailOffset = unsafe.objectFieldOffset</span><br><span class="line">(AbstractQueuedSynchronizer.class.getDeclaredField(&quot;tail&quot;));</span><br><span class="line">waitStatusOffset = unsafe.objectFieldOffset</span><br><span class="line">(Node.class.getDeclaredField(&quot;waitStatus&quot;));</span><br><span class="line">nextOffset = unsafe.objectFieldOffset</span><br><span class="line">(Node.class.getDeclaredField(&quot;next&quot;));</span><br><span class="line"></span><br><span class="line">&#125; catch (Exception ex) &#123; throw new Error(ex); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这个静态代码块中我们也可以看出，CAS操作主要针对5个属性，包括AQS的3个属性state,head和tail, 以及Node对象的两个属性waitStatus,next。说明这5个属性基本是会被多个线程同时访问的。</p><p>定义完属性的偏移量之后，接下来就是CAS操作本身了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean compareAndSetState(int expect, int update) &#123;</span><br><span class="line">    return unsafe.compareAndSwapInt(this, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br><span class="line">private final boolean compareAndSetHead(Node update) &#123;</span><br><span class="line">    return unsafe.compareAndSwapObject(this, headOffset, null, update);</span><br><span class="line">&#125;</span><br><span class="line">private final boolean compareAndSetTail(Node expect, Node update) &#123;</span><br><span class="line">    return unsafe.compareAndSwapObject(this, tailOffset, expect, update);</span><br><span class="line">&#125;</span><br><span class="line">private static final boolean compareAndSetWaitStatus(Node node, int expect,int update) &#123;</span><br><span class="line">    return unsafe.compareAndSwapInt(node, waitStatusOffset, expect, update);</span><br><span class="line">&#125;</span><br><span class="line">private static final boolean compareAndSetNext(Node node, Node expect, Node update) &#123;</span><br><span class="line">    return unsafe.compareAndSwapObject(node, nextOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如前面所说，最终CAS操作调用的还是Unsafe类的compareAndSwapXXX方法。</p><p>最后就是自旋了，这一点就没有什么好说的了，我们在后面源码分析的时候再详细讲。</p><h2 id="AQS核心属性"><a href="#AQS核心属性" class="headerlink" title="AQS核心属性"></a>AQS核心属性</h2><p>前面我们以java并发编程工具类的“三板斧”为切入点分析了AQS的状态，队列和CAS操作，对这个工具类有了初步的认识。接下来，我们就要开始进入源码分析了。在进入正式的分析之前，我们先来总结下AQS核心属性：</p><p>（1）锁相关的属性有两个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private volatile int state; //锁的状态</span><br><span class="line">private transient Thread exclusiveOwnerThread; // 当前持有锁的线程，注意这个属性是从AbstractOwnableSynchronizer继承而来</span><br></pre></td></tr></table></figure><p>（2）sync queue相关的属性有两个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private transient volatile Node head; // 队头，为dummy node</span><br><span class="line">private transient volatile Node tail; // 队尾，新入队的节点</span><br></pre></td></tr></table></figure><p>（3）队列中的Node中需要关注的属性有三组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 节点所代表的线程</span><br><span class="line">volatile Thread thread;</span><br><span class="line"></span><br><span class="line">// 双向链表，每个节点需要保存自己的前驱节点和后继节点的引用</span><br><span class="line">volatile Node prev;</span><br><span class="line">volatile Node next;</span><br><span class="line"></span><br><span class="line">// 线程所处的等待锁的状态，初始化时，该值为0</span><br><span class="line">volatile int waitStatus;</span><br><span class="line">static final int CANCELLED =  1;</span><br><span class="line">static final int SIGNAL    = -1;</span><br></pre></td></tr></table></figure><p>拎了这些属性后，我们下面分析源码就容易很多了。</p><h2 id="Example-FairSync-in-ReentrantLock"><a href="#Example-FairSync-in-ReentrantLock" class="headerlink" title="Example: FairSync in ReentrantLock"></a>Example: FairSync in ReentrantLock</h2><p>前面已经提到, AQS大多数情况下都是通过继承来使用的, 子类通过覆写 tryAcquire 来实现自己的获取锁的逻辑，我们这里以ReentrantLock为例来说明锁的获取流程。</p><p>值得注意的是, ReentrantLock有 公平锁 和 非公平锁 两种实现, 默认实现为非公平锁, 这体现在它的构造函数中:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public class ReentrantLock implements Lock, java.io.Serializable &#123;</span><br><span class="line">    /** Synchronizer providing all implementation mechanics */</span><br><span class="line">    private final Sync sync;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * Base of synchronization control for this lock. Subclassed</span><br><span class="line">     * into fair and nonfair versions below. Uses AQS state to</span><br><span class="line">     * represent the number of holds on the lock.</span><br><span class="line">     */</span><br><span class="line">    abstract static class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * Sync object for non-fair locks</span><br><span class="line">     */</span><br><span class="line">    static final class NonfairSync extends Sync&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * Sync object for fair locks</span><br><span class="line">     */</span><br><span class="line">    static final class FairSync extends Sync &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * Creates an instance of &#123;@code ReentrantLock&#125;.</span><br><span class="line">     * This is equivalent to using &#123;@code ReentrantLock(false)&#125;.</span><br><span class="line">     */</span><br><span class="line">    public ReentrantLock() &#123;</span><br><span class="line">        sync = new NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Creates an instance of &#123;@code ReentrantLock&#125; with the</span><br><span class="line">     * given fairness policy.</span><br><span class="line">     *</span><br><span class="line">     * @param fair &#123;@code true&#125; if this lock should use a fair ordering policy</span><br><span class="line">     */</span><br><span class="line">    public ReentrantLock(boolean fair) &#123;</span><br><span class="line">        sync = fair ? new FairSync() : new NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 获取锁</span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        sync.lock();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出, FairSync 继承自 Sync, 而Sync继承自 AQS, ReentrantLock获取锁的逻辑是直接调用了 FairSync 或者 NonfairSync的逻辑.</p><p>好了, ReentrantLock 就简单说到这里, 以后我们有机会再详细讲, 这里直接以 FairLock 为例, 来逐行分析锁的获取:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static final class FairSync extends Sync &#123;</span><br><span class="line">    private static final long serialVersionUID = -3000897897090466540L;</span><br><span class="line">    //获取锁</span><br><span class="line">    final void lock() &#123;</span><br><span class="line">        acquire(1);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lock 方法调用的 acquire方法来自父类AQS。</p><p>这里首先给出完整的获取锁的流程图, 再逐行分析代码, 因为看源码的时候, 代码会在函数或者循环中来回跳转，读者可以对照以下流程图, 就不容易被绕晕了.</p><p><img src="/2019/11/08/逐行分析AQS源码1——独占锁的获取/3.jpg" alt=""></p><h3 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h3><p>acquire 定义在AQS类中，描述了获取锁的流程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出, 该方法中涉及了四个方法的调用:</p><p><strong>（1）tryAcquire(arg)</strong></p><p>该方法由继承AQS的子类实现, 为获取锁的具体逻辑。</p><p><strong>（2）addWaiter(Node mode)</strong></p><p>该方法由AQS实现, 负责在获取锁失败后调用, 将当前请求锁的线程包装成Node扔到sync queue中去，并返回这个Node。</p><p><strong>（3）acquireQueued(final Node node, int arg)</strong></p><p>该方法由AQS实现,这个方法比较复杂, 主要对上面刚加入队列的Node不断尝试以下两种操作之一:</p><ul><li>在前驱节点就是head节点的时候,继续尝试获取锁</li><li>将当前线程挂起,使CPU不再调度它</li></ul><p><strong>（4）selfInterrupt</strong></p><p>该方法由AQS实现, 用于中断当前线程。由于在整个抢锁过程中，我们都是不响应中断的。那如果在抢锁的过程中发生了中断怎么办呢，总不能假装没看见呀。AQS的做法简单的记录有没有有发生过中断，如果返回的时候发现曾经发生过中断，则在退出acquire方法之前，就调用selfInterrupt自我中断一下，就好像将这个发生在抢锁过程中的中断“推迟”到抢锁结束以后再发生一样。</p><p>从上面的简单介绍中可以看出，除了获取锁的逻辑 tryAcquire(arg)由子类实现外, 其余方法均由AQS实现。</p><p>接下来我们重点来看 FairSync 所实现的获取锁的逻辑:</p><h3 id="tryAcquire"><a href="#tryAcquire" class="headerlink" title="tryAcquire"></a>tryAcquire</h3><p>tryAcquire 获取锁的逻辑其实很简单——判断当前锁有没有被占用：</p><ul><li>如果锁没有被占用, 尝试以公平的方式获取锁</li><li>如果锁已经被占用, 检查是不是锁重入</li></ul><p>获取锁成功返回true, 失败则返回false</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">    final Thread current = Thread.currentThread();</span><br><span class="line">    // 首先获取当前锁的状态</span><br><span class="line">    int c = getState(); </span><br><span class="line">    </span><br><span class="line">    // c=0 说明当前锁是avaiable的, 没有被任何线程占用, 可以尝试获取</span><br><span class="line">    // 因为是实现公平锁, 所以在抢占之前首先看看队列中有没有排在自己前面的Node</span><br><span class="line">    // 如果没有人在排队, 则通过CAS方式获取锁, 就可以直接退出了</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">        if (!hasQueuedPredecessors() </span><br><span class="line">        /* 为了阅读方便, hasQueuedPredecessors源码就直接贴在这里了, 这个方法的本质实际上是检测自己是不是head节点的后继节点，即处在阻塞队列第一位的节点</span><br><span class="line">            public final boolean hasQueuedPredecessors() &#123;</span><br><span class="line">                Node t = tail; </span><br><span class="line">                Node h = head;</span><br><span class="line">                Node s;</span><br><span class="line">                return h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread());</span><br><span class="line">            &#125;</span><br><span class="line">        */</span><br><span class="line">        &amp;&amp; compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current); // 将当前线程设置为占用锁的线程</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 如果 c&gt;0 说明锁已经被占用了</span><br><span class="line">    // 对于可重入锁, 这个时候检查占用锁的线程是不是就是当前线程,是的话,说明已经拿到了锁, 直接重入就行</span><br><span class="line">    else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        int nextc = c + acquires;</span><br><span class="line">        if (nextc &lt; 0)</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        /* setState方法如下：</span><br><span class="line">        protected final void setState(int newState) &#123;</span><br><span class="line">            state = newState;</span><br><span class="line">        &#125;</span><br><span class="line">        */</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 到这里说明有人占用了锁, 并且占用锁的不是当前线程, 则获取锁失败</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里可以看出，获取锁其实主要就是干一件事：</p><blockquote><p>将state的状态通过CAS操作由0改写成1</p></blockquote><p>由于是CAS操作，必然是只有一个线程能执行成功。则执行成功的线程即获取了锁，在这之后，才有权利将exclusiveOwnerThread的值设成自己，从而“坐上铁王座”。<br>另外对于可重入锁，如果当前线程已经是获取了锁的线程了，它还要注意增加锁的重入次数。</p><p>值得一提的是，这里修改state状态的操作，一个用了CAS方法compareAndSetState，一个用了普通的setState方法。这是因为用CAS操作时，当前线程还没有获得锁，所以可能存在多线程同时在竞争锁的情况；而调用setState方法时，是在当前线程已经是持有锁的情况下，因此对state的修改是安全的，只需要普通的方法就可以了。</p><p>因此，在多线程条件下看源码时，我们一定要时刻在心中问自己：</p><blockquote><p>这段代码是否是线程安全的？同一时刻是否可能有多个线程在执行这行代码?</p></blockquote><h3 id="addWaiter"><a href="#addWaiter" class="headerlink" title="addWaiter"></a>addWaiter</h3><p>如果执行到此方法, 说明前面尝试获取锁的tryAcquire已经失败了, 既然获取锁已经失败了, 就要将当前线程包装成Node，加到等待锁的队列中去, 因为是FIFO队列, 所以自然是直接加在队尾。</p><p>方法调用为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addWaiter(Node.EXCLUSIVE)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private Node addWaiter(Node mode) &#123;</span><br><span class="line">    Node node = new Node(Thread.currentThread(), mode); //将当前线程包装成Node</span><br><span class="line">    // 这里我们用注释的形式把Node的构造函数贴出来</span><br><span class="line">    // 因为传入的mode值为Node.EXCLUSIVE，所以节点的nextWaiter属性被设为null</span><br><span class="line">    /*</span><br><span class="line">        static final Node EXCLUSIVE = null;</span><br><span class="line">        </span><br><span class="line">        Node(Thread thread, Node mode) &#123;     // Used by addWaiter</span><br><span class="line">            this.nextWaiter = mode;</span><br><span class="line">            this.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line">    */</span><br><span class="line">    Node pred = tail;</span><br><span class="line">    // 如果队列不为空, 则用CAS方式将当前节点设为尾节点</span><br><span class="line">    if (pred != null) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        if (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 代码会执行到这里, 只有两种情况:</span><br><span class="line">    //    1. 队列为空</span><br><span class="line">    //    2. CAS失败</span><br><span class="line">    // 注意, 这里是并发条件下, 所以什么都有可能发生, 尤其注意CAS失败后也会来到这里</span><br><span class="line">    enq(node); //将节点插入队列</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，每一个处于独占锁模式下的节点，它的nextWaiter一定是null。<br>在这个方法中，我们首先会尝试直接入队，但是因为目前是在并发条件下，所以有可能同一时刻，有多个线程都在尝试入队，导致compareAndSetTail(pred, node)操作失败——因为有可能其他线程已经成为了新的尾节点，导致尾节点不再是我们之前看到的那个pred了。</p><p>如果入队失败了，接下来我们就需要调用enq(node)方法，在该方法中我们将通过自旋+CAS的方式，确保当前节点入队。</p><h3 id="enq"><a href="#enq" class="headerlink" title="enq"></a>enq</h3><p>能执行到这个方法，说明当前线程获取锁已经失败了，我们已经把它包装成一个Node,准备把它扔到等待队列中去，但是在这一步又失败了。这个失败的原因可能是以下两种之一：</p><ul><li>等待队列现在是空的，没有线程在等待。</li><li>其他线程在当前线程入队的过程中率先完成了入队，导致尾节点的值已经改变了，CAS操作失败。</li></ul><p>在该方法中, 我们使用了死循环, 即以自旋方式将节点插入队列，如果失败则不停的尝试, 直到成功为止, 另外, 该方法也负责在队列为空时, 初始化队列，这也说明，队列是延时初始化的(lazily initialized)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private Node enq(final Node node) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        // 如果是空队列, 首先进行初始化</span><br><span class="line">        // 这里也可以看出, 队列不是在构造的时候初始化的, 而是延迟到需要用的时候再初始化, 以提升性能</span><br><span class="line">        if (t == null) &#123; </span><br><span class="line">            // 注意，初始化时使用new Node()方法新建了一个dummy节点</span><br><span class="line">            if (compareAndSetHead(new Node()))</span><br><span class="line">                tail = head; // 这里仅仅是将尾节点指向dummy节点，并没有返回</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        // 到这里说明队列已经不是空的了, 这个时候再继续尝试将节点加到队尾</span><br><span class="line">            node.prev = t;</span><br><span class="line">            if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                return t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里尤其要注意的是，当队列为空时，我们初始化队列并没有使用当前传进来的节点，而是： </p><p><strong>新建了一个空节点！！！</strong><br><strong>新建了一个空节点！！！</strong><br><strong>新建了一个空节点！！！</strong></p><p>在新建完空的头节点之后，我们并没有立即返回，而是将尾节点指向当前的头节点，然后进入下一轮循环。<br>在下一轮循环中，尾节点已经不为null了，此时再将我们包装了当前线程的Node加到这个空节点后面。</p><p>这就意味着，在这个等待队列中，头结点是一个“哑节点”，它不代表任何等待的线程。 </p><p><strong>head节点不代表任何线程，它就是一个空节点！！！</strong><br><strong>head节点不代表任何线程，它就是一个空节点！！！</strong><br><strong>head节点不代表任何线程，它就是一个空节点！！！</strong></p><h3 id="尾分叉"><a href="#尾分叉" class="headerlink" title="尾分叉"></a>尾分叉</h3><p>在继续往下之前，我们先分析enq方法中一个比较有趣的现象，我把它叫做尾分叉。我们着重看将当前节点设置成尾节点的操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#125; else &#123;</span><br><span class="line">// 到这里说明队列已经不是空的了, 这个时候再继续尝试将节点加到队尾</span><br><span class="line">    node.prev = t;</span><br><span class="line">    if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">        t.next = node;</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与将大象放到冰箱里需要三步一样，将一个节点node添加到sync queue的末尾也需要三步：</p><ul><li>设置node的前驱节点为当前的尾节点：node.prev = t</li><li>修改tail属性，使它指向当前节点</li><li>修改原来的尾节点，使它的next指向当前节点</li></ul><p><img src="/2019/11/08/逐行分析AQS源码1——独占锁的获取/4.jpg" alt=""></p><p>但是需要注意的，这里的三步并不是一个原子操作，第一步很容易成功；而第二步由于是一个CAS操作，在并发条件下有可能失败，第三步只有在第二步成功的条件下才执行。这里的CAS保证了同一时刻只有一个节点能成为尾节点，其他节点将失败，失败后将回到for循环中继续重试。</p><p>所以，当有大量的线程在同时入队的时候，同一时刻，只有一个线程能完整地完成这三步，<strong>而其他线程只能完成第一步</strong>，于是就出现了尾分叉：</p><p><img src="/2019/11/08/逐行分析AQS源码1——独占锁的获取/5.jpg" alt=""></p><p>注意，这里第三步是在第二步执行成功后才执行的，这就意味着，有可能即使我们已经完成了第二步，将新的节点设置成了尾节点，此时原来旧的尾节点的next值可能还是null(因为还没有来的及执行第三步)，所以如果此时有线程恰巧从头节点开始向后遍历整个链表，则它是遍历不到新加进来的尾节点的，但是这显然是不合理的，因为现在的tail已经指向了新的尾节点。<br>另一方面，当我们完成了第二步之后，第一步一定是完成了的，所以如果我们从尾节点开始向前遍历，已经可以遍历到所有的节点。这也就是为什么我们在AQS相关的源码中，有时候常常会出现从尾节点开始逆向遍历链表——因为一个节点要能入队，则它的prev属性一定是有值的，但是它的next属性可能暂时还没有值。</p><p>至于那些“分叉”的入队失败的其他节点，在下一轮的循环中，它们的prev属性会重新指向新的尾节点，继续尝试新的CAS操作，最终，所有节点都会通过自旋不断的尝试入队，直到成功为止。</p><h3 id="addWaiter总结"><a href="#addWaiter总结" class="headerlink" title="addWaiter总结"></a>addWaiter总结</h3><p>至此，我们就完成了addWaiter(Node.EXCLUSIVE)方法的完整的分析，该方法并不设计到任何关于锁的操作，它就是解决了并发条件下的节点入队问题。具体来说就是该方法保证了将当前线程包装成Node节点加入到等待队列的队尾，如果队列为空，则会新建一个哑节点作为头节点，再将当前节点接在头节点的后面。</p><p>addWaiter(Node.EXCLUSIVE)方法最终返回了代表了当前线程的Node节点，在返回的那一刻，这个节点必然是当时的sync queue的尾节点。</p><p>不过值得注意的是，enq方法也是有返回值（虽然这里我们并没有使用它的返回值），但是它返回的是node节点的前驱节点，这个返回值虽然在addWaiter方法中并没有使用，但是在其他地方会被用到。</p><p>我们再回到获取锁的逻辑中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当addWaiter(Node.EXCLUSIVE)执行完毕后，节点现在已经被成功添加到sync queue中了，接下来将执行acquireQueued方法。</p><h3 id="acquireQueued"><a href="#acquireQueued" class="headerlink" title="acquireQueued"></a>acquireQueued</h3><p>该方法是最复杂的一个方法, 也是最难啃的骨头, 看代码之前首先简单的说明几点:</p><p>(1) 能执行到该方法, 说明addWaiter 方法已经成功将包装了当前Thread的节点添加到了等待队列的队尾<br>(2) 该方法中将再次尝试去获取锁<br>(3) 在再次尝试获取锁失败后, 判断是否需要把当前线程挂起</p><p>为什么前面获取锁失败了, 这里还要再次尝试获取锁呢?<br>首先, 这里再次尝试获取锁是基于一定的条件的,即:</p><blockquote><p>当前节点的前驱节点就是HEAD节点</p></blockquote><p>因为我们知道，head节点就是个哑节点，它不代表任何线程，或者代表了持有锁的线程，如果当前节点的前驱节点就是head节点，那就说明当前节点已经是排在整个等待队列最前面的了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">    boolean failed = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted = false;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final Node p = node.predecessor();</span><br><span class="line">            // 在当前节点的前驱就是HEAD节点时, 再次尝试获取锁</span><br><span class="line">            if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = null; // help GC</span><br><span class="line">                failed = false;</span><br><span class="line">                return interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            //在获取锁失败后, 判断是否需要把当前线程挂起</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">                interrupted = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这里又来了个自旋操作，我们一段段来看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">final Node p = node.predecessor();</span><br><span class="line">// 在当前节点的前驱就是HEAD节点时, 再次尝试获取锁</span><br><span class="line">if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">    setHead(node);</span><br><span class="line">    p.next = null; // help GC</span><br><span class="line">    failed = false;</span><br><span class="line">    return interrupted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们获取尾节点的前驱节点（因为上一步中返回的就是尾节点，并且这个节点就是代表了当前线程的Node）。<br>如果前驱节点就是head节点，那说明当前线程已经排在了队列的最前面，所以这里我们再试着去获取锁。如果这一次获取成功了，即tryAcquire方法返回了true, 则我们将进入if代码块，调用setHead方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private void setHead(Node node) &#123;</span><br><span class="line">    head = node;</span><br><span class="line">    node.thread = null;</span><br><span class="line">    node.prev = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法将head指向传进来的node,并且将node的thread和prev属性置为null, 如下图所示：</p><p><img src="/2019/11/08/逐行分析AQS源码1——独占锁的获取/6.jpg" alt=""></p><p>可以看出，这个方法的本质是丢弃原来的head，将head指向已经获得了锁的node。但是接着又将该node的thread属性置为null了，<strong>这某种意义上导致了这个新的head节点又成为了一个哑节点，它不代表任何线程</strong>。为什么要这样做呢，因为在tryAcquire调用成功后，exclusiveOwnerThread属性就已经记录了当前获取锁的线程了，此处没有必要再记录。<strong>这某种程度上就是将当前线程从等待队列里面拿出来了，是一个变相的出队操作</strong>。</p><p>还有另外一个特点是，这个setHead方法只是个普通方法，并没有像之前enq方法中那样采用compareAndSetHead方法，这是为什么呢？ 同我们之前分析setState方法一样：</p><p>因为这里不会产生竞争！</p><p>在enq方法中，当我们设置头节点的时候，是新建一个哑节点并将它作为头节点，这个时候，可能多个线程都在执行这一步，因此我们需要通过CAS操作保证只有一个线程能成功。<br>在acquireQueued方法里，由于我们在调用到setHead的时，已经通过tryAcquire方法获得了锁，这意味着：</p><ul><li>此时没有其他线程在创建新的头节点——因为很明显此时队列并不是空的，不会执行到创建头节点的代码</li><li>此时能执行setHead的只有一个线程——因为要执行到setHead, 必然是tryAcquire已经返回了true, 而同一时刻，只有一个线程能获取到锁</li></ul><p>综上，在整个if语句内的代码即使不加锁，也是线程安全的，不需要采用CAS操作。</p><p>接下来我们再来看看另一种情况，即p == head &amp;&amp; tryAcquire(arg)返回了false，此时我们需要判断是否需要将当前线程挂起：</p><h3 id="shouldParkAfterFailedAcquire"><a href="#shouldParkAfterFailedAcquire" class="headerlink" title="shouldParkAfterFailedAcquire"></a>shouldParkAfterFailedAcquire</h3><p>从函数名也可以看出, 该方法用于决定在获取锁失败后, 是否将线程挂起.</p><p>决定的依据就是前驱节点的waitStatus值。</p><p>（有没发现一直到现在，前面的分析中我们都没有用到waitStatus的值，终于在这里要用到了）</p><p>我们先来回顾一下waitStatus有哪些状态值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int CANCELLED =  1;</span><br><span class="line">static final int SIGNAL    = -1;</span><br><span class="line">static final int CONDITION = -2;</span><br><span class="line">static final int PROPAGATE = -3;</span><br></pre></td></tr></table></figure><p>一共有四种状态，但是我们在开篇的时候就说过，在独占锁锁的获取操作中，我们只用到了其中的两个——CANCELLED和SIGNAL。<br>当然，前面我们在创建节点的时候并没有给waitStatus赋值，因此每一个节点最开始的时候waitStatus的值都被初始化为0，即不属于上面任何一种状态。</p><p>那么CANCELLED和SIGNAL代表什么意思呢？</p><p>CANCELLED状态很好理解，它表示Node所代表的当前线程已经取消了排队，即放弃获取锁了。</p><p>SIGNAL这个状态就有点意思了，它不是表征当前节点的状态，而是当前节点的下一个节点的状态。<br>当一个节点的waitStatus被置为SIGNAL，就说明它的下一个节点（即它的后继节点）已经被挂起了（或者马上就要被挂起了），因此在当前节点释放了锁或者放弃获取锁时，如果它的waitStatus属性为SIGNAL，它还要完成一个额外的操作——唤醒它的后继节点。</p><p>有意思的是，SIGNAL这个状态的设置常常不是节点自己给自己设的，而是后继节点设置的，这里给大家打个比方：</p><p>比如说出去吃饭，在人多的时候经常要排队取号，你取到了8号，前面还有7个人在等着进去，你就和排在你前面的7号讲“哥们，我现在排在你后面，队伍这么长，估计一时半会儿也轮不到我，我去那边打个盹，一会轮到你进去了(release)或者你不想等了(cancel), 麻烦你都叫醒我”，说完，你就把他的waitStatus值设成了SIGNAL。</p><p>换个角度讲，当我们决定要将一个线程挂起之前，首先要确保自己的前驱节点的waitStatus为SIGNAL，这就相当于给自己设一个闹钟再去睡，这个闹钟会在恰当的时候叫醒自己，否则，如果一直没有人来叫醒自己，自己可能就一直睡到天荒地老了。</p><p>理解了CANCELLED和SIGNAL这两个状态的含义后，我们再来看看shouldParkAfterFailedAcquire是怎么用的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span><br><span class="line">    int ws = pred.waitStatus; // 获得前驱节点的ws</span><br><span class="line">    if (ws == Node.SIGNAL)</span><br><span class="line">        // 前驱节点的状态已经是SIGNAL了，说明闹钟已经设了，可以直接睡了</span><br><span class="line">        return true;</span><br><span class="line">    if (ws &gt; 0) &#123;</span><br><span class="line">        // 当前节点的 ws &gt; 0, 则为 Node.CANCELLED 说明前驱节点已经取消了等待锁(由于超时或者中断等原因)</span><br><span class="line">        // 既然前驱节点不等了, 那就继续往前找, 直到找到一个还在等待锁的节点</span><br><span class="line">        // 然后我们跨过这些不等待锁的节点, 直接排在等待锁的节点的后面 (是不是很开心!!!)</span><br><span class="line">        do &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; while (pred.waitStatus &gt; 0);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 前驱节点的状态既不是SIGNAL，也不是CANCELLED</span><br><span class="line">        // 用CAS设置前驱节点的ws为 Node.SIGNAL，给自己定一个闹钟</span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，shouldParkAfterFailedAcquire所做的事情无外乎：</p><ul><li>如果为前驱节点的waitStatus值为 Node.SIGNAL 则直接返回 true</li><li>如果为前驱节点的waitStatus值为 Node.CANCELLED (ws &gt; 0), 则跳过那些节点, 重新寻找正常等待中的前驱节点，然后排在它后面，返回false</li><li>其他情况, 将前驱节点的状态改为 Node.SIGNAL, 返回false</li></ul><p>注意了，这个函数只有在当前节点的前驱节点的waitStatus状态本身就是SIGNAL的时候才会返回true, 其他时候都会返回false, 我们再回到这个方法的调用处：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">    boolean failed = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted = false;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final Node p = node.predecessor();</span><br><span class="line">            if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = null; // help GC</span><br><span class="line">                failed = false;</span><br><span class="line">                return interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            // 我们在这里！在这里！！在这里！！！</span><br><span class="line">            // 我们在这里！在这里！！在这里！！！</span><br><span class="line">            // 我们在这里！在这里！！在这里！！！</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">                interrupted = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，当shouldParkAfterFailedAcquire返回false后，会继续回到循环中再次尝试获取锁——这是因为此时我们的前驱节点可能已经变了（搞不好前驱节点就变成head节点了呢）。</p><p>当shouldParkAfterFailedAcquire返回true，即当前节点的前驱节点的waitStatus状态已经设为SIGNAL后，我们就可以安心的将当前线程挂起了，此时我们将调用parkAndCheckInterrupt：</p><h3 id="parkAndCheckInterrupt"><a href="#parkAndCheckInterrupt" class="headerlink" title="parkAndCheckInterrupt"></a>parkAndCheckInterrupt</h3><p>到这个函数已经是最后一步了, 就是将线程挂起, 等待被唤醒</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private final boolean parkAndCheckInterrupt() &#123;</span><br><span class="line">    LockSupport.park(this); // 线程被挂起，停在这里不再往下执行了</span><br><span class="line">    return Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意！LockSupport.park(this)执行完成后线程就被挂起了，除非其他线程unpark了当前线程，或者当前线程被中断了，否则代码是不会再往下执行的，后面的Thread.interrupted()也不会被执行，那后面这个Thread.interrupted()是干什么用的呢？ 我们下一篇再讲。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>AQS中用state属性表示锁，如果能成功将state属性通过CAS操作从0设置成1即获取了锁</li><li>获取了锁的线程才能将exclusiveOwnerThread设置成自己</li><li>addWaiter负责将当前等待锁的线程包装成Node,并成功地添加到队列的末尾，这一点是由它调用的enq方法保证的，enq方法同时还负责在队列为空时初始化队列。</li><li>acquireQueued方法用于在Node成功入队后，继续尝试获取锁（取决于Node的前驱节点是不是head），或者将线程挂起</li><li>shouldParkAfterFailedAcquire方法用于保证当前线程的前驱节点的waitStatus属性值为SIGNAL,从而保证了自己挂起后，前驱节点会负责在合适的时候唤醒自己。</li><li>parkAndCheckInterrupt方法用于挂起当前线程，并检查中断状态。</li><li>如果最终成功获取了锁，线程会从lock()方法返回，继续往下执行；否则，线程会阻塞等待。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;AQS（AbstractQueuedSynchronizer）是JAVA中众多锁以及并发工具的基础，其底层采用乐观锁，大量使用了CAS操作，
      
    
    </summary>
    
      <category term="并发编程" scheme="http://ruanshubin.top/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://ruanshubin.top/tags/Java/"/>
    
      <category term="并发" scheme="http://ruanshubin.top/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>逐行分析AQS源码2--独占锁的释放</title>
    <link href="http://ruanshubin.top/2019/11/08/%E9%80%90%E8%A1%8C%E5%88%86%E6%9E%90AQS%E6%BA%90%E7%A0%812%E2%80%94%E2%80%94%E7%8B%AC%E5%8D%A0%E9%94%81%E7%9A%84%E9%87%8A%E6%94%BE/"/>
    <id>http://ruanshubin.top/2019/11/08/逐行分析AQS源码2——独占锁的释放/</id>
    <published>2019-11-08T13:30:00.000Z</published>
    <updated>2019-12-25T05:51:12.935Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章 我们逐行分析了独占锁的获取操作, 本篇文章我们来看看独占锁的释放。如果前面的锁的获取流程你已经趟过一遍了, 那锁的释放部分就很简单了, 这篇文章我们直接开始看源码.</p><p>开始之前先提一句, JAVA的内置锁在退出临界区之后是会自动释放锁的, 但是ReentrantLock这样的显式锁是需要自己显式的释放的, 所以在加锁之后一定不要忘记在finally块中进行显式的锁释放:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = new ReentrantLock();</span><br><span class="line">...</span><br><span class="line">lock.lock();</span><br><span class="line">try &#123;</span><br><span class="line">    // 更新对象</span><br><span class="line">    //捕获异常</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>一定要记得在 finally 块中释放锁! ! !</strong><br><strong>一定要记得在 finally 块中释放锁! ! !</strong><br><strong>一定要记得在 finally 块中释放锁! ! !</strong></p><h2 id="Example-ReentrantLock的锁释放"><a href="#Example-ReentrantLock的锁释放" class="headerlink" title="Example: ReentrantLock的锁释放"></a>Example: ReentrantLock的锁释放</h2><p>由于锁的释放操作对于公平锁和非公平锁都是一样的, 所以, unlock的逻辑并没有放在 FairSync 或 NonfairSync 里面, 而是直接定义在 ReentrantLock类中:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void unlock() &#123;</span><br><span class="line">    sync.release(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于释放锁的逻辑很简单, 这里就不画流程图了, 我们直接看源码:</p><h3 id="release"><a href="#release" class="headerlink" title="release"></a>release</h3><p>release方法定义在AQS类中，描述了释放锁的流程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h.waitStatus != 0)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出, 相比获取锁的acquire方法, 释放锁的过程要简单很多, 它只涉及到两个子函数的调用:</p><ul><li>tryRelease(arg)<ul><li>该方法由继承AQS的子类实现, 为释放锁的具体逻辑</li></ul></li><li>unparkSuccessor(h)<ul><li>唤醒后继线程</li></ul></li></ul><p>下面我们分别分析这两个子函数</p><h3 id="tryRelease"><a href="#tryRelease" class="headerlink" title="tryRelease"></a>tryRelease</h3><p>tryRelease方法由ReentrantLock的静态类Sync实现:</p><p>多嘴提醒一下, 能执行到释放锁的线程, 一定是已经获取了锁的线程(这不废话嘛!)</p><p>另外, 相比获取锁的操作, 这里并没有使用任何CAS操作, 也是因为当前线程已经持有了锁, 所以可以直接安全的操作, 不会产生竞争.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">    </span><br><span class="line">    // 首先将当前持有锁的线程个数减1(回溯到调用源头sync.release(1)可知, releases的值为1)</span><br><span class="line">    // 这里的操作主要是针对可重入锁的情况下, c可能大于1</span><br><span class="line">    int c = getState() - releases; </span><br><span class="line">    </span><br><span class="line">    // 释放锁的线程当前必须是持有锁的线程</span><br><span class="line">    if (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    </span><br><span class="line">    // 如果c为0了, 说明锁已经完全释放了</span><br><span class="line">    boolean free = false;</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">        free = true;</span><br><span class="line">        setExclusiveOwnerThread(null);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    return free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是很简单? 代码都是自解释的, LZ就不多嘴了.</p><h3 id="unparkSuccessor"><a href="#unparkSuccessor" class="headerlink" title="unparkSuccessor"></a>unparkSuccessor</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h.waitStatus != 0)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>锁成功释放之后, 接下来就是唤醒后继节点了, 这个方法同样定义在AQS中.</p><p>值得注意的是, 在成功释放锁之后(tryRelease 返回 true之后), 唤醒后继节点只是一个 “附加操作”, 无论该操作结果怎样, 最后 release操作都会返回 true.</p><blockquote><p>事实上, unparkSuccessor 函数也不会返回任何值</p></blockquote><p>接下来我们就看看unparkSuccessor的源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private void unparkSuccessor(Node node) &#123;</span><br><span class="line">    int ws = node.waitStatus;</span><br><span class="line">    </span><br><span class="line">    // 如果head节点的ws比0小, 则直接将它设为0</span><br><span class="line">    if (ws &lt; 0)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, 0);</span><br><span class="line"></span><br><span class="line">    // 通常情况下, 要唤醒的节点就是自己的后继节点</span><br><span class="line">    // 如果后继节点存在且也在等待锁, 那就直接唤醒它</span><br><span class="line">    // 但是有可能存在 后继节点取消等待锁 的情况</span><br><span class="line">    // 此时从尾节点开始向前找起, 直到找到距离head节点最近的ws&lt;=0的节点</span><br><span class="line">    Node s = node.next;</span><br><span class="line">    if (s == null || s.waitStatus &gt; 0) &#123;</span><br><span class="line">        s = null;</span><br><span class="line">        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            if (t.waitStatus &lt;= 0)</span><br><span class="line">                s = t; // 注意! 这里找到了并没有return, 而是继续向前找</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果找到了还在等待锁的节点,则唤醒它</span><br><span class="line">    if (s != null)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上一篇文章分析 shouldParkAfterFailedAcquire 方法的时候, 我们重点提到了当前节点的前驱节点的 waitStatus 属性, 该属性决定了我们是否要挂起当前线程, 并且我们知道, 如果一个线程被挂起了, 它的前驱节点的 waitStatus值必然是Node.SIGNAL.</p><p>在唤醒后继节点的操作中, 我们也需要依赖于节点的waitStatus值.</p><p>下面我们仔细分析 unparkSuccessor函数:</p><p>首先, 传入该函数的参数node就是头节点head, 并且条件是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h != null &amp;&amp; h.waitStatus != 0</span><br></pre></td></tr></table></figure><p>h!=null 我们容易理解, h.waitStatus != 0是个什么意思呢?</p><p>我不妨逆向来思考一下, waitStatus在什么条件下等于0? 从上一篇文章到现在, 我们发现之前给 waitStatus赋值过的地方只有一处, 那就是shouldParkAfterFailedAcquire 函数中将前驱节点的 waitStatus设为Node.SIGNAL, 除此之外, 就没有了.</p><p>然而, 真的没有了吗???</p><p>其实还有一处, 那就是新建一个节点的时候, 在addWaiter 函数中, 当我们将一个新的节点添加进队列或者初始化空队列的时候, 都会新建节点 而新建的节点的waitStatus在没有赋值的情况下都会初始化为0.</p><p>所以当一个head节点的waitStatus为0说明什么呢, 说明这个head节点后面没有在挂起等待中的后继节点了(如果有的话, head的ws就会被后继节点设为Node.SIGNAL了), 自然也就不要执行 unparkSuccessor 操作了.</p><p>另外一个有趣的问题是, 为什么要从尾节点开始逆向查找, 而不是直接从head节点往后正向查找, 这样只要正向找到第一个, 不就可以停止查找了吗?</p><p>首先我们要看到，从后往前找是基于一定条件的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (s == null || s.waitStatus &gt; 0)</span><br></pre></td></tr></table></figure><p>即后继节点不存在，或者后继节点取消了排队，这一条件大多数条件下是不满足的。因为虽然后继节点取消排队很正常，但是通过上一篇我们介绍的shouldParkAfterFailedAcquire方法可知，节点在挂起前，都会给自己找一个waitStatus状态为SIGNAL的前驱节点，而跳过那些已经cancel掉的节点。</p><p>所以，这个从后往前找的目的其实是为了照顾刚刚加入到队列中的节点，这就牵涉到我们上一篇特别介绍的“尾分叉”了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private Node addWaiter(Node mode) &#123;</span><br><span class="line">    Node node = new Node(Thread.currentThread(), mode); //将当前线程包装成Node</span><br><span class="line">    Node pred = tail;</span><br><span class="line">    // 如果队列不为空, 则用CAS方式将当前节点设为尾节点</span><br><span class="line">    if (pred != null) &#123;</span><br><span class="line">        node.prev = pred; //step 1, 设置前驱节点</span><br><span class="line">        if (compareAndSetTail(pred, node)) &#123; // step2, 将当前节点设置成新的尾节点</span><br><span class="line">            pred.next = node; // step 3, 将前驱节点的next属性指向自己</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node); </span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你仔细看上面这段代码, 可以发现节点入队不是一个原子操作, 虽然用了compareAndSetTail操作保证了当前节点被设置成尾节点，但是只能保证，此时step1和step2是执行完成的，有可能在step3还没有来的及执行到的时候，我们的unparkSuccessor方法就开始执行了，此时pred.next的值还没有被设置成node，所以从前往后遍历的话是遍历不到尾节点的，但是因为尾节点此时已经设置完成，node.prev = pred操作也被执行过了，也就是说，如果从后往前遍历的话，新加的尾节点就可以遍历到了，并且可以通过它一直往前找。</p><p>所以总结来说，之所以从后往前遍历是因为，我们是处于多线程并发的条件下的，如果一个节点的next属性为null, 并不能保证它就是尾节点（可能是因为新加的尾节点还没来得及执行pred.next = node）, 但是一个节点如果能入队, 则它的prev属性一定是有值的,所以反向查找一定是最精确的。</p><p>最后, 在调用了 LockSupport.unpark(s.thread) 也就是唤醒了线程之后, 会发生什么呢?</p><p>当然是回到最初的原点啦, 从哪里跌倒(被挂起)就从哪里站起来(唤醒)呗:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private final boolean parkAndCheckInterrupt() &#123;</span><br><span class="line">    LockSupport.park(this); // 喏, 就是在这里被挂起了, 唤醒之后就能继续往下执行了</span><br><span class="line">    return Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那接下来做什么呢?</p><p>还记得我们上一篇在讲“锁的获取”的时候留的问题吗？ 如果线程从这里唤醒了，它将接着往下执行。</p><p>注意，这里有两个线程：<br>一个是我们这篇讲的线程，它正在释放锁，并调用了LockSupport.unpark(s.thread) 唤醒了另外一个线程;<br>而这个另外一个线程，就是我们上一节讲的因为抢锁失败而被阻塞在LockSupport.park(this)处的线程。</p><p>我们再倒回上一篇结束的地方，看看这个被阻塞的线程被唤醒后，会发生什么。从上面的代码可以看出，他将调用 Thread.interrupted()并返回。</p><p>我们知道，Thread.interrupted()这个函数将返回当前正在执行的线程的中断状态，并清除它。接着，我们再返回到parkAndCheckInterrupt被调用的地方:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">    boolean failed = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted = false;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final Node p = node.predecessor();</span><br><span class="line">            if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = null; // help GC</span><br><span class="line">                failed = false;</span><br><span class="line">                return interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            // 我们在这里！在这里！！在这里！！！</span><br><span class="line">            // 我们在这里！在这里！！在这里！！！</span><br><span class="line">            // 我们在这里！在这里！！在这里！！！</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">                interrupted = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体来说，就是这个if语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">    interrupted = true;</span><br></pre></td></tr></table></figure><p>可见，如果Thread.interrupted()返回true，则 parkAndCheckInterrupt()就返回true, if条件成立，interrupted状态将设为true;<br>如果Thread.interrupted()返回false, 则 interrupted 仍为false。</p><p>再接下来我们又回到了for (;;) 死循环的开头，进行新一轮的抢锁。</p><p>假设这次我们抢到了，我们将从 return interrupted处返回，返回到哪里呢？ 当然是acquireQueued的调用处啦:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到，如果acquireQueued的返回值为true, 我们将执行 selfInterrupt():</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static void selfInterrupt() &#123;</span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而它的作用，就是中断当前线程。</p><p>绕了这么一大圈，到最后还是中断了当前线程，到底是在干嘛呢？</p><p>其实这一切的原因都在于:</p><p><strong>我们并不知道线程被唤醒的原因</strong>。</p><p>具体来说，当我们从LockSupport.park(this)处被唤醒，我们并不知道是因为什么原因被唤醒，可能是因为别的线程释放了锁，调用了 LockSupport.unpark(s.thread)，<strong>也有可能是因为当前线程在等待中被中断了</strong>，因此我们通过Thread.interrupted()方法检查了当前线程的中断标志，并将它记录下来，在我们最后返回acquire方法后，<strong>如果发现当前线程曾经被中断过，那我们就把当前线程再中断一次</strong>。</p><p>为什么要这么做呢？</p><p>从上面的代码中我们知道，即使线程在等待资源的过程中被中断唤醒，它还是会不依不饶的再抢锁，直到它抢到锁为止。也就是说，它是不响应这个中断的，仅仅是记录下自己被人中断过。</p><p>最后，当它抢到锁返回了，如果它发现自己曾经被中断过，它就再中断自己一次，将这个中断补上。</p><p>注意，中断对线程来说只是一个建议，一个线程被中断只是其中断状态被设为true, 线程可以选择忽略这个中断，中断一个线程并不会影响线程的执行。</p><p>最后再小小的插一句，事实上在我们从return interrupted;处返回时并不是直接返回的，因为还有一个finally代码块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">finally &#123;</span><br><span class="line">    if (failed)</span><br><span class="line">        cancelAcquire(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它做了一些善后工作，但是条件是failed为true，而从前面的分析中我们知道，要从for(;;)中跳出来，只有一种可能，那就是当前线程已经拿到了锁，因为整个争锁过程我们都是不响应中断的，所以不可能有异常抛出，既然是拿到了锁，failed就一定是false，所以这个finally块在这里实际上并没有什么用，它是为响应中断式的抢锁所服务的，这一点我们以后有机会再讲。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一篇文章 我们逐行分析了独占锁的获取操作, 本篇文章我们来看看独占锁的释放。如果前面的锁的获取流程你已经趟过一遍了, 那锁的释放部分就很简单了, 这篇文章我们直接开始看源码.&lt;/p&gt;
&lt;p&gt;开始之前先提一句, JAVA的内置锁在退出临界区之后是会自动释放锁的, 但是Ree
      
    
    </summary>
    
      <category term="并发编程" scheme="http://ruanshubin.top/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://ruanshubin.top/tags/Java/"/>
    
      <category term="并发" scheme="http://ruanshubin.top/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>逐行分析AQS源码3--共享锁的获取与释放</title>
    <link href="http://ruanshubin.top/2019/11/08/%E9%80%90%E8%A1%8C%E5%88%86%E6%9E%90AQS%E6%BA%90%E7%A0%813%E2%80%94%E2%80%94%E5%85%B1%E4%BA%AB%E9%94%81%E7%9A%84%E8%8E%B7%E5%8F%96%E4%B8%8E%E9%87%8A%E6%94%BE/"/>
    <id>http://ruanshubin.top/2019/11/08/逐行分析AQS源码3——共享锁的获取与释放/</id>
    <published>2019-11-08T13:30:00.000Z</published>
    <updated>2019-12-25T05:51:43.179Z</updated>
    
    <content type="html"><![CDATA[<h2 id="共享锁与独占锁的区别"><a href="#共享锁与独占锁的区别" class="headerlink" title="共享锁与独占锁的区别"></a>共享锁与独占锁的区别</h2><p>共享锁与独占锁最大的区别在于，独占锁是<strong>独占的，排他的</strong>，因此在独占锁中有一个exclusiveOwnerThread属性，用来记录当前持有锁的线程。<strong>当独占锁已经被某个线程持有时，其他线程只能等待它被释放后，才能去争锁，并且同一时刻只有一个线程能争锁成功</strong>。</p><p>而对于共享锁而言，由于锁是可以被共享的，因此<strong>它可以被多个线程同时持有</strong>。换句话说，如果一个线程成功获取了共享锁，那么其他等待在这个共享锁上的线程就也可以尝试去获取锁，并且极有可能获取成功。</p><p>共享锁的实现和独占锁是对应的，我们可以从下面这张表中看出：</p><div class="table-container"><table><thead><tr><th style="text-align:center">独占锁</th><th style="text-align:center">共享锁</th></tr></thead><tbody><tr><td style="text-align:center">tryAcquire(int arg)</td><td style="text-align:center">tryAcquireShared(int arg)</td></tr><tr><td style="text-align:center">tryAcquireNanos(int arg, long nanosTimeout)</td><td style="text-align:center">tryAcquireSharedNanos(int arg, long nanosTimeout)</td></tr><tr><td style="text-align:center">acquire(int arg)</td><td style="text-align:center">acquireShared(int arg)</td></tr><tr><td style="text-align:center">acquireQueued(final Node node, int arg)</td><td style="text-align:center">doAcquireShared(int arg)</td></tr><tr><td style="text-align:center">acquireInterruptibly(int arg)</td><td style="text-align:center">acquireSharedInterruptibly(int arg)</td></tr><tr><td style="text-align:center">doAcquireInterruptibly(int arg)</td><td style="text-align:center">doAcquireSharedInterruptibly(int arg)</td></tr><tr><td style="text-align:center">doAcquireNanos(int arg, long nanosTimeout)</td><td style="text-align:center">doAcquireSharedNanos(int arg, long nanosTimeout)</td></tr><tr><td style="text-align:center">release(int arg)</td><td style="text-align:center">releaseShared(int arg)</td></tr><tr><td style="text-align:center">tryRelease(int arg)</td><td style="text-align:center">tryReleaseShared(int arg)</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">doReleaseShared()</td></tr></tbody></table></div><p>可以看出，除了最后一个属于共享锁的doReleaseShared()方法没有对应外，其他的方法，独占锁和共享锁都是一一对应的。</p><p>事实上，其实与doReleaseShared()对应的独占锁的方法应当是unparkSuccessor(h)，只是doReleaseShared()逻辑不仅仅包含了unparkSuccessor(h)，还包含了其他操作，这一点我们下面分析源码的时候再看。</p><p>另外，尤其需要注意的是，在独占锁模式中，我们只有在获取了独占锁的节点释放锁时，才会唤醒后继节点——这是合理的，因为独占锁只能被一个线程持有，如果它还没有被释放，就没有必要去唤醒它的后继节点。</p><p>然而，在共享锁模式下，当一个节点获取到了共享锁，我们在获取成功后就可以唤醒后继节点了，而不需要等到该节点释放锁的时候，这是因为共享锁可以被多个线程同时持有，一个锁获取到了，则后继的节点都可以直接来获取。因此，<strong>在共享锁模式下，在获取锁和释放锁结束时，都会唤醒后继节点</strong>。 这一点也是doReleaseShared()方法与unparkSuccessor(h)方法无法直接对应的根本原因所在。</p><h2 id="共享锁的获取"><a href="#共享锁的获取" class="headerlink" title="共享锁的获取"></a>共享锁的获取</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public final void acquireShared(int arg) &#123;</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们拿它和独占锁模式对比一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两者的结构看上去似乎有点差别，但事实上是一样的，只不过是共享锁模式下，将与addWaiter(Node.EXCLUSIVE)对应的addWaiter(Node.SHARED)，以及selfInterrupt()操作全部移到了doAcquireShared方法内部，这一点我们在下面分析doAcquireShared方法时就一目了然了。</p><p>不过这里先插一句，相对于独占的锁的tryAcquire(int arg)返回boolean类型的值，共享锁的tryAcquireShared(int acquires)返回的是一个整型值：</p><ul><li>如果该值小于0，则代表当前线程获取共享锁失败</li><li>如果该值大于0，则代表当前线程获取共享锁成功，并且接下来其他线程尝试获取共享锁的行为很可能成功</li><li>如果该值等于0，则代表当前线程获取共享锁成功，但是接下来其他线程尝试获取共享锁的行为会失败<br>因此，只要该返回值大于等于0，就表示获取共享锁成功。</li></ul><p>acquireShared中的tryAcquireShared方法由具体的子类负责实现，这里我们暂且不表。</p><p>接下来我们看看doAcquireShared方法，它对应于独占锁的acquireQueued，两者其实很类似，我们把它们相同的部分注释掉，只看不同的部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private void doAcquireShared(int arg) &#123;</span><br><span class="line">    final Node node = addWaiter(Node.SHARED);</span><br><span class="line">    /*boolean failed = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted = false;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final Node p = node.predecessor();*/</span><br><span class="line">            if (p == head) &#123;</span><br><span class="line">                int r = tryAcquireShared(arg);</span><br><span class="line">                if (r &gt;= 0) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = null; // help GC</span><br><span class="line">                    if (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = false;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            /*if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于上面的if部分，独占锁对应的acquireQueued方法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">    setHead(node);</span><br><span class="line">    p.next = null; // help GC</span><br><span class="line">    failed = false;</span><br><span class="line">    return interrupted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，综合来看，这两者的逻辑仅有两处不同：</p><ul><li>addWaiter(Node.EXCLUSIVE) -&gt; addWaiter(Node.SHARED)</li><li>setHead(node) -&gt; setHeadAndPropagate(node, r)</li></ul><p>这里第一点不同就是独占锁的acquireQueued调用的是addWaiter(Node.EXCLUSIVE)，而共享锁调用的是addWaiter(Node.SHARED)，表明了该节点处于共享模式，这两种模式的定义为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">** Marker to indicate a node is waiting in shared mode */</span><br><span class="line">static final Node SHARED = new Node();</span><br><span class="line">/** Marker to indicate a node is waiting in exclusive mode */</span><br><span class="line">static final Node EXCLUSIVE = null;</span><br></pre></td></tr></table></figure><p>该模式被赋值给了节点的nextWaiter属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Node(Thread thread, Node mode) &#123;     // Used by addWaiter</span><br><span class="line">    this.nextWaiter = mode;</span><br><span class="line">    this.thread = thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道，在条件队列中，nextWaiter是指向条件队列中的下一个节点的，它将条件队列中的节点串起来，构成了单链表。但是在sync queue队列中，我们只用prev,next属性来串联节点，形成双向链表，nextWaiter属性在这里只起到一个标记作用，不会串联节点，这里不要被Node SHARED = new Node()所指向的空节点迷惑，这个空节点并不属于sync queue，不代表任何线程，它只起到标记作用，仅仅用作判断节点是否处于共享模式的依据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Node#isShard()</span><br><span class="line">final boolean isShared() &#123;</span><br><span class="line">    return nextWaiter == SHARED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的第二点不同就在于获取锁成功后的行为，对于独占锁而言，是直接调用了setHead(node)方法，而共享锁调用的是setHeadAndPropagate(node, r)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void setHeadAndPropagate(Node node, int propagate) &#123;</span><br><span class="line">    Node h = head; // Record old head for check below</span><br><span class="line">    setHead(node);</span><br><span class="line"></span><br><span class="line">    if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 ||</span><br><span class="line">        (h = head) == null || h.waitStatus &lt; 0) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        if (s == null || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该方法内部我们不仅调用了setHead(node)，还在一定条件下调用了doReleaseShared()来唤醒后继的节点。这是因为在共享锁模式下，锁可以被多个线程所共同持有，既然当前线程已经拿到共享锁了，那么就可以直接通知后继节点来拿锁，而不必等待锁被释放的时候再通知。</p><p>关于这个doReleaseShared方法，我们到下面分析锁释放的时候再看。</p><h2 id="共享锁的释放"><a href="#共享锁的释放" class="headerlink" title="共享锁的释放"></a>共享锁的释放</h2><p>我们使用releaseShared(int arg)方法来释放共享锁：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法对应于独占锁的release(int arg)方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h.waitStatus != 0)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在独占锁模式下，由于头节点就是持有独占锁的节点，在它释放独占锁后，如果发现自己的waitStatus不为0，则它将负责唤醒它的后继节点。</p><p>在共享锁模式下，头节点就是持有共享锁的节点，在它释放共享锁后，它也应该唤醒它的后继节点，但是值得注意的是，我们在之前的setHeadAndPropagate方法中可能已经调用过该方法了，也就是说<strong>它可能会被同一个头节点调用两次</strong>，也有可能在我们从releaseShared方法中调用它时，当前的头节点已经易主了，下面我们就来详细看看这个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private void doReleaseShared() &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h != tail) &#123;</span><br><span class="line">            int ws = h.waitStatus;</span><br><span class="line">            if (ws == Node.SIGNAL) &#123;</span><br><span class="line">                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</span><br><span class="line">                    continue;            // loop to recheck cases</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (ws == 0 &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</span><br><span class="line">                continue;                // loop on failed CAS</span><br><span class="line">        &#125;</span><br><span class="line">        if (h == head)                   // loop if head changed</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法可能是共享锁模式最难理解的方法了，在看该方法时，我们需要明确以下几个问题：</p><p><strong>(1) 该方法有几处调用？</strong></p><p>该方法有两处调用，一处在acquireShared方法的末尾，当线程成功获取到共享锁后，在一定条件下调用该方法；一处在releaseShared方法中，当线程释放共享锁的时候调用。</p><p><strong>(2) 调用该方法的线程是谁？</strong></p><p>在独占锁中，只有获取了锁的线程才能调用release释放锁，因此调用unparkSuccessor(h)唤醒后继节点的必然是持有锁的线程，该线程可看做是当前的头节点(虽然在setHead方法中已经将头节点的thread属性设为了null，但是这个头节点曾经代表的就是这个线程)</p><p>在共享锁中，持有共享锁的线程可以有多个，这些线程都可以调用releaseShared方法释放锁；而这些线程想要获得共享锁，则它们必然曾经成为过头节点，或者就是现在的头节点。因此，如果是在releaseShared方法中调用的doReleaseShared，可能此时调用方法的线程已经不是头节点所代表的线程了，头节点可能已经被易主好几次了。</p><p><strong>(3) 调用该方法的目的是什么？</strong></p><p>无论是在acquireShared中调用，还是在releaseShared方法中调用，该方法的目的都是在当前共享锁是可获取的状态时，唤醒head节点的下一个节点。这一点看上去和独占锁似乎一样，但是它们的一个重要的差别是——在共享锁中，当头节点发生变化时，是会回到循环中再立即唤醒head节点的下一个节点的。也就是说，在当前节点完成唤醒后继节点的任务之后将要退出时，如果发现被唤醒后继节点已经成为了新的头节点，则会立即触发唤醒head节点的下一个节点的操作，如此周而复始。</p><p><strong>(4) 退出该方法的条件是什么</strong></p><p>该方法是一个自旋操作(for(;;))，退出该方法的唯一办法是走最后的break语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (h == head)   // loop if head changed</span><br><span class="line">    break;</span><br></pre></td></tr></table></figure><p>即，只有在当前head没有易主时，才会退出，否则继续循环。<br>这个怎么理解呢？<br>为了说明问题，这里我们假设目前sync queue队列中依次排列有</p><blockquote><p>dummy node -&gt; A -&gt; B -&gt; C -&gt; D</p></blockquote><p>现在假设A已经拿到了共享锁，则它将成为新的dummy node，</p><blockquote><p>dummy node (A) -&gt; B -&gt; C -&gt; D</p></blockquote><p>此时，A线程会调用doReleaseShared，我们写做doReleaseShared[A]，在该方法中将唤醒后继的节点B，它很快获得了共享锁，成为了新的头节点：</p><blockquote><p>dummy node (B) -&gt; C -&gt; D</p></blockquote><p>此时，B线程也会调用doReleaseShared，我们写做doReleaseShared[B]，在该方法中将唤醒后继的节点C，但是别忘了，在doReleaseShared[B]调用的时候，doReleaseShared[A]还没运行结束呢，当它运行到if(h == head)时，发现头节点现在已经变了，所以它将继续回到for循环中，与此同时，doReleaseShared[B]也没闲着，它在执行过程中也进入到了for循环中。。。</p><p>由此可见，我们这里形成了一个doReleaseShared的“调用风暴”，大量的线程在同时执行doReleaseShared，这极大地加速了唤醒后继节点的速度，提升了效率，同时该方法内部的CAS操作又保证了多个线程同时唤醒一个节点时，只有一个线程能操作成功。</p><p>那如果这里doReleaseShared[A]执行结束时，节点B还没有成为新的头节点时，doReleaseShared[A]方法不就退出了吗？是的，但即使这样也没有关系，因为它已经成功唤醒了线程B，即使doReleaseShared[A]退出了，当B线程成为新的头节点时，doReleaseShared[B]就开始执行了，它也会负责唤醒后继节点的，这样即使变成这种每个节点只唤醒自己后继节点的模式，从功能上讲，最终也可以实现唤醒所有等待共享锁的节点的目的，只是效率上没有之前的“调用风暴”快。</p><p>由此我们知道，这里的“调用风暴”事实上是一个优化操作，因为在我们执行到该方法的末尾的时候，unparkSuccessor基本上已经被调用过了，而由于现在是共享锁模式，所以被唤醒的后继节点极有可能已经获取到了共享锁，成为了新的head节点，当它成为新的head节点后，它可能还是要在setHeadAndPropagate方法中调用doReleaseShared唤醒它的后继节点。</p><p>明确了上面几个问题后，我们再来详细分析这个方法，它最重要的部分就是下面这两个if语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (ws == Node.SIGNAL) &#123;</span><br><span class="line">    if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</span><br><span class="line">        continue;            // loop to recheck cases</span><br><span class="line">    unparkSuccessor(h);</span><br><span class="line">&#125;</span><br><span class="line">else if (ws == 0 &amp;&amp;</span><br><span class="line">         !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</span><br><span class="line">    continue;                // loop on failed CAS</span><br></pre></td></tr></table></figure><p>第一个if很好理解，如果当前ws值为Node.SIGNAL，则说明后继节点需要唤醒，这里采用CAS操作先将Node.SIGNAL状态改为0，这是因为前面讲过，可能有大量的doReleaseShared方法在同时执行，我们只需要其中一个执行unparkSuccessor(h)操作就行了，这里通过CAS操作保证了unparkSuccessor(h)只被执行一次。</p><p>比较难理解的是第二个else if，首先我们要弄清楚ws啥时候为0，一种是上面的compareAndSetWaitStatus(h, Node.SIGNAL, 0)会导致ws为0，但是很明显，如果是因为这个原因，则它是不会进入到else if语句块的。所以这里的ws为0是指当前队列的最后一个节点成为了头节点。为什么是最后一个节点呢，因为每次新的节点加进来，在挂起前一定会将自己的前驱节点的waitStatus修改成Node.SIGNAL的。</p><p>其次，compareAndSetWaitStatus(h, 0, Node.PROPAGATE)这个操作什么时候会失败？既然这个操作失败，说明就在执行这个操作的瞬间，ws此时已经不为0了，说明有新的节点入队了，ws的值被改为了Node.SIGNAL，此时我们将调用continue，在下次循环中直接将这个刚刚新入队但准备挂起的线程唤醒。</p><p>其实，如果我们再结合外部的整体条件，就很容易理解这种情况所针对的场景，不要忘了，进入上面这段还有一个条件是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (h != null &amp;&amp; h != tail)</span><br></pre></td></tr></table></figure><p>它处于最外层：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private void doReleaseShared() &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h != tail) &#123; // 注意这里说明了队列至少有两个节点</span><br><span class="line">            int ws = h.waitStatus;</span><br><span class="line">            if (ws == Node.SIGNAL) &#123;</span><br><span class="line">                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</span><br><span class="line">                    continue;            </span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (ws == 0 &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</span><br><span class="line">                continue;               </span><br><span class="line">        &#125;</span><br><span class="line">        if (h == head)</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个条件意味着，队列中至少有两个节点。</p><p>结合上面的分析，我们可以看出，这个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</span><br></pre></td></tr></table></figure><p>描述了一个极其严苛且短暂的状态：</p><ul><li>首先，大前提是队列里至少有两个节点</li><li>其次，要执行到else if语句，说明我们跳过了前面的if条件，说明头节点是刚刚成为头节点的，它的waitStatus值还为0，尾节点是在这之后刚刚加进来的，它需要执行shouldParkAfterFailedAcquire，将它的前驱节点（即头节点）的waitStatus值修改为Node.SIGNAL，但是目前这个修改操作还没有来的及执行。这种情况使我们得以进入else if的前半部分else if (ws == 0 &amp;&amp;</li><li>紧接着，要满足!compareAndSetWaitStatus(h, 0, Node.PROPAGATE)这一条件，说明此时头节点的waitStatus已经不是0了，这说明之前那个没有来得及执行的 在shouldParkAfterFailedAcquire将前驱节点的的waitStatus值修改为Node.SIGNAL的操作现在执行完了。</li></ul><p>由此可见，else if 的 &amp;&amp; 连接了两个不一致的状态，分别对应了shouldParkAfterFailedAcquire的compareAndSetWaitStatus(pred, ws, Node.SIGNAL)执行成功前和执行成功后，因为doReleaseShared和shouldParkAfterFailedAcquire是可以并发执行的，所以这一条件是有可能满足的，只是满足的条件非常严苛，可能只是一瞬间的事。</p><p>这里不得不说，如果以上的分析没有错的话，那作者对于AQS性能的优化已经到了“令人发指”的地步！！！虽说这种短暂的瞬间确实存在，也确实有必要重新回到for循环中再次去唤醒后继节点，但是这种优化也太太太～～～过于精细了吧！</p><p>我们来看看如果不加入这个精细的控制条件有什么后果呢？</p><p>这里我们复习一下新节点入队的过程，前面说过，在发现新节点的前驱不是head节点的时候，它将调用shouldParkAfterFailedAcquire：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span><br><span class="line">    int ws = pred.waitStatus;</span><br><span class="line">    if (ws == Node.SIGNAL)</span><br><span class="line">        /*</span><br><span class="line">         * This node has already set status asking a release</span><br><span class="line">         * to signal it, so it can safely park.</span><br><span class="line">         */</span><br><span class="line">        return true;</span><br><span class="line">    if (ws &gt; 0) &#123;</span><br><span class="line">        /*</span><br><span class="line">         * Predecessor was cancelled. Skip over predecessors and</span><br><span class="line">         * indicate retry.</span><br><span class="line">         */</span><br><span class="line">        do &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; while (pred.waitStatus &gt; 0);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        /*</span><br><span class="line">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span><br><span class="line">         * need a signal, but don&apos;t park yet.  Caller will need to</span><br><span class="line">         * retry to make sure it cannot acquire before parking.</span><br><span class="line">         */</span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于前驱节点的ws值现在还为0，新节点将会把它改为Node.SIGNAL，</p><p>但修改后，该方法返回的是false，也就是说线程不会立即挂起，而是回到上层再尝试一次抢锁：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private void doAcquireShared(int arg) &#123;</span><br><span class="line">    final Node node = addWaiter(Node.SHARED);</span><br><span class="line">    boolean failed = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted = false;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final Node p = node.predecessor();</span><br><span class="line">            if (p == head) &#123;</span><br><span class="line">                int r = tryAcquireShared(arg);</span><br><span class="line">                if (r &gt;= 0) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = null; // help GC</span><br><span class="line">                    if (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = false;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // shouldParkAfterFailedAcquire的返回处</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们再次回到for(;;)循环中，由于此时当前节点的前驱节点已经成为了新的head，所以它可以参与抢锁，由于它抢的是共享锁，所以大概率它是抢的到的，所以极有可能它不会被挂起。这有可能导致在上面的doReleaseShared调用unparkSuccessor方法unpark了一个并没有被park的线程。然而，这一操作是被允许的，当我们unpark一个并没有被park的线程时，该线程在下一次调用park方法时就不会被挂起，而这一行为是符合我们的场景的——因为当前的共享锁处于可获取的状态，后继的线程应该直接来获取锁，不应该被挂起。</p><p>事实上，我个人认为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</span><br><span class="line">    continue;  // loop on failed CAS</span><br></pre></td></tr></table></figure><p>这一段其实也可以省略，当然有了这一段肯定会加速唤醒后继节点的过程，作者针对上面那种极其短暂的情况进行了优化可以说是和它之前“调用风暴”的设计一脉相承，可能也正是由于作者对于性能的极致追求才使得AQS如此之优秀吧。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>共享锁的调用框架和独占锁很相似，它们最大的不同在于获取锁的逻辑——共享锁可以被多个线程同时持有，而独占锁同一时刻只能被一个线程持有。</li><li>由于共享锁同一时刻可以被多个线程持有，因此当头节点获取到共享锁时，可以立即唤醒后继节点来争锁，而不必等到释放锁的时候。因此，共享锁触发唤醒后继节点的行为可能有两处，一处在当前节点成功获得共享锁后，一处在当前节点释放共享锁后。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;共享锁与独占锁的区别&quot;&gt;&lt;a href=&quot;#共享锁与独占锁的区别&quot; class=&quot;headerlink&quot; title=&quot;共享锁与独占锁的区别&quot;&gt;&lt;/a&gt;共享锁与独占锁的区别&lt;/h2&gt;&lt;p&gt;共享锁与独占锁最大的区别在于，独占锁是&lt;strong&gt;独占的，排他的&lt;/st
      
    
    </summary>
    
      <category term="并发编程" scheme="http://ruanshubin.top/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://ruanshubin.top/tags/Java/"/>
    
      <category term="并发" scheme="http://ruanshubin.top/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Thread类源码解读3--线程中断interrupt</title>
    <link href="http://ruanshubin.top/2019/11/07/Thread%E7%B1%BB%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB3%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%ADinterrupt/"/>
    <id>http://ruanshubin.top/2019/11/07/Thread类源码解读3——线程中断interrupt/</id>
    <published>2019-11-07T13:30:00.000Z</published>
    <updated>2019-12-25T05:49:29.840Z</updated>
    
    <content type="html"><![CDATA[<p>线程中断是一个很重要的概念，通常，取消一个任务的执行，最好的，同时也是最合理的方法，就是通过中断。</p><p>本篇我们主要还是通过源码分析来看看中断的概念。</p><p>本文的源码基于JDK1.8</p><h2 id="Interrupt-status-amp-InterruptedException"><a href="#Interrupt-status-amp-InterruptedException" class="headerlink" title="Interrupt status &amp; InterruptedException"></a>Interrupt status &amp; InterruptedException</h2><p>java线程的中断机制为我们提供了一个契机，使被中断的线程能够有机会从当前的任务中跳脱出来。而中断机制的最核心的两个概念就是interrupt status 和 InterruptedException。</p><p>java中对于中断的大部分操作无外乎以下两点:</p><ul><li>设置或者清除中断标志位</li><li>抛出InterruptedException</li></ul><h3 id="interrupt-status"><a href="#interrupt-status" class="headerlink" title="interrupt status"></a>interrupt status</h3><p>在java中，每一个线程都有一个中断标志位，表征了当前线程是否处于被中断状态，我们可以把这个标识位理解成一个boolean类型的变量，当我们中断一个线程时，将该标识位设为true，当我们清除中断状态时，将其设置为false, 其伪代码如下:</p><p>(注意，本文的伪代码部分是我个人所写，并不权威，只是帮助我自己理解写的)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 注意，这是伪代码！！！</span><br><span class="line">// 注意，这是伪代码！！！</span><br><span class="line">// 注意，这是伪代码！！！</span><br><span class="line">public class Thread implements Runnable &#123;</span><br><span class="line">    private boolean interruptFlag; // 中断标志位</span><br><span class="line">    </span><br><span class="line">    public boolean getInterruptFlag() &#123;</span><br><span class="line">        return this.interruptFlag;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setInterruptFlag(boolean flag) &#123;</span><br><span class="line">        this.interruptFlag = flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，<strong>在Thread线程类里面，并没有类似中断标志位的属性，但是提供了获取中断标志位的接口:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Tests if some Thread has been interrupted.  The interrupted state</span><br><span class="line"> * is reset or not based on the value of ClearInterrupted that is</span><br><span class="line"> * passed.</span><br><span class="line"> */</span><br><span class="line">private native boolean isInterrupted(boolean ClearInterrupted);</span><br></pre></td></tr></table></figure><p>这是一个native方法，同时也是一个private方法，该方法除了能够返回当前线程的中断状态，还能根据ClearInterrupted参数来决定要不要重置中断标志位(reset操作相当于上面的interruptFlag = false)。</p><p>Thread类提供了两个public方法来使用该native方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public boolean isInterrupted() &#123;</span><br><span class="line">    return isInterrupted(false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static boolean interrupted() &#123;</span><br><span class="line">    return currentThread().isInterrupted(true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中isInterrupted调用了isInterrupted(false), ClearInterrupted参数为false, 说明它仅仅返回线程实例的中断状态，但是不会对现有的中断状态做任何改变，伪代码可以是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 注意，这是伪代码！！！</span><br><span class="line">// 注意，这是伪代码！！！</span><br><span class="line">// 注意，这是伪代码！！！</span><br><span class="line">public boolean isInterrupted() &#123;</span><br><span class="line">    return interruptFlag; //直接返回Thread实例的中断状态</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而interrupted是一个<strong>静态方法</strong>，所以它可以由Thread类直接调用，自然就是作用于<strong>当前正在执行的线程</strong>，所以函数内部使用了currentThread()方法，与isInterrupted()方法不同的是，它的ClearInterrupted参数为true，在返回线程中断状态的同时，重置了中断标识位，伪代码可以是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 注意，这是伪代码！！！</span><br><span class="line">// 注意，这是伪代码！！！</span><br><span class="line">// 注意，这是伪代码！！！</span><br><span class="line">public static boolean interrupted() &#123;</span><br><span class="line">    Thread current = Thread.currentThread(); // 获取当前正在执行的线程</span><br><span class="line">    boolean interruptFlag = current.getInterruptFlag(); // 获取线程的中断状态</span><br><span class="line">    current.setInterruptFlag(false); // 清除线程的中断状态</span><br><span class="line">    return interruptFlag; //返回线程的中断状态</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，isInterrupted() 和 interrupted() 方法只涉及到中断状态的查询，最多是多加一步重置中断状态，并不牵涉到InterruptedException。</p><p>不过值得一提的是，在我们能使用到的public方法中，<strong>interrupted()是我们清除中断的唯一方法</strong>。</p><h3 id="InterruptedException"><a href="#InterruptedException" class="headerlink" title="InterruptedException"></a>InterruptedException</h3><p>我们直接来看的源码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Thrown when a thread is waiting, sleeping, or otherwise occupied,</span><br><span class="line"> * and the thread is interrupted, either before or during the activity.</span><br><span class="line"> * Occasionally a method may wish to test whether the current</span><br><span class="line"> * thread has been interrupted, and if so, to immediately throw</span><br><span class="line"> * this exception.  The following code can be used to achieve</span><br><span class="line"> * this effect:</span><br><span class="line"> * &lt;pre&gt;</span><br><span class="line"> *  if (Thread.interrupted())  // Clears interrupted status!</span><br><span class="line"> *      throw new InterruptedException();</span><br><span class="line"> * &lt;/pre&gt;</span><br><span class="line"> *</span><br><span class="line"> * @author  Frank Yellin</span><br><span class="line"> * @see     java.lang.Object#wait()</span><br><span class="line"> * @see     java.lang.Object#wait(long)</span><br><span class="line"> * @see     java.lang.Object#wait(long, int)</span><br><span class="line"> * @see     java.lang.Thread#sleep(long)</span><br><span class="line"> * @see     java.lang.Thread#interrupt()</span><br><span class="line"> * @see     java.lang.Thread#interrupted()</span><br><span class="line"> * @since   JDK1.0</span><br><span class="line"> */</span><br><span class="line">public class InterruptedException extends Exception &#123;</span><br><span class="line">    private static final long serialVersionUID = 6700697376100628473L;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Constructs an &lt;code&gt;InterruptedException&lt;/code&gt; with no detail  message.</span><br><span class="line">     */</span><br><span class="line">    public InterruptedException() &#123;</span><br><span class="line">        super();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Constructs an &lt;code&gt;InterruptedException&lt;/code&gt; with the</span><br><span class="line">     * specified detail message.</span><br><span class="line">     *</span><br><span class="line">     * @param   s   the detail message.</span><br><span class="line">     */</span><br><span class="line">    public InterruptedException(String s) &#123;</span><br><span class="line">        super(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的注释是说，在线程处于“waiting, sleeping”甚至是正在运行的过程中，如果被中断了，就可以抛出该异常，我们先来回顾一下我们前面遇到过的抛出InterruptedException异常的例子:</p><p>(1) wait(long timeout)方法中的InterruptedException</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> *</span><br><span class="line"> * @param      timeout   the maximum time to wait in milliseconds.</span><br><span class="line"> * @throws  IllegalArgumentException      if the value of timeout is</span><br><span class="line"> *               negative.</span><br><span class="line"> * @throws  IllegalMonitorStateException  if the current thread is not</span><br><span class="line"> *               the owner of the object&apos;s monitor.</span><br><span class="line"> * @throws  InterruptedException if any thread interrupted the</span><br><span class="line"> *             current thread before or while the current thread</span><br><span class="line"> *             was waiting for a notification.  The &lt;i&gt;interrupted</span><br><span class="line"> *             status&lt;/i&gt; of the current thread is cleared when</span><br><span class="line"> *             this exception is thrown.</span><br><span class="line"> * @see        java.lang.Object#notify()</span><br><span class="line"> * @see        java.lang.Object#notifyAll()</span><br><span class="line"> */</span><br><span class="line">public final native void wait(long timeout) throws InterruptedException;</span><br></pre></td></tr></table></figure><p>该方法的注释中提到，如果在有别的线程在当前线程进入waiting状态之前或者已经进入waiting状态之后中断了当前线程，该方法就会抛出InterruptedException，同时，异常抛出后，当前线程的中断状态也会被清除。</p><p>(2) sleep(long millis)方法中的InterruptedException</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* @param  millis</span><br><span class="line"> *         the length of time to sleep in milliseconds</span><br><span class="line"> *</span><br><span class="line"> * @throws  IllegalArgumentException</span><br><span class="line"> *          if the value of &#123;@code millis&#125; is negative</span><br><span class="line"> *</span><br><span class="line"> * @throws  InterruptedException</span><br><span class="line"> *          if any thread has interrupted the current thread. The</span><br><span class="line"> *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is</span><br><span class="line"> *          cleared when this exception is thrown.</span><br><span class="line"> */</span><br><span class="line">public static native void sleep(long millis) throws InterruptedException;</span><br></pre></td></tr></table></figure><p>上面的wait方法一致，如果当前线程被中断了，sleep方法会抛出InterruptedException，并且清除中断状态。</p><p>如果有其他方法直接或间接的调用了这两个方法，那他们自然也会在线程被中断的时候抛出InterruptedException，并且清除中断状态。例如:</p><ul><li>wait()</li><li>wait(long timeout, int nanos)</li><li>sleep(long millis, int nanos)</li><li>join()</li><li>join(long millis)</li><li>join(long millis, int nanos)</li></ul><p>这里值得注意的是，虽然这些方法会抛出InterruptedException，但是并不会终止当前线程的执行，当前线程可以选择忽略这个异常。</p><p>也就是说，无论是设置interrupt status 还是抛出InterruptedException，它们都是给当前线程的建议，当前线程可以选择采纳或者不采纳，它们并不会影响当前线程的执行。</p><p>至于在收到这些中断的建议后，当前线程要怎么处理，也完全取决于当前线程。 </p><h2 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h2><p>上面我们说了怎么检查(以及清除)一个线程的中断状态，提到当一个线程被中断后，有一些方法会抛出InterruptedException。</p><p>下面我们就来看看怎么中断一个线程。</p><p>要中断一个线程，只需调用该线程的interrupt方法，其源码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Interrupts this thread.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt; Unless the current thread is interrupting itself, which is</span><br><span class="line"> * always permitted, the &#123;@link #checkAccess() checkAccess&#125; method</span><br><span class="line"> * of this thread is invoked, which may cause a &#123;@link</span><br><span class="line"> * SecurityException&#125; to be thrown.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt; If this thread is blocked in an invocation of the &#123;@link</span><br><span class="line"> * Object#wait() wait()&#125;, &#123;@link Object#wait(long) wait(long)&#125;, or &#123;@link</span><br><span class="line"> * Object#wait(long, int) wait(long, int)&#125; methods of the &#123;@link Object&#125;</span><br><span class="line"> * class, or of the &#123;@link #join()&#125;, &#123;@link #join(long)&#125;, &#123;@link</span><br><span class="line"> * #join(long, int)&#125;, &#123;@link #sleep(long)&#125;, or &#123;@link #sleep(long, int)&#125;,</span><br><span class="line"> * methods of this class, then its interrupt status will be cleared and it</span><br><span class="line"> * will receive an &#123;@link InterruptedException&#125;.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt; If this thread is blocked in an I/O operation upon an &#123;@link</span><br><span class="line"> * java.nio.channels.InterruptibleChannel InterruptibleChannel&#125;</span><br><span class="line"> * then the channel will be closed, the thread&apos;s interrupt</span><br><span class="line"> * status will be set, and the thread will receive a &#123;@link</span><br><span class="line"> * java.nio.channels.ClosedByInterruptException&#125;.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt; If this thread is blocked in a &#123;@link java.nio.channels.Selector&#125;</span><br><span class="line"> * then the thread&apos;s interrupt status will be set and it will return</span><br><span class="line"> * immediately from the selection operation, possibly with a non-zero</span><br><span class="line"> * value, just as if the selector&apos;s &#123;@link</span><br><span class="line"> * java.nio.channels.Selector#wakeup wakeup&#125; method were invoked.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt; If none of the previous conditions hold then this thread&apos;s interrupt</span><br><span class="line"> * status will be set. &lt;/p&gt;</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt; Interrupting a thread that is not alive need not have any effect.</span><br><span class="line"> *</span><br><span class="line"> * @throws  SecurityException</span><br><span class="line"> *          if the current thread cannot modify this thread</span><br><span class="line"> *</span><br><span class="line"> * @revised 6.0</span><br><span class="line"> * @spec JSR-51</span><br><span class="line"> */</span><br><span class="line">public void interrupt() &#123;</span><br><span class="line">    if (this != Thread.currentThread())</span><br><span class="line">        checkAccess();</span><br><span class="line"></span><br><span class="line">    synchronized (blockerLock) &#123;</span><br><span class="line">        Interruptible b = blocker;</span><br><span class="line">        if (b != null) &#123;</span><br><span class="line">            interrupt0();           // Just to set the interrupt flag</span><br><span class="line">            b.interrupt(this);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interrupt0();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的注释很长，我们一段一段来看:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Interrupts this thread.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt; Unless the current thread is interrupting itself, which is</span><br><span class="line"> * always permitted, the &#123;@link #checkAccess() checkAccess&#125; method</span><br><span class="line"> * of this thread is invoked, which may cause a &#123;@link</span><br><span class="line"> * SecurityException&#125; to be thrown.</span><br><span class="line"> ...</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>上面这段首先说明了这个函数的目的是中断这个线程，这个this thread，当然指的就是该方法所属的线程对象所代表的线程。</p><p>接着说明了，一个线程总是被允许中断自己，但是我们如果想要在一个线程中中断另一个线程的执行，就需要先通过checkAccess()检查权限。这有可能抛出SecurityException异常, 这段话用代码体现为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (this != Thread.currentThread())</span><br><span class="line">    checkAccess();</span><br></pre></td></tr></table></figure><p>我们接着往下看:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> ...</span><br><span class="line"> * &lt;p&gt; If this thread is blocked in an invocation of the &#123;@link</span><br><span class="line"> * Object#wait() wait()&#125;, &#123;@link Object#wait(long) wait(long)&#125;, or &#123;@link</span><br><span class="line"> * Object#wait(long, int) wait(long, int)&#125; methods of the &#123;@link Object&#125;</span><br><span class="line"> * class, or of the &#123;@link #join()&#125;, &#123;@link #join(long)&#125;, &#123;@link</span><br><span class="line"> * #join(long, int)&#125;, &#123;@link #sleep(long)&#125;, or &#123;@link #sleep(long, int)&#125;,</span><br><span class="line"> * methods of this class, then its interrupt status will be cleared and it</span><br><span class="line"> * will receive an &#123;@link InterruptedException&#125;.</span><br><span class="line"> ...</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>上面这段是说，如果线程因为以下方法的调用而处于阻塞中，那么(调用了interrupt方法之后)，线程的中断标志会被清除，并且收到一个InterruptedException:</p><ul><li>Object的方法<ul><li>wait()</li><li>wait(long)</li><li>wait(long, int)</li></ul></li><li>Thread的方法<ul><li>join()</li><li>join(long)</li><li>join(long, int)</li><li>sleep(long)</li><li>sleep(long, int)</li></ul></li></ul><p>关于这一点，我们上面在分析InterruptedException的时候已经分析过了。</p><p>这里插一句，由于上面这些方法在抛出InterruptedException异常后，会<strong>同时清除中断标识位</strong>，因此当我们此时不想或者无法传递InterruptedException异常，也不对该异常做任何处理时，我们最好通过再次调用interrupt来恢复中断的状态，以供上层调用者处理。</p><p>接下来的两段注释是关于NIO的，我们暂时不看，直接看最后两段:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> ...</span><br><span class="line"> * &lt;p&gt; If none of the previous conditions hold then this thread&apos;s interrupt</span><br><span class="line"> * status will be set. &lt;/p&gt;</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt; Interrupting a thread that is not alive need not have any effect.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>这段话是说:</p><ul><li>如果线程没有因为上面的函数调用而进入阻塞状态的话，那么中断这个线程仅仅会设置它的中断标志位(而不会抛出InterruptedException)</li><li>中断一个已经终止的线程不会有任何影响。</li></ul><p>注释看完了之后我们再来看代码部分，其实代码部分很简单，中间那段同步代码块是和NIO有关的，我们可以暂时不管，整个方法的核心调用就是interrupt0()方法，而它是一个native方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private native void interrupt0();</span><br></pre></td></tr></table></figure><p>这个方法所做的事情很简单:</p><blockquote><p>Just to set the interrupt flag</p></blockquote><p>所以，至此我们明白了，<strong>所谓“中断一个线程”，其实并不是让一个线程停止运行，仅仅是将线程的中断标志设为true, 或者在某些特定情况下抛出一个InterruptedException，它并不会直接将一个线程停掉，在被中断的线程的角度看来，仅仅是自己的中断标志位被设为true了，或者自己所执行的代码中抛出了一个InterruptedException异常，仅此而已。</strong></p><h2 id="终止一个线程"><a href="#终止一个线程" class="headerlink" title="终止一个线程"></a>终止一个线程</h2><p>既然上面我们提到了，中断一个线程并不会使得该线程停止执行，那么我们该怎样终止一个线程的执行呢。早期的java中提供了stop()方法来停止一个线程，但是这个方法是不安全的，所以已经被废弃了。现在终止一个线程，基本上只能靠“曲线救国”式的中断来实现。</p><h3 id="终止处于阻塞状态的线程"><a href="#终止处于阻塞状态的线程" class="headerlink" title="终止处于阻塞状态的线程"></a>终止处于阻塞状态的线程</h3><p>前面我们说过，当一个线程因为调用wait,sleep,join方法而进入阻塞状态后，若在这时中断这个线程，则这些方法将会抛出InterruptedException异常，我们可以利用这个异常，使线程跳出阻塞状态，从而终止线程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    while(true) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // do some task</span><br><span class="line">            // blocked by calling wait/sleep/join</span><br><span class="line">        &#125; catch (InterruptedException ie) &#123;  </span><br><span class="line">            // 如果该线程被中断，则会抛出InterruptedException异常</span><br><span class="line">            // 我们通过捕获这个异常，使得线程从block状态退出</span><br><span class="line">            break; // 这里使用break, 可以使我们在线程中断后退出死循环，从而终止线程。</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="终止处于运行状态的线程"><a href="#终止处于运行状态的线程" class="headerlink" title="终止处于运行状态的线程"></a>终止处于运行状态的线程</h3><p>与中断一个处于阻塞状态所不同的是，中断一个处于运行状态的线程只会将该线程的中断标志位设为true, 而并不会抛出InterruptedException异常，为了能在运行过程中感知到线程已经被中断了，我们只能通过不断地检查中断标志位来实现:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    while (!isInterrupted()) &#123;</span><br><span class="line">        // do some task...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，我们每次循环都会先检查中断标志位，只要当前线程被中断了，isInterrupted()方法就会返回true，从而终止循环。</p><h3 id="终止一个Alive的线程"><a href="#终止一个Alive的线程" class="headerlink" title="终止一个Alive的线程"></a>终止一个Alive的线程</h3><p>上面我们分别介绍了怎样终止一个处于阻塞状态或运行状态的线程，如果我们将这两种方法结合起来，那么就可以同时应对这两种状况，从而能够终止任意一个存活的线程:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 1. isInterrupted() 用于终止一个正在运行的线程。</span><br><span class="line">        while (!isInterrupted()) &#123;</span><br><span class="line">            // 执行任务...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (InterruptedException ie) &#123;  </span><br><span class="line">        // 2. InterruptedException异常用于终止一个处于阻塞状态的线程</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过使用这两者的组合一定要注意，wait,sleep,join等方法抛出InterruptedException有一个副作用: 清除当前的中断标志位，所以不要在异常抛出后不做任何处理，而寄望于用isInterrupted()方法来判断，因为中标志位已经被重置了，所以下面这种写法是不对的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    //isInterrupted() 用于终止一个正在运行的线程。</span><br><span class="line">    while (!isInterrupted()) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">                // 执行任务...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (InterruptedException ie) &#123;  </span><br><span class="line">            // 在这里不做任何处理，仅仅依靠isInterrupted检测异常</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法中，在catch块中我们检测到异常后没有使用break方法跳出循环，而此时中断状态已经被重置，当我们再去调用isInterrupted，依旧会返回false, 故线程仍然会在while循环中执行，无法被中断。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Java没有提供一种安全直接的方法来停止某个线程，但是提供了中断机制。对于被中断的线程，中断只是一个建议，至于收到这个建议后线程要采取什么措施，完全由线程自己决定。</p><p>中断机制的核心在于中断状态和InterruptedException异常</p><p>中断状态:</p><ul><li>设置一个中断状态: Thread#interrupt</li><li>清除一个中断状态: Thread.interrupted</li></ul><p>Thread.interrupted方法同时会返回线程原来的中断的状态。<br>如果仅仅想查看线程当前的中断状态而不清除原来的状态，则应该使用Thread#isInterrupted。</p><p>某些阻塞方法在抛出InterruptedException异常后，会同时清除中断状态。若不能对该异常做出处理也无法向上层抛出，则应该通过再次调用interrupt方法恢复中断状态，以供上层处理，通常情况下我们都不应该屏蔽中断请求。</p><p>中断异常:</p><p>中断异常一般是线程被中断后，在一些block类型的方法(如wait,sleep,join)中抛出。</p><p>我们可以使用Thread#interrupt中断一个线程，被中断的线程所受的影响为以下两种之一:</p><ul><li>若被中断前，该线程处于非阻塞状态，那么该线程的中断状态被设为true, 除此之外，不会发生任何事。</li><li>若被中断前，该线程处于阻塞状态(调用了wait,sleep,join等方法)，那么该线程将会立即从阻塞状态中退出，并抛出一个InterruptedException异常，同时，该线程的中断状态被设为false, 除此之外，不会发生任何事。</li></ul><p>无论是中断状态的改变还是InterruptedException被抛出，这些都是当前线程可以感知到的”建议”，如果当前线程选择忽略这些建议(例如简单地catch住异常继续执行)，那么中断机制对于当前线程就没有任何影响，就好像什么也没有发生一样。</p><p>所以，中断一个线程，只是传递了请求中断的消息，并不会直接阻止一个线程的运行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;线程中断是一个很重要的概念，通常，取消一个任务的执行，最好的，同时也是最合理的方法，就是通过中断。&lt;/p&gt;
&lt;p&gt;本篇我们主要还是通过源码分析来看看中断的概念。&lt;/p&gt;
&lt;p&gt;本文的源码基于JDK1.8&lt;/p&gt;
&lt;h2 id=&quot;Interrupt-status-amp-In
      
    
    </summary>
    
      <category term="并发编程" scheme="http://ruanshubin.top/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://ruanshubin.top/tags/Java/"/>
    
      <category term="并发" scheme="http://ruanshubin.top/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Thread类源码解读2--线程状态及常用方法</title>
    <link href="http://ruanshubin.top/2019/11/06/Thread%E7%B1%BB%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB2%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://ruanshubin.top/2019/11/06/Thread类源码解读2——线程状态及常用方法/</id>
    <published>2019-11-06T13:30:00.000Z</published>
    <updated>2019-12-25T05:48:25.570Z</updated>
    
    <content type="html"><![CDATA[<p>本篇依然是通过源码分析来了解这些知识。</p><p>本文源码基于jdk1.8 。</p><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p>在Thread类中, 线程状态是通过threadStatus属性以及State枚举类实现的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">/* Java thread status for tools,</span><br><span class="line"> * initialized to indicate thread &apos;not yet started&apos;</span><br><span class="line"> */</span><br><span class="line">private volatile int threadStatus = 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public enum State &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Thread state for a thread which has not yet started.</span><br><span class="line">     */</span><br><span class="line">    NEW,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Thread state for a runnable thread.  A thread in the runnable</span><br><span class="line">     * state is executing in the Java virtual machine but it may</span><br><span class="line">     * be waiting for other resources from the operating system</span><br><span class="line">     * such as processor.</span><br><span class="line">     */</span><br><span class="line">    RUNNABLE,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Thread state for a thread blocked waiting for a monitor lock.</span><br><span class="line">     * A thread in the blocked state is waiting for a monitor lock</span><br><span class="line">     * to enter a synchronized block/method or</span><br><span class="line">     * reenter a synchronized block/method after calling</span><br><span class="line">     * &#123;@link Object#wait() Object.wait&#125;.</span><br><span class="line">     */</span><br><span class="line">    BLOCKED,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Thread state for a waiting thread.</span><br><span class="line">     * A thread is in the waiting state due to calling one of the</span><br><span class="line">     * following methods:</span><br><span class="line">     * &lt;ul&gt;</span><br><span class="line">     *   &lt;li&gt;&#123;@link Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span><br><span class="line">     *   &lt;li&gt;&#123;@link #join() Thread.join&#125; with no timeout&lt;/li&gt;</span><br><span class="line">     *   &lt;li&gt;&#123;@link LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span><br><span class="line">     * &lt;/ul&gt;</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span><br><span class="line">     * perform a particular action.</span><br><span class="line">     *</span><br><span class="line">     * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span><br><span class="line">     * on an object is waiting for another thread to call</span><br><span class="line">     * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span><br><span class="line">     * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span><br><span class="line">     * is waiting for a specified thread to terminate.</span><br><span class="line">     */</span><br><span class="line">    WAITING,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Thread state for a waiting thread with a specified waiting time.</span><br><span class="line">     * A thread is in the timed waiting state due to calling one of</span><br><span class="line">     * the following methods with a specified positive waiting time:</span><br><span class="line">     * &lt;ul&gt;</span><br><span class="line">     *   &lt;li&gt;&#123;@link #sleep Thread.sleep&#125;&lt;/li&gt;</span><br><span class="line">     *   &lt;li&gt;&#123;@link Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span><br><span class="line">     *   &lt;li&gt;&#123;@link #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span><br><span class="line">     *   &lt;li&gt;&#123;@link LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span><br><span class="line">     *   &lt;li&gt;&#123;@link LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span><br><span class="line">     * &lt;/ul&gt;</span><br><span class="line">     */</span><br><span class="line">    TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Thread state for a terminated thread.</span><br><span class="line">     * The thread has completed execution.</span><br><span class="line">     */</span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Returns the state of this thread.</span><br><span class="line"> * This method is designed for use in monitoring of the system state,</span><br><span class="line"> * not for synchronization control.</span><br><span class="line"> *</span><br><span class="line"> * @return this thread&apos;s state.</span><br><span class="line"> * @since 1.5</span><br><span class="line"> */</span><br><span class="line">public State getState() &#123;</span><br><span class="line">    // get current thread state</span><br><span class="line">    return sun.misc.VM.toThreadState(threadStatus);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中可以看出, 线程一共有6种状态, 其状态转换关系如下图所示: </p><p><img src="/2019/11/06/Thread类源码解读2——线程状态及常用方法/1.jpg" alt=""></p><p>值得一提的是，从状态的定义中可以看出，RUNNABLE状态包含了我们通常所说的running和ready两种状态。</p><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h3 id="currentThread"><a href="#currentThread" class="headerlink" title="currentThread"></a>currentThread</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Returns a reference to the currently executing thread object.</span><br><span class="line"> *</span><br><span class="line"> * @return  the currently executing thread.</span><br><span class="line"> */</span><br><span class="line">public static native Thread currentThread();</span><br></pre></td></tr></table></figure><p>可见，它是一个静态方法，并且是一个native方法，返回的是<strong>当前正在执行的线程</strong>。</p><p>爱思考的同学可能就要问了，现在咱都多核CPU了，同一时刻可以有多个线程跑在不同的CPU核心上，那当前正在执行的线程有多个，到底返回的是哪一个呢？</p><p>其实，这里”当前正在执行的线程”指的是<strong>当前正在执行这段代码的线程</strong>。</p><p>我们知道，线程是CPU调度的最小单位，任意一段代码总得由一个线程执行，所以该方法返回的是正在执行Thread.currentThread这行代码的线程，例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main</span><br></pre></td></tr></table></figure><p>我们知道当一个Java程序启动以后，有一个线程就会立马跑起来，这就是通常所说的Main线程，main线程将会执行java的入口方法main方法，所以当前正在执行Thread.currentThread()方法的线程就是main线程。</p><h3 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h3><p>谈起sleep方法, 被问的最多的两个问题就是:</p><ul><li>Thread.sleep() 与 Thread.currentThread().sleep() 有什么区别？</li><li>Thread.sleep() 和 Object.wait()有什么区别?</li></ul><p>这些问题的答案, 你在源码里都能找得到。我们直接来看源码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Causes the currently executing thread to sleep (temporarily cease</span><br><span class="line"> * execution) for the specified number of milliseconds, subject to</span><br><span class="line"> * the precision and accuracy of system timers and schedulers. The thread</span><br><span class="line"> * does not lose ownership of any monitors.</span><br><span class="line"> *</span><br><span class="line"> * @param  millis</span><br><span class="line"> *         the length of time to sleep in milliseconds</span><br><span class="line"> *</span><br><span class="line"> * @throws  IllegalArgumentException</span><br><span class="line"> *          if the value of &#123;@code millis&#125; is negative</span><br><span class="line"> *</span><br><span class="line"> * @throws  InterruptedException</span><br><span class="line"> *          if any thread has interrupted the current thread. The</span><br><span class="line"> *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is</span><br><span class="line"> *          cleared when this exception is thrown.</span><br><span class="line"> */</span><br><span class="line">public static native void sleep(long millis) throws InterruptedException;</span><br></pre></td></tr></table></figure><p>可见, sleep方法也是一个静态方法, 并且是native方法, 从注释Causes the currently executing thread to sleep中可以看出, 它<strong>作用于当前正在执行的线程</strong>, 所以上面那个问题我们就能回答了:</p><blockquote><p>Thread.sleep() 与 Thread.currentThread().sleep() 没有区别</p></blockquote><p>如果硬要说他们有什么区别的话, 那就是一个是用类直接调用静态方法, 一个是用类的实例调用静态方法.</p><p>另外, 上面的注释中还有一句非常重要的话:</p><blockquote><p>The thread does not lose ownership of any monitors.</p></blockquote><p>也就是说, <strong>虽然sleep函数使当前线程让出了CPU, 但是, 当前线程仍然持有它所获得的监视器锁, 这与同时让出CPU资源和监视器锁资源的wait方法是不一样的</strong>。</p><p>sleep方法还有另外一个版本:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Causes the currently executing thread to sleep (temporarily cease</span><br><span class="line"> * execution) for the specified number of milliseconds plus the specified</span><br><span class="line"> * number of nanoseconds, subject to the precision and accuracy of system</span><br><span class="line"> * timers and schedulers. The thread does not lose ownership of any</span><br><span class="line"> * monitors.</span><br><span class="line"> *</span><br><span class="line"> * @param  millis</span><br><span class="line"> *         the length of time to sleep in milliseconds</span><br><span class="line"> *</span><br><span class="line"> * @param  nanos</span><br><span class="line"> *         &#123;@code 0-999999&#125; additional nanoseconds to sleep</span><br><span class="line"> *</span><br><span class="line"> * @throws  IllegalArgumentException</span><br><span class="line"> *          if the value of &#123;@code millis&#125; is negative, or the value of</span><br><span class="line"> *          &#123;@code nanos&#125; is not in the range &#123;@code 0-999999&#125;</span><br><span class="line"> *</span><br><span class="line"> * @throws  InterruptedException</span><br><span class="line"> *          if any thread has interrupted the current thread. The</span><br><span class="line"> *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is</span><br><span class="line"> *          cleared when this exception is thrown.</span><br><span class="line"> */</span><br><span class="line">public static void sleep(long millis, int nanos) throws InterruptedException &#123;</span><br><span class="line">    if (millis &lt; 0) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;timeout value is negative&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (nanos &lt; 0 || nanos &gt; 999999) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;nanosecond timeout value out of range&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (nanos &gt;= 500000 || (nanos != 0 &amp;&amp; millis == 0)) &#123;</span><br><span class="line">        millis++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(millis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法多加了纳秒级别的延时参数, 但是我们看源码就知道, 这个多加的纳秒级别的延时并没有什么用, 最终该函数还是调用了上面的单参数native sleep方法, 延时还是毫秒级别的, 多出来的参数最多是让当前毫秒级别的延时增加1毫秒.<br>还记得我们上次讲的wait方法吗？我们来对比下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public final void wait(long timeout, int nanos) throws InterruptedException &#123;</span><br><span class="line">    if (timeout &lt; 0) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;timeout value is negative&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (nanos &lt; 0 || nanos &gt; 999999) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;nanosecond timeout value out of range&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (nanos &gt; 0) &#123;</span><br><span class="line">        timeout++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wait(timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>怎么样？是不是很像？两者只不过在从纳秒向毫秒的进位处有细微的差别，我猜这个不统一是历史原因导致的。</p><p>另外，值得一提的是，wait有无参的wait()方法，它调用的是wait(0),表示无限期等待，而sleep并没有无参数的版本，那么sleep(0)代表什么呢？</p><p>这一点在源码里面并没有提及，但是通过猜测sleep方法的定义我们知道，它是让出CPU 0毫秒，这听上去好像没有什么意义，但其实调用Thread.sleep(0)的当前线程确实被“冻结”了一下，让其他线程有机会优先执行。也就是说当前线程会释放一些未用完的时间片给其他线程或进程使用，就相当于一个让位动作，这看上去就和下面要说的yield方法很像了。</p><h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h3><p>既然上面谈到了sleep(0)方法, 就不得不提yield方法了:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * A hint to the scheduler that the current thread is willing to yield</span><br><span class="line"> * its current use of a processor. The scheduler is free to ignore this</span><br><span class="line"> * hint.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt; Yield is a heuristic attempt to improve relative progression</span><br><span class="line"> * between threads that would otherwise over-utilise a CPU. Its use</span><br><span class="line"> * should be combined with detailed profiling and benchmarking to</span><br><span class="line"> * ensure that it actually has the desired effect.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt; It is rarely appropriate to use this method. It may be useful</span><br><span class="line"> * for debugging or testing purposes, where it may help to reproduce</span><br><span class="line"> * bugs due to race conditions. It may also be useful when designing</span><br><span class="line"> * concurrency control constructs such as the ones in the</span><br><span class="line"> * &#123;@link java.util.concurrent.locks&#125; package.</span><br><span class="line"> */</span><br><span class="line">public static native void yield();</span><br></pre></td></tr></table></figure><p>yield方法也是一个native方法, 从它的注释可以看出A hint to the scheduler that the current thread is willing to yield its current use of a processor. The scheduler is free to ignore this hint. 它对于CPU只是一个建议, 告诉CPU, 当前线程愿意让出CPU给其他线程使用, 至于CPU采不采纳, 取决于不同厂商的行为, 有可能一个线程刚yield出CPU, 然后又立马获得了CPU。与之相对, sleep方法一定会让出CPU资源, 并且休眠指定的时间, 不参与CPU的竞争.</p><p>所以调用yield方法不会使线程退出RUNNANLE状态，顶多会使线程从running 变成 ready，<br>但是sleep方法是有可能将线程状态转换成TIMED_WAITING的。</p><h3 id="isAlive"><a href="#isAlive" class="headerlink" title="isAlive"></a>isAlive</h3><p>isAlive方法用于检查线程是否还活着，它是一个native方法，但不是静态方法，也就是说它必须被线程的实例所调用。</p><p>其实大家可以思考一下它为什么不是静态方法，因为静态方法一般都是作用于当前正在执行的线程，既然是“当前正在执行”，那必然是Alive的，所以作为静态方法调用并没有意义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Tests if this thread is alive. A thread is alive if it has</span><br><span class="line"> * been started and has not yet died.</span><br><span class="line"> *</span><br><span class="line"> * @return  &lt;code&gt;true&lt;/code&gt; if this thread is alive;</span><br><span class="line"> *          &lt;code&gt;false&lt;/code&gt; otherwise.</span><br><span class="line"> */</span><br><span class="line">public final native boolean isAlive();</span><br></pre></td></tr></table></figure><h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p>join方法是另一个能将线程状态转换成WAITING或者TIMED_WAITING的，它和wait方法一样，有三个版本，我们一个个来看:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Waits at most &#123;@code millis&#125; milliseconds for this thread to</span><br><span class="line"> * die. A timeout of &#123;@code 0&#125; means to wait forever.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt; This implementation uses a loop of &#123;@code this.wait&#125; calls</span><br><span class="line"> * conditioned on &#123;@code this.isAlive&#125;. As a thread terminates the</span><br><span class="line"> * &#123;@code this.notifyAll&#125; method is invoked. It is recommended that</span><br><span class="line"> * applications not use &#123;@code wait&#125;, &#123;@code notify&#125;, or</span><br><span class="line"> * &#123;@code notifyAll&#125; on &#123;@code Thread&#125; instances.</span><br><span class="line"> *</span><br><span class="line"> * @param  millis</span><br><span class="line"> *         the time to wait in milliseconds</span><br><span class="line"> *</span><br><span class="line"> * @throws  IllegalArgumentException</span><br><span class="line"> *          if the value of &#123;@code millis&#125; is negative</span><br><span class="line"> *</span><br><span class="line"> * @throws  InterruptedException</span><br><span class="line"> *          if any thread has interrupted the current thread. The</span><br><span class="line"> *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is</span><br><span class="line"> *          cleared when this exception is thrown.</span><br><span class="line"> */</span><br><span class="line">public final synchronized void join(long millis) throws InterruptedException &#123;</span><br><span class="line">    long base = System.currentTimeMillis();</span><br><span class="line">    long now = 0;</span><br><span class="line"></span><br><span class="line">    if (millis &lt; 0) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;timeout value is negative&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (millis == 0) &#123;</span><br><span class="line">        while (isAlive()) &#123;</span><br><span class="line">            wait(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        while (isAlive()) &#123;</span><br><span class="line">            long delay = millis - now;</span><br><span class="line">            if (delay &lt;= 0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段源码注释的开头部分就告诉了我们join方法的作用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Waits at most &#123;@code millis&#125; milliseconds for this thread to die. A timeout of &#123;@code 0&#125; means to wait forever.</span><br></pre></td></tr></table></figure><p>也就是说，该方法等待this thread终止，最多等指定的时间，如果指定时间为0，则一直等。</p><p>这里有两个问题需要弄清楚:</p><ul><li>谁在等this thread终止？</li><li>this thread指的是哪个线程？</li></ul><p>为了便于说明，我们直接来看一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class JoinMethodTest &#123;</span><br><span class="line"></span><br><span class="line">    private static void printWithThread(String content) &#123;</span><br><span class="line">        System.out.println(&quot;[&quot; + Thread.currentThread().getName() + &quot;线程]: &quot; + content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        printWithThread(&quot;开始执行main方法&quot;);</span><br><span class="line"></span><br><span class="line">        Thread myThread = new Thread(() -&gt; &#123;</span><br><span class="line">            printWithThread(&quot;我在自定义的线程的run方法里&quot;);</span><br><span class="line">            printWithThread(&quot;我马上要休息1秒钟, 并让出CPU给别的线程使用.&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">                printWithThread(&quot;已经休息了1秒, 又重新获得了CPU&quot;);</span><br><span class="line">                printWithThread(&quot;我休息好了, 马上就退出了&quot;);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">        try &#123;</span><br><span class="line">            myThread.start();</span><br><span class="line">            printWithThread(&quot;我在main方法里面, 我要等下面这个线程执行完了才能继续往下执行.&quot;);</span><br><span class="line">            myThread.join();</span><br><span class="line">            printWithThread(&quot;我在main方法里面, 马上就要退出了.&quot;);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，我们在main方法中调用了 myThread.join()，注意上面这段代码有两个线程，一个是执行main方法的线程，一个是我们自定义的myThread线程，所以上面的两个问题的答案是:</p><ul><li>main线程在等this thread的终止，因为我们在main方法中调用了myThread.join()</li><li>this thread线程指的是myThread线程，因为我们在myThread对象上调用了join方法。</li></ul><p>上面这段代码的执行结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[main线程]: 开始执行main方法</span><br><span class="line">[main线程]: 我在main方法里面, 我要等下面这个线程执行完了才能继续往下执行.</span><br><span class="line">[Thread-0线程]: 我在自定义的线程的run方法里</span><br><span class="line">[Thread-0线程]: 我马上要休息1秒钟, 并让出CPU给别的线程使用.</span><br><span class="line">[Thread-0线程]: 已经休息了1秒, 又重新获得了CPU</span><br><span class="line">[Thread-0线程]: 我休息好了, 马上就退出了</span><br><span class="line">[main线程]: 我在main方法里面, 马上就要退出了.</span><br></pre></td></tr></table></figure><p>从运行结果可以看出，虽然myThread线程(即Thread-0线程)中途让出了CPU, main线程还是必须等到其执行完毕了才能继续往下执行，我们现在修改一下代码，让main线程最多等0.5秒,即将myThread.join()改为myThread.join(500);，则结果如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[main线程]: 开始执行main方法</span><br><span class="line">[main线程]: 我在main方法里面, 我要等下面这个线程执行完了才能继续往下执行.</span><br><span class="line">[Thread-0线程]: 我在自定义的线程的run方法里</span><br><span class="line">[Thread-0线程]: 我马上要休息1秒钟, 并让出CPU给别的线程使用.</span><br><span class="line">[main线程]: 我在main方法里面, 马上就要退出了.</span><br><span class="line">[Thread-0线程]: 已经休息了1秒, 又重新获得了CPU</span><br><span class="line">[Thread-0线程]: 我休息好了, 马上就退出了</span><br></pre></td></tr></table></figure><p>我们看到，由于main线程最多等待myThread 0.5秒，在myThread休眠的一秒内，它就不等了，继续往下执行，而随后myThread抢占到CPU资源继续运行。</p><p>通过列子有了感性的认识后，我们再来看源码，首先看join(0)部分:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public final synchronized void join(long millis) throws InterruptedException &#123;</span><br><span class="line">    ...</span><br><span class="line">    if (millis == 0) &#123;</span><br><span class="line">        while (isAlive()) &#123;</span><br><span class="line">            wait(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个自旋操作，注意，这里的isAlive和wait(0)方法都是线程实例的方法，在上面的例子中就是myThread的方法，Thread虽然是一个线程类，但只是特殊在它的native方法上，除此之外，它就是个普通的java类，而java中所有的类都继承自Object类，所以Thread类继承了Object的wait方法，myThread作为线程类的实例，自然也有wait方法。</p><p>我们之前说wait方法的时候提到过，执行wait方法必须拿到监视器锁，并且必须在同步代码块中调用，这里我们检查join方法发现，它确实被synchronized关键字修饰，并且是一个非静态方法，所以它使用的是当前对象实例的监视器锁(this)。</p><p>好像开始复杂了，我们从头到尾捋一捋(注意了！敲黑板了！这段比较绕! ):</p><ul><li>首先我们要明确，这里牵涉到两个线程，一个是main线程，一个是我们自定义的myThread线程(即例子里的Thread-0)。</li><li>我们在main方法中调用了myThread.join()，main方法由main线程执行，所以执行myThread.join()这行代码的“当前线程”是main线程。</li><li>join方法是一个同步方法，使用的是对象锁(this锁)，即myThread对象所关联的监视器对象。</li><li>main线程必须首先拿到join方法的监视器锁才能进入同步代码块。</li><li>main线程进入同步代码块后会首先检查myThread线程是否还存活，注意，这里的isAlive是myThread线程的方法，它是检查myThread线程是否还活着，而不是当前线程（当前线程是执行isAlive方法的线程，即main线程）。</li><li>如果myThread线程还存活，(main线程)就无限期等待，并让出监视器锁，进入WAITING状态。</li><li>当main线程从WAITING状态被唤醒后（通过notify，notifyAll或者是假唤醒), 将继续竞争监视器锁，当成功获得监视器锁后，他将从调用wait的地方恢复，继续运行。由于wait方法在while循环中，则它将继续检查myThread线程是否存活，如果还是没有终止，则继续挂起等待。</li><li>可以看出，退出这个“自旋”状态的唯一途径就是myThread线程终止运行（或者有中断异常抛出）。</li></ul><p>有的细心的同学可能就要问了: 要是没有人调用notify或者notifyAll,也没有假唤醒状态的发生，那main线程不就一直被wait(0)方法挂起了吗？这样以来不就连检测myThread线程是否存活的机会都没有吗？这样即使myThread终止了，也无法退出啊。</p><p>关于这一点，注释中其实是做了解释的:</p><blockquote><p>As a thread terminates the {@code this.notifyAll} method is invoked.</p></blockquote><p>我们知道，wait(0)方法的监视器锁就是myThread对象(this), 而<strong>当myThread终止执行时，this.notifyAll会被调用</strong>，所以所有等待this锁的线程都会被唤醒，而main线程就是等待在这个监视器锁上的线程，因此myThread运行结束时，main线程会从wait方法处被唤醒。</p><p>另外，注释中还多加了一句:</p><blockquote><p>It is recommended that applications not use {@code wait}, {@code notify}, or {@code notifyAll} on {@code Thread} instances.</p></blockquote><p>这个推荐还是很有必要的，至于为什么，就给大家留作思考题吧&lt;(￣︶￣)&gt;</p><p>不过我这里再啰嗦一句，<strong>一定要分清执行代码的线程和方法所属的线程类所代表的线程！</strong></p><p>例如，在上面的例子中：</p><ul><li>myThread.join() 是myThread对象的方法，但是执行这个方法的是main线程；</li><li>isAlive() 是myThread对象的方法，但是执行这个方法的是main线程，而这个方法检测是myThread线程是否活着</li><li>wait(0) 是myThread对象的方法，但是执行这个方法的是main线程，它使得main线程挂起，但是main线程是在myThread对象代表的monitor上挂起。</li></ul><p>这里<strong>最重要的是区分“myThread对象”和“myThread线程”</strong>，myThread对象有时候代表了myThread线程，例如myThread对象的isAlive方法，检测的就是它代表的myThread线程是否活着，但是其实大多数时候，myThread对象就是普通的java对象，这个对象的方法通常也都是由其他线程(例如上面例子中的main线程)来执行的，对于我们自定义的线程来说(例如上面的myThread线程)，通常由它自己执行的方法就只有传进入的run方法了。</p><p>再回到上面的例子，从上面的分析中可以看出，join(0)方法实现了一定程度上的线程同步，<strong>即当前线程只有等join方法所属的线程对象所代表的线程终止执行了才能继续往下执行，否则将一直挂起等待。</strong></p><p>这一点也说明使用join(0)是很危险的，因为如果myThread线程因为得不到资源一直被挂起，而main线程又在等待myThread线程终止，则程序永远会停在那里，无法终止，所以源码中提供了限时等待的版本:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public final synchronized void join(long millis) throws InterruptedException &#123;</span><br><span class="line">        long base = System.currentTimeMillis();</span><br><span class="line">        long now = 0;</span><br><span class="line">        ...</span><br><span class="line">        if (millis == 0) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            while (isAlive()) &#123;</span><br><span class="line">                long delay = millis - now;</span><br><span class="line">                if (delay &lt;= 0) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                wait(delay);</span><br><span class="line">                now = System.currentTimeMillis() - base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>与无限期等待不同的是，限时等待只等待指定时间，如果指定的时间到了就直接从循环中跳出来，使用的wai方法也是限时wait的版本，定时时间到了之后，main线程会被自动唤醒。上面的代码是自解释的，我就不再赘述了。</p><p>接下来我们再来看看其他两个版本的join方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public final void join() throws InterruptedException &#123;</span><br><span class="line">    join(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final synchronized void join(long millis, int nanos) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    if (millis &lt; 0) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;timeout value is negative&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (nanos &lt; 0 || nanos &gt; 999999) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;nanosecond timeout value out of range&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (nanos &gt;= 500000 || (nanos != 0 &amp;&amp; millis == 0)) &#123;</span><br><span class="line">        millis++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    join(millis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，其他两个版本最终调用的都是我们分析的第一版本，这和wait方法，sleep方法很像，至于为什么wait方法和join方法都提供了无参方法而sleep方法没有，我个人认为是为了保持语义的一致性:</p><p>wait()和join()分别和wait(0)和join(0)等价，他们都代表了无限期等待，而sleep(0)并不代表无限期等待，所以sleep方法没有无参的形式，以防止语义上的混乱。除这点之外，这三个方法在两个参数的版本XXX(long millis, int nanos)中的实现，都大同小异。</p><p>另外最后一点值得注意的是，我们在join方法中只调用了isAlive方法检测线程是否存活，并没有启动这个线程，也就是说，如果我们想要实现当前线程等待myThread线程执行完成之后再执行的效果，就必须在调用myThread.join()之前调用myThread.start()让线程先跑起来，否则join方法发现isAlive为false会立即退出，myThread线程就不会被执行，大家可以将myThread.start()注释掉自己跑一跑试试看。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇依然是通过源码分析来了解这些知识。&lt;/p&gt;
&lt;p&gt;本文源码基于jdk1.8 。&lt;/p&gt;
&lt;h2 id=&quot;线程状态&quot;&gt;&lt;a href=&quot;#线程状态&quot; class=&quot;headerlink&quot; title=&quot;线程状态&quot;&gt;&lt;/a&gt;线程状态&lt;/h2&gt;&lt;p&gt;在Thread类中, 线程
      
    
    </summary>
    
      <category term="并发编程" scheme="http://ruanshubin.top/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://ruanshubin.top/tags/Java/"/>
    
      <category term="并发" scheme="http://ruanshubin.top/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Thread类源码解读1--如何创建和启动线程</title>
    <link href="http://ruanshubin.top/2019/11/05/Thread%E7%B1%BB%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB1%E2%80%94%E2%80%94%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%92%8C%E5%90%AF%E5%8A%A8%E7%BA%BF%E7%A8%8B/"/>
    <id>http://ruanshubin.top/2019/11/05/Thread类源码解读1——如何创建和启动线程/</id>
    <published>2019-11-05T13:30:00.000Z</published>
    <updated>2019-12-25T05:46:53.341Z</updated>
    
    <content type="html"><![CDATA[<p>本文源码基于jdk1.8 。</p><h2 id="Runnale接口"><a href="#Runnale接口" class="headerlink" title="Runnale接口"></a>Runnale接口</h2><p>我们看Thread类的定义知道，它实现了Runable接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Thread implements Runnable &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而Runnable接口的定义如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Runnable &#123;</span><br><span class="line">    public abstract void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它只有一个抽象方法run。同时，该接口还被@FunctionalInterface注解标注，说明它是一个函数式接口(@FunctionalInterface是java 1.8版本之后引入的)。这意味着我们可以使用Lambda表达式来创建Runnable接口的实例，这个我们到后面再举例。</p><h2 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h2><p>在java中，创建一个线程，有且仅有一种方式:</p><p><strong>创建一个Thread类实例，并调用它的start方法。</strong></p><p>这写在了java语言规范中(参见The Java Language Specification, Java SE 8 Edition, P659,chapter17):</p><blockquote><p>Threads are represented by the Thread class. The only way for a user to create a thread is to create an object of this class; each thread is associated with such an object. A thread will start when the start() method is invoked on the corresponding Thread object.</p></blockquote><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>要创建一个Thread类的实例自然要通过构造函数，Thread的public构造函数有8个之多，但是他们本质上都调用了同一个init函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public Thread() &#123;</span><br><span class="line">    init(null, null, &quot;Thread-&quot; + nextThreadNum(), 0);</span><br><span class="line">&#125;</span><br><span class="line">public Thread(String name) &#123;</span><br><span class="line">    init(null, null, name, 0);</span><br><span class="line">&#125;</span><br><span class="line">public Thread(Runnable target) &#123;</span><br><span class="line">    init(null, target, &quot;Thread-&quot; + nextThreadNum(), 0);</span><br><span class="line">&#125;</span><br><span class="line">public Thread(Runnable target, String name) &#123;</span><br><span class="line">    init(null, target, name, 0);</span><br><span class="line">&#125;</span><br><span class="line">public Thread(ThreadGroup group, Runnable target) &#123;</span><br><span class="line">    init(group, target, &quot;Thread-&quot; + nextThreadNum(), 0);</span><br><span class="line">&#125;</span><br><span class="line">public Thread(ThreadGroup group, String name) &#123;</span><br><span class="line">    init(group, null, name, 0);</span><br><span class="line">&#125;</span><br><span class="line">public Thread(ThreadGroup group, Runnable target, String name) &#123;</span><br><span class="line">    init(group, target, name, 0);</span><br><span class="line">&#125;</span><br><span class="line">public Thread(ThreadGroup group, Runnable target, String name, long stackSize) &#123;</span><br><span class="line">    init(group, target, name, stackSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，这八个public类型的构造函数只不过是给init的方法的四个参数分别赋不同的值, 这四个参数分别是:</p><ul><li>ThreadGroup g（线程组）</li><li>Runnable target （Runnable 对象）</li><li>String name （线程的名字）</li><li>long stackSize （为线程分配的栈的大小，若为0则表示忽略这个参数）</li></ul><p>而init方法又调用了另一个init方法，设置了AccessController，以及inheritThreadLocals参数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Initializes a Thread with the current AccessControlContext.</span><br><span class="line"> * @see #init(ThreadGroup,Runnable,String,long,AccessControlContext,boolean)</span><br><span class="line"> */</span><br><span class="line">private void init(ThreadGroup g, Runnable target, String name, long stackSize) &#123;</span><br><span class="line">    init(g, target, name, stackSize, null, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//上面那个init方法最终调用了下面这个方法:</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Initializes a Thread.</span><br><span class="line"> *</span><br><span class="line"> * @param g the Thread group</span><br><span class="line"> * @param target the object whose run() method gets called</span><br><span class="line"> * @param name the name of the new Thread</span><br><span class="line"> * @param stackSize the desired stack size for the new thread, or</span><br><span class="line"> *        zero to indicate that this parameter is to be ignored.</span><br><span class="line"> * @param acc the AccessControlContext to inherit, or</span><br><span class="line"> *            AccessController.getContext() if null</span><br><span class="line"> * @param inheritThreadLocals if &#123;@code true&#125;, inherit initial values for</span><br><span class="line"> *            inheritable thread-locals from the constructing thread</span><br><span class="line"> */</span><br><span class="line">private void init(ThreadGroup g, Runnable target, String name, long stackSize, AccessControlContext acc, boolean inheritThreadLocals) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>init方法中有一些关于线程组和访问控制上下文的设置，这里我们暂时就不深入讨论了。</p><p>所以综上来看，我们最常用的也就两个参数:</p><ul><li>Runnable target （Runnable 对象）</li><li>String name （线程的名字）</li></ul><p>而对于线程的名字，其默认值为”Thread-“ + nextThreadNum(), nextThreadNum方法又是什么呢:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* For autonumbering anonymous threads. */</span><br><span class="line">private static int threadInitNumber;</span><br><span class="line">private static synchronized int nextThreadNum() &#123;</span><br><span class="line">    return threadInitNumber++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，它就是一个简单的递增计数器，所以如果创建线程时没有指定线程名，那线程名就会是:<br>Thread-0, Thread-1, Thread-2, Thread-3, …</p><p>至此，我们看到，虽然Thread类的构造函数有这么多，但对我们来说真正重要的参数只有一个：</p><blockquote><p>Runnable target （Runnable 对象）</p></blockquote><p><strong>所以创建一个线程实例最重要的是要传入一个Runnable类型对象。</strong></p><p>既然是Runnable类型，那么这个target必然是实现了Runnable接口的，也就是说该对象一定覆写了run方法。</p><p>我们知道，Thread类本身也实现了Runnable接口，所以它必然也覆写了run方法，我们先来看看它的run方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    if (target != null) &#123;</span><br><span class="line">        target.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这个run方法仅仅是调用了target对象的run方法，如果我们在线程构造时没有传入target（例如调用了无参构造函数），那么这个run方法就什么也不会做。</p><h3 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h3><p>线程对象创建完了之后，接下来就是启动一个线程，在java中，启动一个线程必须调用线程的start方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Causes this thread to begin execution; the Java Virtual Machine</span><br><span class="line"> * calls the &lt;code&gt;run&lt;/code&gt; method of this thread.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * The result is that two threads are running concurrently: the</span><br><span class="line"> * current thread (which returns from the call to the</span><br><span class="line"> * &lt;code&gt;start&lt;/code&gt; method) and the other thread (which executes its</span><br><span class="line"> * &lt;code&gt;run&lt;/code&gt; method).</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * It is never legal to start a thread more than once.</span><br><span class="line"> * In particular, a thread may not be restarted once it has completed</span><br><span class="line"> * execution.</span><br><span class="line"> *</span><br><span class="line"> * @exception  IllegalThreadStateException  if the thread was already</span><br><span class="line"> *               started.</span><br><span class="line"> * @see        #run()</span><br><span class="line"> * @see        #stop()</span><br><span class="line"> */</span><br><span class="line">public synchronized void start() &#123;</span><br><span class="line">    /**</span><br><span class="line">     * This method is not invoked for the main method thread or &quot;system&quot;</span><br><span class="line">     * group threads created/set up by the VM. Any new functionality added</span><br><span class="line">     * to this method in the future may have to also be added to the VM.</span><br><span class="line">     *</span><br><span class="line">     * A zero status value corresponds to state &quot;NEW&quot;.</span><br><span class="line">     */</span><br><span class="line">    if (threadStatus != 0)</span><br><span class="line">        throw new IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">    /* Notify the group that this thread is about to be started</span><br><span class="line">     * so that it can be added to the group&apos;s list of threads</span><br><span class="line">     * and the group&apos;s unstarted count can be decremented. */</span><br><span class="line">    group.add(this);</span><br><span class="line"></span><br><span class="line">    boolean started = false;</span><br><span class="line">    try &#123;</span><br><span class="line">        start0();</span><br><span class="line">        started = true;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (!started) &#123;</span><br><span class="line">                group.threadStartFailed(this);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable ignore) &#123;</span><br><span class="line">            /* do nothing. If start0 threw a Throwable then</span><br><span class="line">              it will be passed up the call stack */</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private native void start0()</span><br></pre></td></tr></table></figure><p>这个方法本质是调用了native的start0()方法，但是它的注释部分说明一些很重要的信息:</p><p>这个方法使得线程开始执行，并由JVM来执行这个线程的run方法，结果就是有两个线程在并发执行，一个是当前线程，也就是调用了Thread#start方法的线程，另一个线程就是当前thread对象代表的线程，它执行了run方法。</p><p>也就是说，这个Thread类实例代表的线程最终会执行它的run方法，而上面的分析中我们知道，它的run做的事就是调用Runnable对象的run方法，如果Runnable对象为null, 就啥也不做:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    if (target != null) &#123;</span><br><span class="line">        target.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有的同学就要问了，绕了一大圈，忙了大半天，最后不就是为了执行target对象的run方法吗？为什么我们不直接调用target的run方法？这一层层的调用究竟是为了啥？ 答案是：</p><p><strong>为了使用多线程 ！</strong></p><p>我们知道，Thread类从定义上看就是个普通的java类，是什么魔法让它从一个普通的java类晋升为一个可以代表线程的类呢？是native方法！</p><p><strong>如果我们直接调用target对象的run方法，或者Thread类的run方法，那就是一个普通调用，因为run方法就是普普通通的类方法，与我们平时调用的其他类方法没有什么不同，这并不会产生多线程。</strong></p><p>但是，如果我们调用了start方法，由于它内部使用了native方法来启动线程，<strong>它将导致一个新的线程被创建出来</strong>, 而我们的Thread实例, 就代表了这个新创建出来的线程, 并且由这个新创建出来的线程来执行Thread实例的run方法。</p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>说了这么多理论的东西，下面让我们通过一个实战来加深理解。java官方文档给我们提供了两种创建线程的方法.</p><h3 id="方法1：继承Thread类，覆写run方法"><a href="#方法1：继承Thread类，覆写run方法" class="headerlink" title="方法1：继承Thread类，覆写run方法"></a>方法1：继承Thread类，覆写run方法</h3><p>首先我们自定义一个继承自Thread的类，并覆写run方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class CustomizedThread extends Thread &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;[&quot; + Thread.currentThread().getName() + &quot;线程]: &quot; + &quot;我是定义在CustomizedThread类中的run方法。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们创建类的实例，并调用start方法启动这个线程:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class CustomizedThreadTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;[&quot; + Thread.currentThread().getName() + &quot;线程]: &quot; + &quot;我在main方法里&quot;);</span><br><span class="line">        CustomizedThread myThread = new CustomizedThread();</span><br><span class="line">        myThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[main线程]: 我在main方法里</span><br><span class="line">[Thread-0线程]: 我是定义在CustomizedThread类中的run方法。</span><br></pre></td></tr></table></figure><p>可见，这里有两个线程，一个是main线程，它执行了main方法，一个是Thread-0线程，它是我们自定义的线程，它执行了run方法。</p><p>如果我们不通过start方法来运行线程会有什么不同呢:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class CustomizedThreadTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;[&quot; + Thread.currentThread().getName() + &quot;线程]: &quot; + &quot;我在main方法里&quot;);</span><br><span class="line">        CustomizedThread myThread = new CustomizedThread();</span><br><span class="line">        //myThread.start();</span><br><span class="line">        myThread.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们直接调用自定义线程的run方法，看看结果有什么不同:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[main线程]: 我在main方法里</span><br><span class="line">[main线程]: 我是定义在CustomizedThread类中的run方法。</span><br></pre></td></tr></table></figure><p>可见，这次只有一个main线程，由main线程执行了我们自定义线程类的run方法，并没有新的线程产生。 其实这个时候，CustomizedThread的run方法就是一个普普通通的类的普普通通的方法，与我们平时定义的方法并没有什么特别之处。</p><p>有的同学要问了，上面不是说创建一个线程最重要的是传入一个Runnable对象吗？ 我没有看到Runnable对象啊？ 别急，我们来分析一下：</p><p>首先，我们的CustomizedThread继承自Thread类，则我们会调用父类的无参构造函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Thread() &#123;</span><br><span class="line">    init(null, null, &quot;Thread-&quot; + nextThreadNum(), 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个构造函数中，target对象为null;</p><p>然后，我们使用了myThread.start()，因为我们在子类中没有定义start方法，所以，这个方法来自父类，而Thread类的start方法的作用我们已经讲过，它将新建一个线程，并调用它的run方法，这个新建的线程的抽象代表就是我们的CustomizedThread，所以它的(CustomizedThread的)run方法将会被调用。</p><p>那么，如果我们的子类没有覆写run方法呢？，那自然是继承Thread类自己的run方法了:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    if (target != null) &#123;</span><br><span class="line">        target.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而Thread类的run方法调用的又是target对象的run方法，而target对象现在为null, 所以这个方法啥也不做。</p><p>所以到这里我们就很清晰了，<strong>创建一个线程最重要的是定义一个run方法，这个run方法要么通过继承Thread类的子类覆写，要么通过直接构造Thread类时传入一个Runnable的target对象。无论它由子类覆写提供还是由target对象提供，start方法最终都会新建一个线程来执行这个run方法。</strong></p><h3 id="方法2：通过Runnable接口创建线程类"><a href="#方法2：通过Runnable接口创建线程类" class="headerlink" title="方法2：通过Runnable接口创建线程类"></a>方法2：通过Runnable接口创建线程类</h3><p>我们先来看官方的例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class PrimeRun implements Runnable &#123;</span><br><span class="line">     long minPrime;</span><br><span class="line">     PrimeRun(long minPrime) &#123;</span><br><span class="line">         this.minPrime = minPrime;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     public void run() &#123;</span><br><span class="line">         // compute primes larger than minPrime</span><br><span class="line">          . . .</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">//The following code would then create a thread and start it running:</span><br><span class="line"></span><br><span class="line">PrimeRun p = new PrimeRun(143);</span><br><span class="line">new Thread(p).start();</span><br></pre></td></tr></table></figure><p>这个例子中首先定义了一个PrimeRun类实现了Runnable接口，接着实例化出一个对象p，并将这个对象作为参数传递给Thread类的构造方法。</p><p>这种方法看上去好像复杂了好多，但其实就是通过新建Thread类的对象来创建线程。它本质上就是传递一个Runnable对象给Thread的构造函数，所以我们完全可以用匿名类，又因为Runnable是一个函数接口，所以上面的代码完全可以被简写，我们来看一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class CustomizedThreadTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;[&quot; + Thread.currentThread().getName() + &quot;线程]: &quot; + &quot;我在main方法里&quot;);</span><br><span class="line">        Thread myThread = new Thread(() -&gt; System.out.println(&quot;[&quot; + Thread.currentThread().getName() + &quot;线程]: &quot; + &quot;我是传递给Thread类的Runnable对象的run方法&quot;));</span><br><span class="line">        myThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[main线程]: 我在main方法里</span><br><span class="line">[Thread-0线程]: 我是传递给Thread类的Runnable对象的run方法</span><br></pre></td></tr></table></figure><p>这里，myThread是我们new出来的Thread类的实例，我们调用了Thread类的构造函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Thread(Runnable target) &#123;</span><br><span class="line">    init(null, target, &quot;Thread-&quot; + nextThreadNum(), 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入了一个Runnable对象，这个Runnable对象由lambda表达式表示。我们最后调用了 myThread.start()来启动这个线程，通过上一节的分析我们知道，start方法会调用run方法，而thread类的run方法最终会调用target对象的run方法，而target对象的run方法就是我们传进来的lambda表达式。上面这个例子其实等效于下面这种写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class CustomizedThreadTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;[&quot; + Thread.currentThread().getName() + &quot;线程]: &quot; + &quot;我在main方法里&quot;);</span><br><span class="line">        Thread myThread = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;[&quot; + Thread.currentThread().getName() + &quot;线程]: &quot; + &quot;我是传递给Thread类的Runnable对象的run方法&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        myThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见函数式接口和lambda表达式使我们的书写变得简洁多了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在java中，创建一个线程，有且仅有一种方式:</p><blockquote><p>创建一个Thread类实例，并调用它的start方法。</p></blockquote><p>创建一个Thread类的实例最重要的是定义一个run方法，这个run方法说明了这个线程具体要做什么事情。有两种方式定义一个run方法:</p><ul><li>继承Thread类，覆写run方法</li><li>实现Runnale接口，将它作为target参数传递给Thread类构造函数</li></ul><p>启动一个线程一定要调用该线程的start方法，否则，并不会创建出新的线程来。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文源码基于jdk1.8 。&lt;/p&gt;
&lt;h2 id=&quot;Runnale接口&quot;&gt;&lt;a href=&quot;#Runnale接口&quot; class=&quot;headerlink&quot; title=&quot;Runnale接口&quot;&gt;&lt;/a&gt;Runnale接口&lt;/h2&gt;&lt;p&gt;我们看Thread类的定义知道，它实现了
      
    
    </summary>
    
      <category term="并发编程" scheme="http://ruanshubin.top/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://ruanshubin.top/tags/Java/"/>
    
      <category term="并发" scheme="http://ruanshubin.top/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL</title>
    <link href="http://ruanshubin.top/2019/11/02/PostgreSQL%E5%AE%89%E8%A3%85/"/>
    <id>http://ruanshubin.top/2019/11/02/PostgreSQL安装/</id>
    <published>2019-11-02T13:30:00.000Z</published>
    <updated>2019-12-25T03:16:55.091Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备编译环境"><a href="#准备编译环境" class="headerlink" title="准备编译环境"></a>准备编译环境</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 检查服务器上是否存在gcc-c++的环境，使用命令：</span><br><span class="line">rpm -qa | grep gcc-c++</span><br><span class="line"></span><br><span class="line"># 若无，则访问镜像网站获取：http://mirrors.aliyun.com/centos/7/os/x86_64/Packages/</span><br><span class="line"></span><br><span class="line">rpm -Uvh *.rpm --nodeps --force</span><br><span class="line"></span><br><span class="line"># 查看gcc版本和g++版本，会看到详细的版本信息，安装完成</span><br><span class="line"></span><br><span class="line">gcc -v</span><br><span class="line">g++ -v</span><br></pre></td></tr></table></figure><h2 id="编译postgresql源码包，并安装"><a href="#编译postgresql源码包，并安装" class="headerlink" title="编译postgresql源码包，并安装"></a>编译postgresql源码包，并安装</h2><p>访问 <a href="https://www.postgresql.org/ftp/source/，选择对应版本：" target="_blank" rel="noopener">https://www.postgresql.org/ftp/source/，选择对应版本：</a></p><p><img src="/2019/11/02/PostgreSQL安装/1.jpg" alt=""></p><p>点击之后，下载对应的tar.gz源码包，然后将其上传到服务器指定路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">[root@test postgresql]# tar -zvxf postgresql-9.6.9.tar.gz </span><br><span class="line"></span><br><span class="line"># 进入解压后目录，通过命令 ./configure --help 可以看到配置相关的帮助信息</span><br><span class="line">[root@test postgresql]# cd postgresql-9.6.9/</span><br><span class="line">[root@test postgresql-9.6.9]# ./configure --help</span><br><span class="line"></span><br><span class="line"># 其中，--prefix=dir 可以指定安装目录：</span><br><span class="line">[root@test software]# mkdir pgsql</span><br><span class="line"></span><br><span class="line">[root@test postgresql-9.6.9]# ./configure --prefix=/usr/software/pgsql</span><br><span class="line"></span><br><span class="line"># 此时，会报以下错误：</span><br><span class="line"></span><br><span class="line">configure: error: readline library not found</span><br><span class="line">If you have readline already installed, see config.log for details on the</span><br><span class="line">failure.  It is possible the compiler isn&apos;t looking in the proper directory.</span><br><span class="line">Use --without-readline to disable readline support.</span><br><span class="line"></span><br><span class="line"># 安装缺少的包即可</span><br><span class="line"></span><br><span class="line">[root@test outrpm]# rpm -ivh ncurses-devel-5.9-14.20130511.el7_4.x86_64.rpm </span><br><span class="line">[root@test outrpm]# rpm -ivh readline-devel-6.2-10.el7.x86_64.rpm </span><br><span class="line">[root@test outrpm]# rpm -ivh zlib-1.2.7-18.el7.x86_64.rpm </span><br><span class="line"></span><br><span class="line"># 安装zlib会与原来的zlib冲突</span><br><span class="line">[root@test outrpm]# rpm -ivh zlib-1.2.7-18.el7.x86_64.rpm </span><br><span class="line">warning: zlib-1.2.7-18.el7.x86_64.rpm: Header V3 RSA/SHA256 Signature, key ID f4a80eb5: NOKEY</span><br><span class="line">Preparing...                          ################################# [100%]</span><br><span class="line">        file /usr/lib64/libz.so.1.2.7 from install of zlib-1.2.7-18.el7.x86_64 conflicts with file from package zlib-1.2.7-17.el7.x86_64</span><br><span class="line"></span><br><span class="line"># 添加--force参数强制更新  --nodeps 为不考虑依赖</span><br><span class="line">[root@test outrpm]# rpm -ivh zlib-1.2.7-18.el7.x86_64.rpm --force</span><br><span class="line"></span><br><span class="line">[root@tcd-test outrpm]# rpm -ivh zlib-devel-1.2.7-18.el7.x86_64.rpm </span><br><span class="line"></span><br><span class="line"># 然后，重新注册即可</span><br><span class="line">[root@test postgresql-9.6.9]# ./configure --prefix=/usr/software/pgsql</span><br><span class="line">[root@tcd-test postgresql-9.6.9]# make</span><br><span class="line">[root@tcd-test postgresql-9.6.9]# make install</span><br></pre></td></tr></table></figure><h2 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h2><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@tcd-test ~]# groupadd postgres</span><br><span class="line">[root@tcd-test ~]# useradd postgres -g postgres</span><br><span class="line">[root@tcd-test ~]# passwd postgres</span><br><span class="line"></span><br><span class="line"># 在安装目录创建data和log目录</span><br><span class="line">[root@tcd-test ~]# cd /usr/software/pgsql/</span><br><span class="line">[root@tcd-test pgsql]# mkdir data</span><br><span class="line">[root@tcd-test pgsql]# mkdir log</span><br><span class="line"></span><br><span class="line"># 设定权限</span><br><span class="line">[root@tcd-test ~]# chown -R postgres:postgres /usr/software/pgsql/</span><br></pre></td></tr></table></figure><h3 id="环境变量配置"><a href="#环境变量配置" class="headerlink" title="环境变量配置"></a>环境变量配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line"># 底部添加以下内容：</span><br><span class="line">export PGDATA=/usr/software/pgsql/data</span><br><span class="line">export PG_HOME=/usr/software/pgsql</span><br><span class="line">export PATH=$PATH:$PG_HOME/bin</span><br><span class="line"></span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><h3 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 初始化数据库的帮助信息</span><br><span class="line">[root@tcd-test pgsql]# initdb --help</span><br></pre></td></tr></table></figure><p><img src="/2019/11/02/PostgreSQL安装/2.jpg" alt=""></p><p>由于之前在配置文件中已经设定了环境变量 PGDATA ，因此可以直接使用命令 initdb 来完成数据库初始化操作。</p><p><strong>切换为postgres用户</strong>,初始化数据库。</p><p>注意，如果root用户下执行数据库初始化操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@tcd-test pgsql]# initdb </span><br><span class="line">initdb: cannot be run as root</span><br><span class="line">Please log in (using, e.g., &quot;su&quot;) as the (unprivileged) user that will</span><br><span class="line">own the server process.</span><br><span class="line"></span><br><span class="line">[root@tcd-test pgsql]# su postgres</span><br><span class="line">[postgres@tcd-test pgsql]$ initdb</span><br></pre></td></tr></table></figure><h3 id="配置数据库"><a href="#配置数据库" class="headerlink" title="配置数据库"></a>配置数据库</h3><p>进入*/pgsql/data 目录，使用命令vim pg_hba.conf，配置对数据库的访问控制(设置为可以通过密码访问);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[postgres@tcd-test pgsql]$ cd /usr/software/pgsql/data</span><br><span class="line">[postgres@tcd-test data]$ vim ./pg_hba.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/11/02/PostgreSQL安装/3.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[postgres@tcd-test data]$ vim ./postgresql.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/11/02/PostgreSQL安装/4.jpg" alt=""></p><h3 id="关闭防火墙-root用户"><a href="#关闭防火墙-root用户" class="headerlink" title="关闭防火墙(root用户)"></a>关闭防火墙(root用户)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 查看防火墙状态</span><br><span class="line">systemctl status firewalld</span><br><span class="line"># 关闭防火墙</span><br><span class="line">systemctl stop firewalld</span><br><span class="line"># 设置开机不启动</span><br><span class="line">systemctl disable firewalld</span><br></pre></td></tr></table></figure><h3 id="配置系统服务-root用户"><a href="#配置系统服务-root用户" class="headerlink" title="配置系统服务(root用户)"></a>配置系统服务(root用户)</h3><p>进入postgresql源码包的解压目录；</p><p>执行命令 cp contrib/start-scripts/linux /etc/init.d/postgresql；</p><p>然后vim /etc/init.d/postgresql，进行配置修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@tcd-test ~]# cd /usr/software/postgresql/postgresql-9.6.9/</span><br><span class="line">[root@tcd-test postgresql-9.6.9]# cp contrib/start-scripts/linux /etc/init.d/postgresql</span><br><span class="line">vim /etc/init.d/postgresql</span><br></pre></td></tr></table></figure><p><img src="/2019/11/02/PostgreSQL安装/5.jpg" alt=""></p><p>使用命令chmod +x /etc/init.d/postgresql，赋予该文件执行权限;</p><p>另外，还可以使用命令chkconfig —add postgresql，设置服务开机自启。</p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><h3 id="启动数据库服务"><a href="#启动数据库服务" class="headerlink" title="启动数据库服务"></a>启动数据库服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@tcd-test ~]# service postgresql status</span><br><span class="line">pg_ctl: no server running</span><br><span class="line">[root@tcd-test ~]# service postgresql start</span><br><span class="line">Starting PostgreSQL: ok</span><br></pre></td></tr></table></figure><h3 id="本地连接"><a href="#本地连接" class="headerlink" title="本地连接"></a>本地连接</h3><p>启动成功后，可以通过postgresql自带的客户端工具psql来进行连接；</p><p>postgresql用户直接输入psql看到版本信息则说明连接成功。</p><p>然后，使用 “\password”，设置密码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@tcd-test ~]# su postgres</span><br><span class="line">[postgres@tcd-test root]$ psql</span><br><span class="line">could not change directory to &quot;/root&quot;: Permission denied</span><br><span class="line">psql (9.6.9)</span><br><span class="line">Type &quot;help&quot; for help.</span><br><span class="line"></span><br><span class="line">postgres=# \password</span><br><span class="line">Enter new password: </span><br><span class="line">Enter it again: </span><br><span class="line">postgres=# </span><br><span class="line">postgres=# \l</span><br><span class="line">                                  List of databases</span><br><span class="line">   Name    |  Owner   | Encoding |   Collate   |    Ctype    |   Access privileges   </span><br><span class="line">-----------+----------+----------+-------------+-------------+-----------------------</span><br><span class="line"> postgres  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | </span><br><span class="line"> template0 | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +</span><br><span class="line">           |          |          |             |             | postgres=CTc/postgres</span><br><span class="line"> template1 | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +</span><br><span class="line">           |          |          |             |             | postgres=CTc/postgres</span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure><h3 id="远程连接"><a href="#远程连接" class="headerlink" title="远程连接"></a>远程连接</h3><p><img src="/2019/11/02/PostgreSQL安装/6.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;准备编译环境&quot;&gt;&lt;a href=&quot;#准备编译环境&quot; class=&quot;headerlink&quot; title=&quot;准备编译环境&quot;&gt;&lt;/a&gt;准备编译环境&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gut
      
    
    </summary>
    
      <category term="基础" scheme="http://ruanshubin.top/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="数据库" scheme="http://ruanshubin.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="PostgreSQL" scheme="http://ruanshubin.top/tags/PostgreSQL/"/>
    
  </entry>
  
  <entry>
    <title>git私服搭建</title>
    <link href="http://ruanshubin.top/2019/11/01/git%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/"/>
    <id>http://ruanshubin.top/2019/11/01/git私服搭建/</id>
    <published>2019-11-01T13:30:00.000Z</published>
    <updated>2019-12-25T03:12:21.896Z</updated>
    
    <content type="html"><![CDATA[<h2 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h2><p>系统： Linux：<strong>CentOS 7.2 64位</strong></p><p>由于CentOS已经内置了<strong>OpenSSH</strong>,如果您的系统没有，请自行安装。</p><p>查看ssh版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@ruanshubin ~]# ssh -V</span><br><span class="line"></span><br><span class="line"># 输出以下表示没问题，可以继续。 版本可能不一致，能用即可。</span><br><span class="line">OpenSSH_7.4p1, OpenSSL 1.0.2k-fips  26 Jan 2017</span><br></pre></td></tr></table></figure><blockquote><p>避免系统环境和其他的不一致，请核对您系统的版本，其他发行版请对应修改。</p></blockquote><h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><p>建议以下操作都切换到root:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 请确保您切换到了root账户</span><br><span class="line">$ su root</span><br><span class="line">$ yum install -y git</span><br><span class="line"></span><br><span class="line"># 验证是否安装成功</span><br><span class="line">$ git --version</span><br><span class="line"># 输出如下内容表示成功：</span><br><span class="line">git version x.x.x.x</span><br></pre></td></tr></table></figure><h2 id="添加git的管理的账户和设置密码"><a href="#添加git的管理的账户和设置密码" class="headerlink" title="添加git的管理的账户和设置密码"></a>添加git的管理的账户和设置密码</h2><p>设置专门管理git的账号非必须，但是建议这么操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 添加git账户</span><br><span class="line">$ adduser git</span><br><span class="line"></span><br><span class="line"># 修改git的密码</span><br><span class="line">$ passwd git</span><br><span class="line"># 然后两次输入git的密码确认后。</span><br><span class="line"></span><br><span class="line"># 查看git是否安装成功</span><br><span class="line">$ cd /home &amp;&amp; ls -al</span><br><span class="line"># 如果已经有了git，那么表示成，参考如下：</span><br><span class="line">drwxr-xr-x.  5 root root 4096 Apr  4 15:03 .</span><br><span class="line">dr-xr-xr-x. 19 root root 4096 Apr  4 15:05 ..</span><br><span class="line">drwx------  10 git  git  4096 Apr  4 00:26 git</span><br><span class="line"></span><br><span class="line"># 默认还给我们分配一个名字叫git的组。</span><br></pre></td></tr></table></figure><h2 id="git的权限管理"><a href="#git的权限管理" class="headerlink" title="git的权限管理"></a>git的权限管理</h2><p>git仓库的权限管理，我们可以手动进行管理和配置，也可以通过其他辅助工具。如果小团队的话，直接通过ssh公钥进行管理即可，如果大点的团队，最好用gitolite 或者 gitosis，两者都差不多，一个是Perl开发，一个是Python开发。</p><p>以下我分别介绍手动管理权限和使用gitolite管理的方式，注意两者不兼容，不能混用。</p><h3 id="git的手动权限管理"><a href="#git的手动权限管理" class="headerlink" title="git的手动权限管理"></a>git的手动权限管理</h3><p>经过以上步骤，其实服务器的基本已经配置好，但是需要设置权限和配置远程访问git仓库的方式。我们只介绍ssh的方式，https不做介绍。</p><h4 id="配置服务端的ssh访问"><a href="#配置服务端的ssh访问" class="headerlink" title="配置服务端的ssh访问"></a>配置服务端的ssh访问</h4><p>切换到git账号,并创建ssh的默认目录和校验公钥的配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 1.切换到git账号</span><br><span class="line">$ su git</span><br><span class="line"># 2.进入 git账户的主目录</span><br><span class="line">$ cd /home/git</span><br><span class="line"></span><br><span class="line"># 3.创建.ssh的配置，如果此文件夹已经存在请忽略此步。</span><br><span class="line">$ mkdir .ssh</span><br><span class="line"></span><br><span class="line"># 4. 进入刚创建的.ssh目录并创建authorized_keys文件,此文件存放客户端远程访问的 ssh的公钥。</span><br><span class="line">$ cd /home/git/.ssh</span><br><span class="line">$ touch authorized_keys</span><br><span class="line"></span><br><span class="line"># 5. 设置权限，此步骤不能省略，而且权限值也不要改，不然会报错。</span><br><span class="line">$ chmod 700 /home/git/.ssh/</span><br><span class="line">$ chmod 600 /home/git/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>此时，服务端的配置基本完成。接下需要把客户端的公钥拷贝到authorized_keys文件中。</p><h4 id="配置客户端的ssh私钥并上传服务器"><a href="#配置客户端的ssh私钥并上传服务器" class="headerlink" title="配置客户端的ssh私钥并上传服务器"></a>配置客户端的ssh私钥并上传服务器</h4><p>以下是客户端创建ssh私钥和拷贝的过程，如果您有私钥越过创建私钥的过程。</p><p>请用您的客户端进入终端（如果只有一台电脑，可以用不同的账号模拟不同客户端）</p><p>第一步： 创建客户端的ssh私钥和公钥</p><p>检查是否已经拥有ssh公钥和私钥：进入用户的主目录。</p><p>用户主目录：<br>Windows系统：C:\Users\用户名<br>Linux系统：/home/用户名<br>Mac系统：/Users/用户名</p><p>然后查看是否有.ssh文件夹，此文件夹下是否有如下几个文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 用户主目录的.ssh文件夹下</span><br><span class="line">.ssh</span><br><span class="line">├── id_rsa</span><br><span class="line">└── id_rsa.pub  # 我们要用的私钥</span><br></pre></td></tr></table></figure><p>如果没有，那么用ssh-keygen创建ssh的私钥。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa</span><br><span class="line"></span><br><span class="line"># 接下来，三个回车默认即可。</span><br></pre></td></tr></table></figure><p>创建私钥成功后，在查看用户目录是否有意加有了公钥文件id_rsa.pub</p><p>第二步： 拷贝私钥到git的服务器</p><p>如何把客户端的文件拷贝到服务器端，我建议用scp命令进行拷贝。</p><p>以下以mac系统为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 首先进入我的用户主目录的.ssh目录下，注意用户名xxx替换成自己的</span><br><span class="line">$ cd /Users/xxx/.ssh</span><br><span class="line"></span><br><span class="line"># 以下命令是：把本地的id_rsa.pub文件拷贝到 aicoder.com服务器，登录aicoder.com服务的账号是git。</span><br><span class="line"># 冒号后面默认就是git账号的主目录，最后文件被保存成laoma.pub</span><br><span class="line"># 注意：把域名换成你自己的或者ip，最后的文件名可以自己定，后面还有用。</span><br><span class="line">$ scp ./id_rsa.pub git@aicoder.com:.ssh/laoma.pub</span><br></pre></td></tr></table></figure><h4 id="服务器端添加客户端的SSH公钥"><a href="#服务器端添加客户端的SSH公钥" class="headerlink" title="服务器端添加客户端的SSH公钥"></a>服务器端添加客户端的SSH公钥</h4><p>切换到服务器端，把刚才上传的laoma.pub文件的内容添加到 authorized_keys中，就可以允许客户端ssh访问了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 切换到git账户</span><br><span class="line">$ su git</span><br><span class="line">$ cd /home/git/.ssh</span><br><span class="line"></span><br><span class="line">$ ls -al</span><br><span class="line"># 查看一下.ssh目录是否有authorized_keys和laoma.pub文件</span><br><span class="line"># .</span><br><span class="line"># |-- authorized_keys</span><br><span class="line"># `-- laoma.pub</span><br><span class="line"></span><br><span class="line"># 如果有，那么进行下面的把laoma.pub文件中的内容添加到authorized_keys中.</span><br><span class="line">$ cat laoma.pub &gt;&gt; authorized_keys</span><br><span class="line"></span><br><span class="line"># &gt;&gt; 是在文件后面追加的意思，主要如果用其他编辑器，每个ssh的pub要单独一行，建议用cat命令方便简单。</span><br></pre></td></tr></table></figure><p>到此为止，您配置的客户端应该可以ssh的方式直接用git账号登录服务器。(当然不安全，后面可以控制)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 在客户端用ssh测试连接远程服务器,请将域名aicoder.com换成你的ip地址或者域名</span><br><span class="line">$ ssh git@aicoder.com    </span><br><span class="line"></span><br><span class="line"># 第一次连接有警告，输入yes继续即可。如果可以连接上，那么恭喜你的ssh配置已经可以了。</span><br></pre></td></tr></table></figure><h4 id="服务器端创建测试git仓库"><a href="#服务器端创建测试git仓库" class="headerlink" title="服务器端创建测试git仓库"></a>服务器端创建测试git仓库</h4><p>进入服务器的终端。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 切换到git账号</span><br><span class="line">$ su git</span><br><span class="line"># 进入git账号的用户主目录。</span><br><span class="line"></span><br><span class="line">$ cd /home/git</span><br><span class="line"># 在用户主目录下创建 test.git仓库的文件夹</span><br><span class="line"></span><br><span class="line">$ mkdir test.git  &amp;&amp; cd test.git</span><br><span class="line"># 在test.git目录下初始化git仓库</span><br><span class="line"></span><br><span class="line">$ git init --bare</span><br><span class="line"># 输出如下内容，表示成功</span><br><span class="line">Initialized empty Git repository in /home/git/test.git/</span><br></pre></td></tr></table></figure><blockquote><p>git init —bare 是在当前目录创建一个裸仓库，也就是说没有工作区的文件，直接把git仓库隐藏的文件放在当前目录下，此目录仅用于存储仓库的历史版本等数据。</p></blockquote><p>此时，客户端就可以进行clone或者remote add此仓库了。</p><h4 id="客户端测试连接git远程仓库"><a href="#客户端测试连接git远程仓库" class="headerlink" title="客户端测试连接git远程仓库"></a>客户端测试连接git远程仓库</h4><p>客户端，可以新建一个文件夹，初始化一个仓库，然后跟远程服务器上的空仓库建立连接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 以下shell代码，纯手写没有验证，如果有错误请自行纠正。</span><br><span class="line">$ mkdir demos &amp;&amp; cd demos</span><br><span class="line">$ git init</span><br><span class="line">$ touch a.txt</span><br><span class="line">$ echo &apos;aicoder.com&apos; &gt;&gt; a.txt</span><br><span class="line"></span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m &apos;the first commit&apos;</span><br><span class="line"></span><br><span class="line"># 把当前仓库跟远程仓库添映射</span><br><span class="line">$ git remote add origin git@aicoder.com:test.git</span><br><span class="line"></span><br><span class="line"># 把当前仓库push到远程仓库。</span><br><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure><p>到此为止，我们就可以尽情的享用git私服了，但是！但是！但是！客户端可以直接ssh登录啊，这是bug，也是不安全的隐患，且看下面怎么禁用git账号的shell登录。</p><h4 id="修改Git-remote-add时使用的远程仓库"><a href="#修改Git-remote-add时使用的远程仓库" class="headerlink" title="修改Git remote add时使用的远程仓库"></a>修改Git remote add时使用的远程仓库</h4><p>方法一：</p><p>git remote rm origin<br>git remote add origin git@github.com:Liutos/foobar.git</p><p>方法二：</p><p>git remote set-url origin <url><br>把<url>替换成新的url地址。</url></url></p><p>方法三：</p><p>直接修改.git/config文件</p><h4 id="禁止客户端shell登录"><a href="#禁止客户端shell登录" class="headerlink" title="禁止客户端shell登录"></a>禁止客户端shell登录</h4><p>因为前面我们添加了客户端的ssh的公钥到远程服务器，所以客户端可以直接通过shell远程登录服务器，这不安全，也不是我们想要的。且看下面如何禁用shell登录：</p><p>第一步：<br>给 /home/git 下面创建git-shell-commands目录，并把目录的拥有者设置为git账户。可以直接用git账号登录服务器终端操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ su git</span><br><span class="line">$ mkdir /home/git/git-shell-commands</span><br></pre></td></tr></table></figure><blockquote><p>此文件夹是git-shell用到的目录，需要我们手动创建，不然报错：fatal: Interactive git shell is not enabled. hint: ~/git-shell-commands should exist and have read and execute access.</p></blockquote><p>第二步：修改/etc/passwd文件，修改:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/passwd</span><br><span class="line"></span><br><span class="line"># 可以通过 vim的正则搜索快速定位到这行，  命名模式下  :/git:x</span><br><span class="line"></span><br><span class="line"># 找到这句, 注意1000可能是别的数字</span><br><span class="line">git:x:1000:1000::/home/git:/bin/bash</span><br><span class="line"></span><br><span class="line"># 改为：</span><br><span class="line">git:x:1000:1000::/home/git:/bin/git-shell</span><br><span class="line"></span><br><span class="line"># 最好不要直接改，可以先复制一行，然后注释掉一行，修改一行，保留原始的，这就是经验！！！</span><br><span class="line"># vim快捷键： 命令模式下：yy复制行， p 粘贴  0光标到行首 $到行尾 x删除一个字符  i进入插入模式 </span><br><span class="line"># 修改完后退出保存：  esc进入命令模式， 输入：:wq!   保存退出。</span><br></pre></td></tr></table></figure><p>好了，此时我们就不用担心客户端通过shell登录，只允许使用git-shell进行管理git的仓库。</p><p>如果有其他小伙伴要连接git服务器，仅需要把他的公钥也添加到authorized_keys即可。</p><h3 id="git的自动权限管理：gitolite"><a href="#git的自动权限管理：gitolite" class="headerlink" title="git的自动权限管理：gitolite"></a>git的自动权限管理：gitolite</h3><p>如果团队大点的，我们可以用gitolite管理，而且使用很方便。</p><h4 id="gitolite的安装和配置"><a href="#gitolite的安装和配置" class="headerlink" title="gitolite的安装和配置"></a>gitolite的安装和配置</h4><p>以下配置此承接第5，如果第6步您已经操作，请注意第二步的说明。</p><p>第一步：添加gitolite依赖的perl的包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum install &apos;perl(Data::Dumper)&apos;</span><br></pre></td></tr></table></figure><p>第二步：清空服务器端配置的ssh的公钥</p><p>确保：~/.ssh/authorized_keys文件是空的，或者不存在。如果已经存在，建议你把他改名即可，比如：authorized_keys.bak</p><p>第三步：上传管理员的客户端的ssh公钥到服务器</p><p>把你管理员电脑的ssh的id_rsa.pub文件拷贝到服务器的： $HOME/YourName.pub</p><p>YourName可以自定义，最好根据不同伙伴的名字命名。</p><p>参考：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># mac客户端</span><br><span class="line">$ scp /Users/fly/.ssh/id_rsa.pub git@aicoder.com:malun.pub</span><br></pre></td></tr></table></figure><p>第四步：安装配置gitolite</p><p>用git账号登录，并执行如下命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># 切换到git账号</span><br><span class="line">$ su git</span><br><span class="line"></span><br><span class="line"># 进入git主目录</span><br><span class="line">$ cd /home/git</span><br><span class="line"></span><br><span class="line"># 下载gitolite的仓库</span><br><span class="line">$ git clone https://github.com/sitaramc/gitolite</span><br><span class="line"></span><br><span class="line"># 创建bin文件夹，必须！！！</span><br><span class="line">$ mkdir -p $HOME/bin</span><br><span class="line"></span><br><span class="line"># 用下载下来的仓库中的insall执行安装操作，指向的目录就是上一命令行创建的目录</span><br><span class="line">$ ./gitolite二进制/install -to $HOME/bin</span><br><span class="line"></span><br><span class="line"># 把上传到服务器的 管理员的公钥setup到gitolite中，注意：YourName.pub改成你自己的文件名。</span><br><span class="line">$ ~/bin/gitolite setup -pk ~/YourName.pub</span><br><span class="line"></span><br><span class="line"># 此时安装配完成后，查看git主目录</span><br><span class="line">$ ls /home/git</span><br><span class="line">drwxr-xr-x   7 git  git  4096 Apr  3 23:50 bin               # 我们创建的存放gitolite二进制</span><br><span class="line">drwxrwxr-x   6 git  git  4096 Apr  3 23:40 gitolite</span><br><span class="line">drwx------   6 git  git  4096 Apr  3 23:52 .gitolite</span><br><span class="line">-rw-------   1 git  git  7130 Apr  3 23:52 .gitolite.rc</span><br><span class="line">-rw-------   1 git  git   398 Apr  3 23:39 malun.pub         # 管理员的公钥</span><br><span class="line">drwxrw----   3 git  git  4096 Apr  3 23:40 .pki</span><br><span class="line">-rw-------   1 git  git    19 Apr  4 00:26 projects.list     # 仓库列表（gitolite自动创建）</span><br><span class="line">drwx------   5 git  git  4096 Apr  4 00:26 repositories      # 存放所有仓库文件夹</span><br><span class="line">drwx------   2 git  git  4096 Apr  4 15:50 .ssh</span><br><span class="line"></span><br><span class="line"># repositories目录下已经有了两个git仓库了。</span><br><span class="line"># .</span><br><span class="line"># |-- gitolite-admin.git    # 管理配置权限的仓库</span><br><span class="line"># `-- testing.git           # 测试仓库</span><br></pre></td></tr></table></figure><p>好了，到此位置，管理员就可以直接把默认的远程管理的仓库gitolite-admin直接clone到本地进行管理git服务了。</p><p>第五步：管理员在本地管理和配置服务器端的仓库</p><p>下载服务器端的远程管理仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 下载远程管理仓库, 请把aicoder.com换成你自己服务器的域名或者ip</span><br><span class="line">$ git clone git@aicoder.com:gitolite-admin</span><br><span class="line">$ cd gitolite-admin</span><br><span class="line"># 目录结构如下：</span><br><span class="line"># .</span><br><span class="line"># ├── conf                # 配置文件夹</span><br><span class="line"># │   └── gitolite.conf   # 配置权限的文件</span><br><span class="line"># └── keydir              # 客户端的公钥文件夹，所有伙伴的公钥要放到此目录下</span><br><span class="line">#     └── malun.pub</span><br></pre></td></tr></table></figure><h4 id="gitolite的权限配置"><a href="#gitolite的权限配置" class="headerlink" title="gitolite的权限配置"></a>gitolite的权限配置</h4><ul><li>添加其他开发的小伙伴</li></ul><p>把小伙伴的公钥发给管理员。管理员添加到gitolite-admin仓库的keydir目录下,注意文件名字格式为username.pub,username就是配置权限时的用户名。</p><ul><li>配置用户对仓库的读写权限</li></ul><p>直接修改conf文件夹下的，gitolite.conf文件。简单解释下几个用法：</p><ul><li>repo代表仓库的意思，如果新添加一个repo，代表服务端新建一个空仓库，仓库push到服务端后会自动创建。</li><li>RW 代表可读可写</li><li>@all 代表所有人。</li><li>master和 dev代表分支</li></ul><p>参考：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@admin = malun  </span><br><span class="line">@om = malun bcd  </span><br><span class="line">  </span><br><span class="line">repo gitolite-admin  </span><br><span class="line">    RW+     =   malun </span><br><span class="line">  </span><br><span class="line">repo testing  </span><br><span class="line">    RW+     =   @all  </span><br><span class="line">  </span><br><span class="line">repo om  </span><br><span class="line">    RW+     =   @admin  </span><br><span class="line">    RW+ master = @admin  </span><br><span class="line">    RW+ dev  =   @om</span><br></pre></td></tr></table></figure><ul><li>应用修改到服务器端</li></ul><p>做好配置后，由管理员把修改push到服务器端，会自动处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add conf</span><br><span class="line">$ git add keydir</span><br><span class="line">$ git commit -m &quot;added foo, gave access to alice, bob, carol&quot;</span><br><span class="line">$ git push</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;系统环境&quot;&gt;&lt;a href=&quot;#系统环境&quot; class=&quot;headerlink&quot; title=&quot;系统环境&quot;&gt;&lt;/a&gt;系统环境&lt;/h2&gt;&lt;p&gt;系统： Linux：&lt;strong&gt;CentOS 7.2 64位&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于CentOS已经内置了
      
    
    </summary>
    
      <category term="基础" scheme="http://ruanshubin.top/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Git" scheme="http://ruanshubin.top/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>gitlab搭建</title>
    <link href="http://ruanshubin.top/2019/11/01/gitlab%E6%90%AD%E5%BB%BA/"/>
    <id>http://ruanshubin.top/2019/11/01/gitlab搭建/</id>
    <published>2019-11-01T13:30:00.000Z</published>
    <updated>2019-12-25T03:11:22.347Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><ul><li>配置yum源</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/yum.repos.d/gitlab-ce.repo</span><br></pre></td></tr></table></figure><p>复制以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[gitlab-ce]</span><br><span class="line">name=gitlab-ce</span><br><span class="line">baseurl=http://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el6</span><br><span class="line">Repo_gpgcheck=0</span><br><span class="line">Enabled=1</span><br><span class="line">Gpgkey=https://packages.gitlab.com/gpg.key</span><br></pre></td></tr></table></figure><ul><li>更新本地yum缓存</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum makecache</span><br></pre></td></tr></table></figure><p><img src="/2019/11/01/gitlab搭建/1.jpg" alt=""></p><ul><li>安装GitLab社区版</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y gitlab-ce --nogpgcheck  #自动安装最新版</span><br><span class="line">sudo yum install gitlab-ce-x.x.x  #安装指定版本</span><br></pre></td></tr></table></figure><ul><li>GitLab常用命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-ctl start    # 启动所有 gitlab 组件；</span><br><span class="line">sudo gitlab-ctl stop        # 停止所有 gitlab 组件；</span><br><span class="line">sudo gitlab-ctl restart        # 重启所有 gitlab 组件；</span><br><span class="line">sudo gitlab-ctl status        # 查看服务状态；</span><br><span class="line">sudo gitlab-ctl reconfigure        # 启动服务；</span><br><span class="line">sudo vim /etc/gitlab/gitlab.rb        # 修改默认的配置文件；</span><br><span class="line">gitlab-rake gitlab:check SANITIZE=true --trace    # 检查gitlab；</span><br><span class="line">sudo gitlab-ctl tail        # 查看日志；</span><br></pre></td></tr></table></figure><h2 id="安装问题"><a href="#安装问题" class="headerlink" title="安装问题"></a>安装问题</h2><ul><li>yum安装软件时报错libmysqlclient.so.18()(64bit)</li></ul><p>环境：CentOS 7.2，使用网易yum的网络源<br>问题：<br>使用yum安装软件时报错<br>…<br>2:postfix-2.10.1-6.el7.x86_64 has missing requires of libmysqlclient.so.18()(64bit)<br>2:postfix-2.10.1-6.el7.x86_64 has missing requires of libmysqlclient.so.18(libmysqlclient_18)(64bit)<br>重点关注：libmysqlclient.so.18()(64bit)<br>解决:<br>缺少Percona-XtraDB-Cluster-shared-55-5.5.37-25.10.756.el6.x86_64.rpm这个包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># wget http://www.percona.com/redir/downloads/Percona-XtraDB-Cluster/5.5.37-25.10/RPM/rhel6/x86_64/Percona-XtraDB-Cluster-shared-55-5.5.37-25.10.756.el6.x86_64.rpm</span><br><span class="line"># rpm -ivh Percona-XtraDB-Cluster-shared-55-5.5.37-25.10.756.el6.x86_64.rpm</span><br></pre></td></tr></table></figure><ul><li>安装后访问报502</li></ul><p>解决方案为修改默认端口号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@ianly]# vim /etc/gitlab/gitlab.rb </span><br><span class="line"></span><br><span class="line">修改两个冲突端口号</span><br><span class="line">external_url &apos;http://ip:8899&apos;</span><br><span class="line">unicorn[&apos;port&apos;] = 8088</span><br><span class="line"></span><br><span class="line"># 启动GitLab</span><br><span class="line">[root@ianly]# gitlab-ctl reconfigure</span><br><span class="line">[root@ianly]# gitlab-ctl restart</span><br><span class="line"></span><br><span class="line"># 访问http://ip:8899</span><br></pre></td></tr></table></figure><ul><li>忘记root密码</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@ruanshubin gitlab]# gitlab-rails console production</span><br><span class="line"></span><br><span class="line">irb(main):01:0&gt; user = User.where(id:1).first</span><br><span class="line">irb(main):02:0&gt; user.password=&apos;Administrator&apos;</span><br><span class="line">irb(main):03:0&gt; user.save!</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装步骤&quot;&gt;&lt;a href=&quot;#安装步骤&quot; class=&quot;headerlink&quot; title=&quot;安装步骤&quot;&gt;&lt;/a&gt;安装步骤&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;配置yum源&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table
      
    
    </summary>
    
      <category term="基础" scheme="http://ruanshubin.top/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Git" scheme="http://ruanshubin.top/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Springboot自定义Starter</title>
    <link href="http://ruanshubin.top/2019/10/31/Springboot%E8%87%AA%E5%AE%9A%E4%B9%89Starter/"/>
    <id>http://ruanshubin.top/2019/10/31/Springboot自定义Starter/</id>
    <published>2019-10-31T13:30:00.000Z</published>
    <updated>2019-12-25T03:08:24.097Z</updated>
    
    <content type="html"><![CDATA[<p>在springboot中，使用的最多的就是starter。starter可以理解为一个可拔插式的插件，例如，你想使用jdbc插件，那么可以使用spring-boot-starter-jdbc；如果想使用mongodb，可以使用spring-boot-starter-data-mongodb。 </p><p>下面介绍如何自定义Starter。</p><h2 id="自定义Starter"><a href="#自定义Starter" class="headerlink" title="自定义Starter"></a>自定义Starter</h2><h3 id="创建maven工程"><a href="#创建maven工程" class="headerlink" title="创建maven工程"></a>创建maven工程</h3><ul><li>命名规范</li></ul><p>注意artifactId的命名规则，Spring官方Starter通常命名为spring-boot-starter-{name}如 spring-boot-starter-web， Spring官方建议非官方Starter命名应遵循{name}-spring-boot-starter的格式, 如mybatis-spring-boot-starter。这里创建的项目的artifactId为helloworld-spring-boot-starter。</p><ul><li>引入必要依赖</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;</span><br><span class="line">&lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><h3 id="XxxProperties"><a href="#XxxProperties" class="headerlink" title="XxxProperties"></a>XxxProperties</h3><p>在使用Spring官方的Starter时通常可以在application.properties中来配置参数覆盖掉默认的值，例如在使用redis时一般就会有对应的RedisProperties</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@ConfigurationProperties(prefix = &quot;spring.redis&quot;)</span><br><span class="line">public class RedisProperties &#123;</span><br><span class="line">    private int database = 0;</span><br><span class="line">    private String url;</span><br><span class="line">    private String host = &quot;localhost&quot;;</span><br><span class="line">    private String password;</span><br><span class="line">    private int port = 6379;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来模仿来定义自己的Properties类:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@ConfigurationProperties(prefix = &quot;spring.person&quot;)</span><br><span class="line">public class PersonProperties &#123;</span><br><span class="line">    // 姓名</span><br><span class="line">    private String name;</span><br><span class="line">    // 年龄</span><br><span class="line">    private int age;</span><br><span class="line">    // 性别</span><br><span class="line">    private String sex = &quot;M&quot;;</span><br><span class="line"></span><br><span class="line">    // Getter &amp; Setter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="核心服务类"><a href="#核心服务类" class="headerlink" title="核心服务类"></a>核心服务类</h3><p>每个starter都有自己的功能，例如在spring-boot-starter-jdbc中最重要的类时JdbcTemplate，每个starter中的核心业务类明白都不同，也没什么规律（像spring-boot-starter-data-xxx的命名是比较有规律的），这里使用PersonService来定义helloworld-spring-boot-starter的功能，这里通过一个sayHello来模拟一个功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class PersonService &#123;</span><br><span class="line">    private PersonProperties properties;</span><br><span class="line"></span><br><span class="line">    public PersonService() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public PersonService(PersonProperties properties) &#123;</span><br><span class="line">        this.properties = properties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void sayHello()&#123;</span><br><span class="line">        System.out.println(&quot;大家好，我叫：&quot; + properties.getName() + &quot;,今年&quot; + properties.getAge() + &quot;岁&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自动配置类"><a href="#自动配置类" class="headerlink" title="自动配置类"></a>自动配置类</h3><p>一般每个starter都至少会有一个自动配置类，一般命名规则使用XxxAutoConfiguration, 例如RedisAutoConfiguration</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ConditionalOnClass(&#123; JedisConnection.class, RedisOperations.class, Jedis.class &#125;)</span><br><span class="line">@EnableConfigurationProperties(RedisProperties.class)</span><br><span class="line">public class RedisAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    @Configuration</span><br><span class="line">    @ConditionalOnClass(GenericObjectPool.class)</span><br><span class="line">    protected static class RedisConnectionConfiguration &#123;</span><br><span class="line">        private final RedisProperties properties;</span><br><span class="line"></span><br><span class="line">        @Bean</span><br><span class="line">        @ConditionalOnMissingBean(RedisConnectionFactory.class)</span><br><span class="line">        public JedisConnectionFactory redisConnectionFactory()</span><br><span class="line">                throws UnknownHostException &#123;</span><br><span class="line">            return applyProperties(createJedisConnectionFactory());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;       </span><br><span class="line"></span><br><span class="line">    @Configuration</span><br><span class="line">    protected static class RedisConfiguration &#123;</span><br><span class="line">        @Bean</span><br><span class="line">        @ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)</span><br><span class="line">        public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory)</span><br><span class="line">                        throws UnknownHostException &#123;</span><br><span class="line">            RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;Object, Object&gt;();</span><br><span class="line">            template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">            return template;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们定义自己的自动配置PersonServiceAutoConfiguration，并将核心功能类PersonService放入到Spring Context容器中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableConfigurationProperties(PersonProperties.class)</span><br><span class="line">@ConditionalOnClass(PersonService.class)</span><br><span class="line">@ConditionalOnProperty(prefix = &quot;spring.person&quot;, value = &quot;enabled&quot;, matchIfMissing = true)</span><br><span class="line">public class PersonServiceAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private PersonProperties properties;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnMissingBean(PersonService.class)  // 当容器中没有指定Bean的情况下，自动配置PersonService类</span><br><span class="line">    public PersonService personService()&#123;</span><br><span class="line">        PersonService personService = new PersonService(properties);</span><br><span class="line">        return personService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>@ConditionalOnClass：当类路径classpath下有指定的类的情况下进行自动配置</li><li>@ConditionalOnMissingBean:当容器(Spring Context)中没有指定Bean的情况下进行自动配置</li><li>@ConditionalOnProperty(prefix = “example.service”, value = “enabled”, matchIfMissing = true)，当配置文件中example.service.enabled=true时进行自动配置，如果没有设置此值就默认使用matchIfMissing对应的值</li><li>@ConditionalOnMissingBean，当Spring Context中不存在该Bean时。</li><li>@ConditionalOnBean:当容器(Spring Context)中有指定的Bean的条件下</li><li>@ConditionalOnMissingClass:当类路径下没有指定的类的条件下</li><li>@ConditionalOnExpression:基于SpEL表达式作为判断条件</li><li>@ConditionalOnJava:基于JVM版本作为判断条件</li><li>@ConditionalOnJndi:在JNDI存在的条件下查找指定的位置</li><li>@ConditionalOnNotWebApplication:当前项目不是Web项目的条件下</li><li>@ConditionalOnWebApplication:当前项目是Web项目的条件下</li><li>@ConditionalOnResource:类路径下是否有指定的资源</li><li>@ConditionalOnSingleCandidate:当指定的Bean在容器中只有一个，或者在有多个Bean的情况下，用来指定首选的Bean</li></ul><h3 id="src-main-resources-META-INF-spring-factories"><a href="#src-main-resources-META-INF-spring-factories" class="headerlink" title="src/main/resources/META-INF/spring.factories"></a>src/main/resources/META-INF/spring.factories</h3><p>注意：META-INF是自己手动创建的目录，spring.factories也是手动创建的文件,在该文件中配置自己的自动配置类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.ruanshubin.config.PersonServiceAutoConfiguration</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul><li>打包mvn clean install</li><li>创建一个Spring Boot工程并引入依赖</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.ruanshubin.springboot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;helloworld-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><ul><li>配置application.properties</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.person.name=mengday</span><br><span class="line">spring.person.age=28</span><br></pre></td></tr></table></figure><ul><li>test</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class MystarterApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private PersonService personService;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testHelloWorld() &#123;</span><br><span class="line">        personService.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从使用者的角度来看，自己并没有将PersonService放入到Spring容器中，就直接来使用了，进行注入进来了。</p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>总结下Starter的工作原理：</p><ul><li>Spring Boot在启动时扫描项目所依赖的JAR包，寻找包含spring.factories文件的JAR包，</li><li>然后读取spring.factories文件获取配置的自动配置类AutoConfiguration，</li><li>然后将自动配置类下满足条件(@ConditionalOnXxx)的@Bean放入到Spring容器中(Spring Context)</li><li>这样使用者就可以直接用来注入，因为该类已经在容器中了</li></ul><p>@ConfigurationProperties: 注解主要用来把properties配置文件转化为对应的XxxProperties来使用的,并不会把该类放入到IOC容器中，如果想放入到容器中可以在XxxProperties上使用@Component来标注，也可以使用@EnableConfigurationProperties(XxxProperties.class)统一配置到Application上来，这种方式可以在Application上来统一开启指定的属性，这样也没必要在每个XxxProperties上使用@Component</p><p>@EnableConfigurationProperties(XxxProperties.class) 注解的作用是@ConfigurationProperties注解生效。如果只配置@ConfigurationProperties注解，在IOC容器中是获取不到properties配置文件转化的bean的</p><p>如果在每个Properties上都使用@Component来标注，那么在XxxApplication上也不需要使用@EnableConfigurationProperties({XxxProperties.class})来标注了，同样也可以在spring上下文容器中也能获取到XxxProperties对应的bean</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在springboot中，使用的最多的就是starter。starter可以理解为一个可拔插式的插件，例如，你想使用jdbc插件，那么可以使用spring-boot-starter-jdbc；如果想使用mongodb，可以使用spring-boot-starter-data
      
    
    </summary>
    
      <category term="Springboot" scheme="http://ruanshubin.top/categories/Springboot/"/>
    
    
      <category term="Java" scheme="http://ruanshubin.top/tags/Java/"/>
    
      <category term="Springboot" scheme="http://ruanshubin.top/tags/Springboot/"/>
    
  </entry>
  
  <entry>
    <title>ELK系统研究</title>
    <link href="http://ruanshubin.top/2019/10/30/ELK%E7%B3%BB%E7%BB%9F%E7%A0%94%E7%A9%B6/"/>
    <id>http://ruanshubin.top/2019/10/30/ELK系统研究/</id>
    <published>2019-10-30T13:30:00.000Z</published>
    <updated>2019-12-25T03:05:34.856Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><h3 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h3><ul><li>业务发展越来越庞大，服务器越来越多;</li><li>各种访问日志、应用日志、错误日志量越来越多，导致运维人员无法很好的去管理日志;</li><li>开发人员排查问题，需要到服务器上查日志，不方便;</li><li>运营人员需要一些数据，需要我们运维到服务器上分析日志。</li></ul><h3 id="为什么要用到ELK"><a href="#为什么要用到ELK" class="headerlink" title="为什么要用到ELK"></a>为什么要用到ELK</h3><p>一般我们需要进行日志分析场景：直接在日志文件中grep、awk 就可以获得自己想要的信息。但在规模较大也就是日志量多而复杂的场景中，此方法效率低下，面临问题包括日志量太大如何归档、文本搜索太慢怎么办、如何多维度查询。需要集中化的日志管理，所有服务器上的日志收集汇总。常见解决思路是建立集中式日志收集系统，将所有节点上的日志统一收集，管理，访问。</p><p>大型系统通常都是一个分布式部署的架构，不同的服务模块部署在不同的服务器上，问题出现时，大部分情况需要根据问题暴露的关键信息，定位到具体的服务器和服务模块，构建一套集中式日志系统，可以提高定位问题的效率。</p><p>一个完整的集中式日志系统，需要包含以下几个主要特点：</p><ul><li>收集－能够采集多种来源的日志数据;</li><li>传输－能够稳定的把日志数据传输到中央系统;</li><li>存储－如何存储日志数据;</li><li>分析－可以支持UI分析;</li><li>警告－能够提供错误报告，监控机制。</li></ul><p>而ELK则提供了一整套解决方案，并且都是开源软件，之间互相配合使用，完美衔接，高效的满足了很多场合的应用。是目前主流的一种日志系统。</p><h3 id="ELK简介"><a href="#ELK简介" class="headerlink" title="ELK简介"></a>ELK简介</h3><p>ELK是三个开源软件的缩写，分别为：Elasticsearch 、 Logstash以及Kibana , 它们都是开源软件。不过现在还新增了一个Beats，它是一个轻量级的日志收集处理工具(Agent)，Beats占用资源少，适合于在各个服务器上搜集日志后传输给Logstash，官方也推荐此工具，目前由于原本的ELK Stack成员中加入了Beats工具所以已改名为Elastic Stack。</p><p>Elastic Stack包含：</p><ul><li><p>Elasticsearch是个开源分布式搜索引擎，提供搜集、分析、存储数据三大功能。它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，restful风格接口，多数据源，自动搜索负载等。详细可参考Elasticsearch权威指南;</p></li><li><p>Logstash主要是用来日志的搜集、分析、过滤日志的工具，支持大量的数据获取方式。一般工作方式为c/s架构，client端安装在需要收集日志的主机上，server端负责将收到的各节点日志进行过滤、修改等操作在一并发往elasticsearch上去;</p></li><li><p>Kibana也是一个开源和免费的工具，Kibana可以为Logstash和ElasticSearch 提供的日志分析友好的Web界面，可以帮助汇总、分析和搜索重要数据日志;</p></li><li><p>Beats在这里是一个轻量级日志采集器，其实Beats家族有6个成员，早期的ELK架构中使用Logstash收集、解析日志，但是Logstash对内存、cpu、io等资源消耗比较高。相比Logstash，Beats所占系统的CPU和内存几乎可以忽略不计。</p></li></ul><p>ELK Stack （5.0版本之后）—&gt; Elastic Stack == （ELK Stack + Beats）。目前Beats包含六种工具：</p><ul><li>Packetbeat： 网络数据（收集网络流量数据）;</li><li>Metricbeat： 指标 （收集系统、进程和文件系统级别的 CPU 和内存使用情况等数据）;</li><li>Filebeat： 日志文件（收集文件数据）;</li><li>Winlogbeat： windows事件日志（收集 Windows 事件日志数据）;</li><li>Auditbeat：审计数据 （收集审计日志）;</li><li>Heartbeat：运行时间监控 （收集系统运行时的数据）。</li></ul><h3 id="ELK部署"><a href="#ELK部署" class="headerlink" title="ELK部署"></a>ELK部署</h3><p>下载：<a href="https://www.elastic.co/cn/downloads/" target="_blank" rel="noopener">https://www.elastic.co/cn/downloads/</a></p><p><img src="/2019/10/30/ELK系统研究/1.jpg" alt=""></p><h4 id="Elasticsearch安装"><a href="#Elasticsearch安装" class="headerlink" title="Elasticsearch安装"></a>Elasticsearch安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"># 解压es的安装包</span><br><span class="line">[root@sumo elasticsearch-6.6.2]# tar -zvxf elasticsearch-6.6.2-linux-x86_64.tar.gz </span><br><span class="line"></span><br><span class="line">[root@sumo elasticsearch-6.6.2]# cd elasticsearch-6.6.2/</span><br><span class="line">[root@sumo elasticsearch-6.6.2]# cd config/</span><br><span class="line">[root@sumo config]# vim elasticsearch.yml</span><br><span class="line"></span><br><span class="line"># ======================== Elasticsearch Configuration =========================</span><br><span class="line">#</span><br><span class="line"># NOTE: Elasticsearch comes with reasonable defaults for most settings.</span><br><span class="line">#       Before you set out to tweak and tune the configuration, make sure you</span><br><span class="line">#       understand what are you trying to accomplish and the consequences.</span><br><span class="line">#</span><br><span class="line"># The primary way of configuring a node is via this file. This template lists</span><br><span class="line"># the most important settings you may want to configure for a production cluster.</span><br><span class="line">#</span><br><span class="line"># Please consult the documentation for further information on configuration options:</span><br><span class="line"># https://www.elastic.co/guide/en/elasticsearch/reference/index.html</span><br><span class="line">#</span><br><span class="line"># ---------------------------------- Cluster -----------------------------------</span><br><span class="line">#</span><br><span class="line"># Use a descriptive name for your cluster:</span><br><span class="line">#</span><br><span class="line">cluster.name: ELK</span><br><span class="line">#</span><br><span class="line"># ------------------------------------ Node ------------------------------------</span><br><span class="line">#</span><br><span class="line"># Use a descriptive name for the node:</span><br><span class="line">#</span><br><span class="line">node.name: node-1</span><br><span class="line">#</span><br><span class="line"># Add custom attributes to the node:</span><br><span class="line">#</span><br><span class="line">#node.attr.rack: r1</span><br><span class="line">#</span><br><span class="line"># ----------------------------------- Paths ------------------------------------</span><br><span class="line">#</span><br><span class="line"># Path to directory where to store the data (separate multiple locations by comma):</span><br><span class="line">#</span><br><span class="line">#path.data: /path/to/data</span><br><span class="line">#</span><br><span class="line"># Path to log files:</span><br><span class="line">#</span><br><span class="line">#path.logs: /path/to/logs</span><br><span class="line">#</span><br><span class="line"># ----------------------------------- Memory -----------------------------------</span><br><span class="line">#</span><br><span class="line"># Lock the memory on startup:</span><br><span class="line">#</span><br><span class="line">#bootstrap.memory_lock: true</span><br><span class="line">#</span><br><span class="line"># Make sure that the heap size is set to about half the memory available</span><br><span class="line"># on the system and that the owner of the process is allowed to use this</span><br><span class="line"># limit.</span><br><span class="line">#</span><br><span class="line"># Elasticsearch performs poorly when the system is swapping the memory.</span><br><span class="line">#</span><br><span class="line"># ---------------------------------- Network -----------------------------------</span><br><span class="line">#</span><br><span class="line"># Set the bind address to a specific IP (IPv4 or IPv6):</span><br><span class="line">#</span><br><span class="line">network.host: 10.194.224.83</span><br><span class="line">#</span><br><span class="line"># Set a custom port for HTTP:</span><br><span class="line">#</span><br><span class="line">http.port: 9200</span><br><span class="line">#</span><br><span class="line"># For more information, consult the network module documentation.</span><br><span class="line">#</span><br><span class="line"># --------------------------------- Discovery ----------------------------------</span><br><span class="line">#</span><br><span class="line"># Pass an initial list of hosts to perform discovery when this node is started:</span><br><span class="line"># The default list of hosts is [&quot;127.0.0.1&quot;, &quot;[::1]&quot;]</span><br><span class="line">#</span><br><span class="line">#discovery.seed_hosts: [&quot;host1&quot;, &quot;host2&quot;]</span><br><span class="line">#</span><br><span class="line"># Bootstrap the cluster using an initial set of master-eligible nodes:</span><br><span class="line">#</span><br><span class="line">#cluster.initial_master_nodes: [&quot;node-1&quot;, &quot;node-2&quot;]</span><br><span class="line">cluster.initial_master_nodes: [&quot;node-1&quot;]</span><br><span class="line">#</span><br><span class="line"># For more information, consult the discovery and cluster formation module documentation.</span><br><span class="line">#</span><br><span class="line"># ---------------------------------- Gateway -----------------------------------</span><br><span class="line">#</span><br><span class="line"># Block initial recovery after a full cluster restart until N nodes are started:</span><br><span class="line">#</span><br><span class="line">#gateway.recover_after_nodes: 3</span><br><span class="line">#</span><br><span class="line"># For more information, consult the gateway module documentation.</span><br><span class="line">#</span><br><span class="line"># ---------------------------------- Various -----------------------------------</span><br><span class="line">#</span><br><span class="line"># Require explicit names when deleting indices:</span><br><span class="line">#</span><br><span class="line">#action.destructive_requires_name: true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 创建es账户</span><br><span class="line">[root@sumo config]# groupadd elsearch</span><br><span class="line">[root@sumo config]# useradd elsearch -g elsearch -p elsearch</span><br><span class="line">[root@sumo config]# chown -R elsearch:elsearch  es根目录</span><br><span class="line"></span><br><span class="line"># 切换到elsearch用户</span><br><span class="line">[root@sumo config]# su elsearch</span><br><span class="line">[elsearch@sumo config]$ </span><br><span class="line"></span><br><span class="line"># 启动es</span><br><span class="line">[elsearch@sumo config]$ /usr/software/es/elasticsearch-6.6.2/bin/elasticsearch -d</span><br><span class="line"></span><br><span class="line"># 加了-d是后台启动，不加是前台启动，第一次不建议后台启动，前台启动可以直观的看到日志信息</span><br></pre></td></tr></table></figure><p>前台启动后，报以下3个错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[1]: max file descriptors [4096] for elasticsearch process is too low, increase to at least [65535]</span><br><span class="line">[2]: max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]</span><br><span class="line">[3]: the default discovery settings are unsuitable for production use; at least one of [discovery.seed_hosts, discovery.seed_providers, cluster.initial_master_nodes] must be configured</span><br></pre></td></tr></table></figure><ul><li>Elasticsearch：max file descriptors [4096] for elasticsearch process is too low, increase to at least [65536]</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@sumo config]# vim /etc/security/limits.conf </span><br><span class="line">增加以下配置：</span><br><span class="line">*               soft    nofile          65536</span><br><span class="line">*               hard    nofile          65536</span><br><span class="line">重新连接服务器，查看配置是否生效：</span><br><span class="line">ulimit -Su</span><br><span class="line">ulimit -Hu</span><br></pre></td></tr></table></figure><ul><li>Elasticsearch：max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]</li></ul><p>elasticsearch用户拥有的内存权限太小，至少需要262144；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@sumo ~]# vim /etc/sysctl.conf</span><br><span class="line"># 添加以下配置：</span><br><span class="line">vm.max_map_count=262144</span><br><span class="line"></span><br><span class="line"># 使配置生效：</span><br><span class="line">[root@sumo ~]# sysctl -p</span><br><span class="line"></span><br><span class="line"># 查看</span><br><span class="line">[root@sumo ~]# sysctl -a|grep vm.max_map_count</span><br></pre></td></tr></table></figure><ul><li>[1]: the default discovery settings are unsuitable for production use; at least one of [discovery.seed_hosts, discovery.seed_providers, cluster.initial_master_nodes] must be configured</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[elsearch@sumo config]$ vim /usr/software/es/elasticsearch-6.6.2/config/elasticsearch.yml </span><br><span class="line"></span><br><span class="line">将 #cluster.initial_master_nodes: [&quot;node-1&quot;, &quot;node-2&quot;] 修改为 cluster.initial_master_nodes: [&quot;node-1&quot;]</span><br></pre></td></tr></table></figure><p>浏览器访问: <a href="http://xxx.xxx.xxx.xxx:9200/" target="_blank" rel="noopener">http://xxx.xxx.xxx.xxx:9200/</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot; : &quot;node-1&quot;,</span><br><span class="line">  &quot;cluster_name&quot; : &quot;ELK&quot;,</span><br><span class="line">  &quot;cluster_uuid&quot; : &quot;1l1qU4KPRqaafaPTrZAy-w&quot;,</span><br><span class="line">  &quot;version&quot; : &#123;</span><br><span class="line">    &quot;number&quot; : &quot;6.6.2&quot;,</span><br><span class="line">    &quot;build_flavor&quot; : &quot;default&quot;,</span><br><span class="line">    &quot;build_type&quot; : &quot;tar&quot;,</span><br><span class="line">    &quot;build_hash&quot; : &quot;e4efcb5&quot;,</span><br><span class="line">    &quot;build_date&quot; : &quot;2019-04-29T12:56:03.145736Z&quot;,</span><br><span class="line">    &quot;build_snapshot&quot; : false,</span><br><span class="line">    &quot;lucene_version&quot; : &quot;8.0.0&quot;,</span><br><span class="line">    &quot;minimum_wire_compatibility_version&quot; : &quot;6.7.0&quot;,</span><br><span class="line">    &quot;minimum_index_compatibility_version&quot; : &quot;6.0.0-beta1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;tagline&quot; : &quot;You Know, for Search&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他可能的报错及解决方案:</p><ul><li>Elasticsearch：Failed to obtain node lock</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 节点被已有的es进程占用，需要杀掉重启</span><br><span class="line">ps aux | grep &apos;java&apos;</span><br><span class="line">kill -9 &lt;属于es的PID&gt;</span><br></pre></td></tr></table></figure><ul><li>elk的3个组件均不能通过ip:port的形式访问</li></ul><p>将各自组件的yml配置文件中的host修改为0.0.0.0。</p><h4 id="Cerebro安装"><a href="#Cerebro安装" class="headerlink" title="Cerebro安装"></a>Cerebro安装</h4><p>Cerebro是一款Elasticsearch监控工具。</p><p><a href="https://github.com/lmenezes/cerebro" target="_blank" rel="noopener">https://github.com/lmenezes/cerebro</a></p><p><img src="/2019/10/30/ELK系统研究/2.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@sumo cerebro]# tar -zvxf cerebro-0.8.3.tgz </span><br><span class="line">[root@sumo cerebro]# cd /usr/software/cerebro/cerebro-0.8.3/conf/</span><br><span class="line">[root@sumo conf]# vim application.conf </span><br><span class="line"></span><br><span class="line">hosts = [</span><br><span class="line">  #&#123;</span><br><span class="line">  #  host = &quot;http://localhost:9200&quot;</span><br><span class="line">  #  name = &quot;Some Cluster&quot;</span><br><span class="line">  #&#125;,</span><br><span class="line">  # Example of host with authentication</span><br><span class="line">  #&#123;</span><br><span class="line">  #  host = &quot;http://some-authenticated-host:9200&quot;</span><br><span class="line">  #  name = &quot;Secured Cluster&quot;</span><br><span class="line">  #  auth = &#123;</span><br><span class="line">  #    username = &quot;username&quot;</span><br><span class="line">  #    password = &quot;secret-password&quot;</span><br><span class="line">  #  &#125;</span><br><span class="line">  #&#125;</span><br><span class="line">  &#123;</span><br><span class="line">    host = &quot;http://xxx.xxx.xxx.xxx:9200&quot;</span><br><span class="line">    name = &quot;elk&quot;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>启动Cerebro:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@sumo bin]# nohup ./cerebro -Dhttp.port=1234 -Dhttp.address=10.194.224.112 &gt; /dev/null &amp;</span><br></pre></td></tr></table></figure><p><img src="/2019/10/30/ELK系统研究/3.jpg" alt=""></p><p><img src="/2019/10/30/ELK系统研究/4.jpg" alt=""></p><h4 id="Kibana安装"><a href="#Kibana安装" class="headerlink" title="Kibana安装"></a>Kibana安装</h4><p><img src="/2019/10/30/ELK系统研究/5.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@sumo kibana]# tar -zvxf kibana-6.6.2-linux-x86_64.tar.gz </span><br><span class="line">[root@sumo kibana]# cd kibana-6.6.2-linux-x86_64/config/</span><br><span class="line">[root@sumo config]# vim kibana.yml </span><br><span class="line"></span><br><span class="line">server.port: 5602</span><br><span class="line">server.host: &quot;0.0.0.0&quot;</span><br><span class="line">elasticsearch.hosts: [&quot;http://10.194.224.83:9200&quot;]</span><br><span class="line"></span><br><span class="line">[root@sumo config]# nohup ../kibana &gt; /dev/null &amp;</span><br><span class="line"></span><br><span class="line"># 如何关闭kibana</span><br><span class="line"># 查询kibana的PID</span><br><span class="line">ps -ef | grep node </span><br><span class="line">netstat -tunlp|grep 5602</span><br><span class="line"></span><br><span class="line">root        777      1  0  2018 ?        00:00:00 /usr/sbin/mcelog --ignorenodev --daemon --syslog</span><br><span class="line">root      11323      1  1 May21 ?        00:17:06 ./../node/bin/node --no-warnings --max-http-header-size=65536 ./../src/cli</span><br><span class="line">root      76232  63850  0 11:48 pts/1    00:00:00 grep --color=auto node</span><br><span class="line"></span><br><span class="line">kill -9 11323</span><br></pre></td></tr></table></figure><h4 id="Logstash安装"><a href="#Logstash安装" class="headerlink" title="Logstash安装"></a>Logstash安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[root@sumo logstash]# tar -zvxf logstash-6.6.2.tar.gz </span><br><span class="line">[root@sumo logstash]# cd /usr/software/logstash/logstash-6.6.2/config</span><br><span class="line">[root@sumo config]# vim std_to_es.conf </span><br><span class="line"></span><br><span class="line"># 安装logstash-codec-json_lines插件</span><br><span class="line"></span><br><span class="line">[root@sumo config]# ../bin/logstash-plugin install logstash-codec-json_lines</span><br><span class="line"></span><br><span class="line">input &#123;</span><br><span class="line">    tcp &#123;</span><br><span class="line">        host =&gt; &quot;xxx.xxx.xxx.xxx&quot;</span><br><span class="line">        port =&gt; 4560</span><br><span class="line">        mode =&gt; &quot;server&quot;</span><br><span class="line">        tags =&gt; [&quot;tags&quot;]</span><br><span class="line">        codec =&gt; json_lines</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output&#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">     action =&gt; &quot;index&quot;</span><br><span class="line">     hosts =&gt; [&quot;xxx.xxx.xxx.xxx:9200&quot;]</span><br><span class="line">     index =&gt; &quot;%&#123;[appname]&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line">  stdout &#123; codec =&gt; rubydebug &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 启动</span><br><span class="line">[root@sumo config]# nohup ../bin/logstash -f ./std_to_es.conf &gt; /dev/null &amp;</span><br></pre></td></tr></table></figure><h4 id="filebeat使用"><a href="#filebeat使用" class="headerlink" title="filebeat使用"></a>filebeat使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@sumo filebeat-6.6.2-linux-x86_64]# vim filebeat.yml</span><br><span class="line"></span><br><span class="line">filebeat.inputs:</span><br><span class="line">- type: log</span><br><span class="line">  paths:</span><br><span class="line">    - /usr/software/data/filebeat-dataset.log</span><br><span class="line">setup.template.name: &quot;tcd&quot;</span><br><span class="line">setup.template.pattern: &quot;tcd-*&quot;</span><br><span class="line">output.elasticsearch:</span><br><span class="line">  hosts: [&quot;xxx.xxx.xxx.xxx:9200&quot;]</span><br><span class="line">  index: &quot;tcd-%&#123;+yyyy.MM.dd&#125;&quot;</span><br><span class="line"></span><br><span class="line">[root@sumo filebeat-6.6.2-linux-x86_64]# ./filebeat -e -c filebeat.yml -d &quot;publish&quot;</span><br></pre></td></tr></table></figure><ul><li>filebeat监控多个文件,并且写入elasticsearch的不同index的中</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">filebeat.inputs:</span><br><span class="line">- type: log</span><br><span class="line">  paths:</span><br><span class="line">    - /usr/software/data/tcd-as.log</span><br><span class="line">  fields:</span><br><span class="line">    index: &apos;tcd-as&apos;</span><br><span class="line">- type: log</span><br><span class="line">  paths:</span><br><span class="line">    - /usr/software/data/tcd-dm.log</span><br><span class="line">  fields:</span><br><span class="line">    index: &apos;tcd-dm&apos;</span><br><span class="line">output.elasticsearch:</span><br><span class="line">  hosts: [&quot;xxx.xxx.xxx.xxx:9200&quot;]</span><br><span class="line">  indices:</span><br><span class="line">    - index: &quot;tcd-as&quot;</span><br><span class="line">      when:</span><br><span class="line">        contains:</span><br><span class="line">          fields.index: &quot;tcd-as&quot;</span><br><span class="line">    - index: &quot;tcd-dm&quot;</span><br><span class="line">      when:</span><br><span class="line">        contains:</span><br><span class="line">          fields.index: &quot;tcd-dm&quot;</span><br></pre></td></tr></table></figure><p>logback.xml:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;appender name=&quot;LOGSTASH&quot; class=&quot;net.logstash.logback.appender.LogstashTcpSocketAppender&quot;&gt;</span><br><span class="line">        &lt;destination&gt;xxx.xxx.xxx.xxx:4560&lt;/destination&gt;</span><br><span class="line">        &lt;encoder charset=&quot;UTF-8&quot; class=&quot;net.logstash.logback.encoder.LogstashEncoder&quot;&gt;</span><br><span class="line">  &lt;!-- 注意：index的名称必须小写，且只允许下划线，中划线会导致消息进入不到es里面 --&gt;</span><br><span class="line">           &lt;customFields&gt;&#123;&quot;appname&quot;:&quot;applog&quot;&#125;&lt;/customFields&gt;</span><br><span class="line">        &lt;/encoder&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line"></span><br><span class="line">    &lt;include resource=&quot;org/springframework/boot/logging/logback/base.xml&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;root level=&quot;INFO&quot;&gt;</span><br><span class="line">        &lt;appender-ref ref=&quot;LOGSTASH&quot; /&gt;</span><br><span class="line">        &lt;appender-ref ref=&quot;CONSOLE&quot; /&gt;</span><br><span class="line">    &lt;/root&gt;</span><br><span class="line"></span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;h3 id=&quot;需求背景&quot;&gt;&lt;a href=&quot;#需求背景&quot; class=&quot;headerlink&quot; title=&quot;需求背景&quot;&gt;&lt;/a&gt;需求背景&lt;/h
      
    
    </summary>
    
      <category term="基础" scheme="http://ruanshubin.top/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="基础" scheme="http://ruanshubin.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="ELK" scheme="http://ruanshubin.top/tags/ELK/"/>
    
  </entry>
  
  <entry>
    <title>Linux服务器配置代理上网</title>
    <link href="http://ruanshubin.top/2019/10/29/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86%E4%B8%8A%E7%BD%91/"/>
    <id>http://ruanshubin.top/2019/10/29/Linux服务器配置代理上网/</id>
    <published>2019-10-29T13:30:00.000Z</published>
    <updated>2019-12-25T03:01:04.613Z</updated>
    
    <content type="html"><![CDATA[<ul><li>代理服务器选择了CCproxy，下载并安装CCProxy，配置所要代理的协议，并选择能够联外网的网卡ip；</li></ul><p><img src="/2019/10/29/Linux服务器配置代理上网/Linux服务器配置代理上网_files/1.jpg" alt=""></p><ul><li>账号管理根据个人需要进行配置，我这边选择的是允许所有（建议最好为虚拟机配置账号，方便以后调试和监控）。</li></ul><p><img src="/2019/10/29/Linux服务器配置代理上网/Linux服务器配置代理上网_files/2.jpg" alt=""></p><ul><li>在CentOS中配置全局代理</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line">export http_proxy=&quot;http://202.169.100.196:8089&quot;</span><br><span class="line">export https_proxy=&quot;http://202.169.100.196:8089&quot;</span><br><span class="line">export ftp_proxy=$http_proxy</span><br><span class="line"></span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><ul><li>配置yum代理</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/yum.conf</span><br><span class="line"></span><br><span class="line">proxy=http://202.169.100.196:8089</span><br></pre></td></tr></table></figure><ul><li>配置wget代理</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/wgetrc</span><br><span class="line"></span><br><span class="line">http_proxy = http://202.169.100.196:8089</span><br><span class="line">ftp_proxy = http://202.169.100.196:8089</span><br><span class="line">https_proxy = http://202.169.100.196:8089</span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -k https://www.baidu.com</span><br><span class="line">wget https://www.baidu.com</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;代理服务器选择了CCproxy，下载并安装CCProxy，配置所要代理的协议，并选择能够联外网的网卡ip；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/2019/10/29/Linux服务器配置代理上网/Linux服务器配置代理上网_files/1.jpg
      
    
    </summary>
    
      <category term="Linux" scheme="http://ruanshubin.top/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://ruanshubin.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Java的线程池</title>
    <link href="http://ruanshubin.top/2019/10/28/Java%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://ruanshubin.top/2019/10/28/Java的线程池/</id>
    <published>2019-10-28T13:30:00.000Z</published>
    <updated>2019-12-25T02:54:40.677Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建线程的方法"><a href="#创建线程的方法" class="headerlink" title="创建线程的方法"></a>创建线程的方法</h2><p>常见的创建线程的方法，主要有以下3种:</p><ul><li>继承Thread类;</li><li>实现Runnable接口;</li><li>实现Callable接口.</li></ul><p>需要有返回值时，可以使用Callable创建多线程，使用FutureTask的get()来取得该返回值。</p><p>上述3种方法创建的线程在运行结束后均会被虚拟机销毁，如果线程数量多的话，频繁的创建和销毁线程会大大浪费时间和效率，更重要的是浪费内存，因为正常来说，线程执行完毕后死亡，线程对象变成垃圾。</p><p>是否有1种方法能让线程运行完不立即销毁，而是让线程重复使用，继续执行其他的任务呢?</p><p>线程池可解决上述问题。</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="线程池参数"><a href="#线程池参数" class="headerlink" title="线程池参数"></a>线程池参数</h3><p>线程池的最上层接口是Executor。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Executor &#123;</span><br><span class="line">    void execute(Runnable command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>execute最后由ThreadPoolExecutor类实现，该方法用于传入任务，而ThreadPoolExecutor是线程池的核心类，此类的构造方法如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,</span><br><span class="line">            BlockingQueue&lt;Runnable&gt; workQueue);</span><br><span class="line"> </span><br><span class="line">public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,</span><br><span class="line">BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory);</span><br><span class="line"></span><br><span class="line">public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,</span><br><span class="line">BlockingQueue&lt;Runnable&gt; workQueue,RejectedExecutionHandler handler);</span><br><span class="line"></span><br><span class="line">public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,</span><br><span class="line">BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler);</span><br></pre></td></tr></table></figure><p>构造方法的参数及意义:</p><ul><li>corePoolSize</li></ul><p>核心线程池的大小，如果核心线程池有空闲位置，新的任务就会被核心线程池新建1个线程执行，执行完毕后不会销毁线程，线程会进入缓存队列等待再次被运行；</p><ul><li>maximumPoolSize</li></ul><p>线程池能创建最大的线程数量，如果核心线程池和缓存队列都已经满了，新的任务进来就会创建新的线程来执行，但是数量不能超过maximumPoolSize，否则会采取拒绝接受任务策略；</p><ul><li>keepAliveTime</li></ul><p>非核心线程能够空闲的最长时间，超过时间，线程终止。该参数默认在线程数量超过核心线程池大小时才会起作用；</p><ul><li>unit</li></ul><p>时间单位，和keepAliveTime配合使用；</p><ul><li>workQueue</li></ul><p>缓存队列，用于存放等待被执行的任务；</p><ul><li>threadFactory</li></ul><p>线程工厂，用于创建线程，一般有3种选择策略；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayBlockingQueue;</span><br><span class="line">LinkedBlockingQueue;</span><br><span class="line">SynchronousQueue;</span><br></pre></td></tr></table></figure><ul><li>handler</li></ul><p>拒绝处理策略，线程数量大于最大线程数就会采用拒绝处理策略，四种策略为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 </span><br><span class="line">ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 </span><br><span class="line">ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</span><br><span class="line">ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</span><br></pre></td></tr></table></figure><p>Executor接口有一个子接口ExecutorService，ExecutorService的实现类为AbstracExecutorService，而ThreadPoolExcutor正是AbstrcExecutorService的子类。</p><p>ThreadPoolExecutor还有两个常用的方法shutdown()和shutdownNow()，两者都用来关闭线程池，但是后者有一个结果返回。</p><h3 id="线程池实现原理"><a href="#线程池实现原理" class="headerlink" title="线程池实现原理"></a>线程池实现原理</h3><ul><li>线程池图:</li></ul><p><img src="/2019/10/28/Java的线程池/1.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// 任务的后备队列</span><br><span class="line">private final BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line">// 锁</span><br><span class="line">private final ReentrantLock mainLock = new ReentrantLock();</span><br><span class="line">// 用来支持等待中断的</span><br><span class="line">private final Condition termination = mainLock.newCondition();</span><br><span class="line">// 存放的工作线程，只有当获取到锁的时候才能访问这个 Set</span><br><span class="line">private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;();</span><br><span class="line">// 线程池最大数量</span><br><span class="line">private int largestPoolSize;</span><br><span class="line">// 完成的线程数，只有在获取锁的时候才能更新这个值</span><br><span class="line">private long completedTaskCount;</span><br><span class="line"></span><br><span class="line">//==============================================================================</span><br><span class="line">// 这里有提到用户自定义的变量我们都是用 volatile 来修饰 以保证获取到最新的值</span><br><span class="line">//==============================================================================</span><br><span class="line">// 线程创建工厂类</span><br><span class="line">private volatile ThreadFactory threadFactory;</span><br><span class="line">// 当任务队列饱和或者线程池关闭后 再往里面提交任务时候的执行策略</span><br><span class="line">private volatile RejectedExecutionHandler handler;</span><br><span class="line">// 默认的执行策略是采用的 AbortPolicy (这是一个函数式接口的子类，里面实现的方法默认是抛异常)</span><br><span class="line">private static final RejectedExecutionHandler defaultHandler = new AbortPolicy();</span><br><span class="line">// 非核心线程的存活时间</span><br><span class="line">private volatile long keepAliveTime;</span><br><span class="line">// 是否允许核心线程具有存活时间，允许则上面的参数也会作用于核心线程</span><br><span class="line">private volatile boolean allowCoreThreadTimeOut;</span><br><span class="line">// 核心线程的大小</span><br><span class="line">private volatile int corePoolSize;</span><br><span class="line">// 最大线程数</span><br><span class="line">private volatile int maximumPoolSize;</span><br><span class="line">// 池控参数  非常重要！！！！</span><br><span class="line">private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));</span><br><span class="line">// ctl 的解包 -&gt; workerCount 和 runState</span><br><span class="line">private static int runStateOf(int c)     &#123; return c &amp; ~CAPACITY; &#125;</span><br><span class="line">private static int workerCountOf(int c)  &#123; return c &amp; CAPACITY; &#125;</span><br><span class="line">// 打包操作 两个变量或一下</span><br><span class="line">private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125;</span><br></pre></td></tr></table></figure><p>其中比较重要的属性有: workQueue(任务队列)、一个Set(线程集合)、池参数、线程工厂类、拒绝策略、池控参数。</p><p>其中池控参数是将两个变量都打包进去，分别是workerCount和runState。</p><p>workerCount为有效线程数，runState表明线程池的状态是否为运行。为了方便表示，我们把 workerCount和runState打包到了1个变量里面就是ctl。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">COUNT_BITS = 29</span><br><span class="line">CAPACITY = 0001 1111 1111 1111 </span><br><span class="line">           1111 1111 1111 1111</span><br><span class="line">RUNNING = 111 0 0000 0000 0000 </span><br><span class="line">          0000 0000 0000 0000</span><br><span class="line">SHUTDOWN = 000 0 0000 0000 0000</span><br><span class="line">           0000 0000 0000 0000</span><br><span class="line">STOP = 001 0 0000 0000 0000 </span><br><span class="line">       0000 0000 0000 0000</span><br><span class="line">TIDYING = 010 0 0000 0000 0000 </span><br><span class="line">          0000 0000 0000 0000</span><br><span class="line">TERMINATED = 011 0 0000 0000 0000 </span><br><span class="line">             0000 0000 0000 0000</span><br></pre></td></tr></table></figure><p>高3位作为状态值，低29位作为工作线程总数。</p><ul><li>线程池状态</li></ul><p>线程池和线程一样拥有自己的状态，在ThreadPoolExecutor类中定义了一个volatile变量runState来表示线程池的状态，线程池有以下状态:</p><ul><li>RUNNING：接受新任务并处理排队的任务</li><li>SHUTDOWN：不接受新任务，但处理排队的任务</li><li>STOP：不接受新任务，不处理排队的任务，并中断正在进行的任务</li><li>TIDYING：所有任务都已终止，workerCount为零，线程转换到状态TIDYING 将运行terminate() 勾子</li><li><p>TERMINATED：terminated()已完成<br>  <br>并且这些值之间顺序很重要，以允许有序的比较。 runState在整个过程中是单调递增的但不需要经过每一个状态，具体规律如下：</p></li><li><p>RUNNING -&gt; SHUTDOWN  在执行 shutdown()的时候</p></li><li>(RUNNING or SHUTDOWN) -&gt; STOP  在执行shutdownNow()</li><li>SHUTDOWN -&gt; TIDYING  当任务队列和线程池为空的时候</li><li>STOP -&gt; TIDYING  当池为空的时候</li><li>TIDYING -&gt; TERMINATED  钩子方法调用完毕</li></ul><h4 id="Excute方法"><a href="#Excute方法" class="headerlink" title="Excute方法"></a>Excute方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public void execute(Runnable command) &#123;</span><br><span class="line">if (command == null)</span><br><span class="line">throw new NullPointerException();</span><br><span class="line">int c = ctl.get();</span><br><span class="line">if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">// 如果工作线程少于corePoolSize，则尝试增加新核心线程处理command</span><br><span class="line">if (addWorker(command, true))</span><br><span class="line">// 新核心线程增加成功，则直接返回</span><br><span class="line">return;</span><br><span class="line">// 新核心线程增加不成功，重新获取池控参数</span><br><span class="line">c = ctl.get();</span><br><span class="line">&#125;</span><br><span class="line">// 如果线程池处于Running，则将当前command增加到任务队列</span><br><span class="line">if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">// 重新获取池化参数</span><br><span class="line">int recheck = ctl.get();</span><br><span class="line">// 如果线程池关闭了，我们需要做回退动作，也就是撤销刚才放入的任务</span><br><span class="line">// 如果撤销成功，执行拒绝策略</span><br><span class="line">if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">reject(command);</span><br><span class="line">// 如果撤销失败，并且没有工作线程不管他</span><br><span class="line">else if (workerCountOf(recheck) == 0)</span><br><span class="line">addWorker(null, false);</span><br><span class="line">&#125;</span><br><span class="line">// 若排队失败，增加非核心线程处理command</span><br><span class="line">// 若线程添加失败，则说明线程池关闭或者处于饱和状态</span><br><span class="line">else if (!addWorker(command, false))</span><br><span class="line">reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="addWorker"><a href="#addWorker" class="headerlink" title="addWorker"></a>addWorker</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">private boolean addWorker(Runnable firstTask, boolean core) &#123;</span><br><span class="line">retry:</span><br><span class="line">for (;;) &#123;</span><br><span class="line">int c = ctl.get();</span><br><span class="line">int rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">// Check if queue empty only if necessary.</span><br><span class="line">if (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">   firstTask == null &amp;&amp;</span><br><span class="line">   ! workQueue.isEmpty()))</span><br><span class="line">return false;</span><br><span class="line"></span><br><span class="line">for (;;) &#123;</span><br><span class="line">int wc = workerCountOf(c);</span><br><span class="line">// 如果工作线程数量大于CAPACITY</span><br><span class="line">// 或者工作线程数量大于最大值(若core为true，最大值为corePoolSize，否则为maximumPoolSize)</span><br><span class="line">if (wc &gt;= CAPACITY ||</span><br><span class="line">wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">return false;</span><br><span class="line">// 若工作线程数目增加成功，退出最外层自旋</span><br><span class="line">if (compareAndIncrementWorkerCount(c))</span><br><span class="line">break retry;</span><br><span class="line">// 重新读取池控参数，若状态发生变化，继续自旋</span><br><span class="line">c = ctl.get();  // Re-read ctl</span><br><span class="line">if (runStateOf(c) != rs)</span><br><span class="line">continue retry;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boolean workerStarted = false;</span><br><span class="line">boolean workerAdded = false;</span><br><span class="line">Worker w = null;</span><br><span class="line">try &#123;</span><br><span class="line">w = new Worker(firstTask);</span><br><span class="line">final Thread t = w.thread;</span><br><span class="line">if (t != null) &#123;</span><br><span class="line">final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">mainLock.lock();</span><br><span class="line">try &#123;</span><br><span class="line">int rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">if (rs &lt; SHUTDOWN ||</span><br><span class="line">(rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123;</span><br><span class="line">if (t.isAlive()) // precheck that t is startable</span><br><span class="line">throw new IllegalThreadStateException();</span><br><span class="line">workers.add(w);</span><br><span class="line">int s = workers.size();</span><br><span class="line">if (s &gt; largestPoolSize)</span><br><span class="line">largestPoolSize = s;</span><br><span class="line">workerAdded = true;</span><br><span class="line">&#125;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">mainLock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">if (workerAdded) &#123;</span><br><span class="line">t.start();</span><br><span class="line">workerStarted = true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">if (! workerStarted)</span><br><span class="line">addWorkerFailed(w);</span><br><span class="line">&#125;</span><br><span class="line">return workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public void shutdown() &#123;</span><br><span class="line">final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">mainLock.lock();</span><br><span class="line">try &#123;</span><br><span class="line">// 调用checkShutdownAccess方法检查每一个线程池的线程是否有可以ShutDown的权限</span><br><span class="line">checkShutdownAccess();</span><br><span class="line">// 调用advanceRunState函数通过自旋的CAS操作来将ctl中的状态变为SHUTDOWN</span><br><span class="line">advanceRunState(SHUTDOWN);</span><br><span class="line">// 调用interruptIdleWorkers方法，将所有Idle状态的线程都调用interrupt方法，中断线程。而判断idle状态使用Worker中的ReentrantLock来调用tryLock尝试加锁，看Worker线程是否已经获取了锁，如果Worker的锁已经被加了的话，那么tryLock返回的就是false</span><br><span class="line">interruptIdleWorkers();</span><br><span class="line">// 通过onShutDown()方法告知子类，线程池要处于ShutDown状态了</span><br><span class="line">onShutdown(); // hook for ScheduledThreadPoolExecutor</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">mainLock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">// 调用tryTermiante的方法尝试终止线程池</span><br><span class="line">tryTerminate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow"></a>shutdownNow</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Runnable&gt; shutdownNow() &#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        interruptWorkers();</span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">    return tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ShutDownNow方法和ShutDown方法差不多，这两个方法的区别有：</p><ul><li>shutDownNow方法会返回未完成的任务队列中的任务列表</li><li>advanceRunState方法中传入的是STOP，而不是SHUTDOWN。</li></ul><h4 id="interruptIdleWorkers"><a href="#interruptIdleWorkers" class="headerlink" title="interruptIdleWorkers"></a>interruptIdleWorkers</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private void interruptIdleWorkers(boolean onlyOne) &#123;</span><br><span class="line">final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">mainLock.lock();</span><br><span class="line">try &#123;</span><br><span class="line">for (Worker w : workers) &#123;</span><br><span class="line">Thread t = w.thread;</span><br><span class="line">// 如果线程未被中断，尝试获取worker的锁</span><br><span class="line">if (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">// 中断线程</span><br><span class="line">t.interrupt();</span><br><span class="line">&#125; catch (SecurityException ignore) &#123;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">w.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 如果onlyOne为True，则只中断1个空闲工作线程</span><br><span class="line">if (onlyOne)</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">mainLock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 默认中断所有空闲工作线程</span><br><span class="line">private void interruptIdleWorkers() &#123;</span><br><span class="line">interruptIdleWorkers(false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="tryTerminate"><a href="#tryTerminate" class="headerlink" title="tryTerminate"></a>tryTerminate</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">final void tryTerminate() &#123;</span><br><span class="line">for (;;) &#123;</span><br><span class="line">int c = ctl.get();</span><br><span class="line">// 判断当前线程池是否正在运行，或者当前线程池的状态比TIDYING（整理中）要大（也就是处于TIDYING或者TERMINATED状态），或者当前线程状态处于SHUTDOWN并且任务队列不为空的话，那么就直接return</span><br><span class="line">if (isRunning(c) ||</span><br><span class="line">runStateAtLeast(c, TIDYING) ||</span><br><span class="line">(runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">return;</span><br><span class="line">// 如果当前的WorkerCount不为0，那么就会调用interruptedIdleWorkers(true)，并且返回</span><br><span class="line">if (workerCountOf(c) != 0) &#123; // Eligible to terminate</span><br><span class="line">interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">mainLock.lock();</span><br><span class="line">// 通过CAS操作将ctl设置成TIDYING，如果设置成功之后就会调用terminated方法， 告知子类，要终止了，终止完之后，就会将ctl的状态设置成TERMINATED，以及workerCount为0</span><br><span class="line">try &#123;</span><br><span class="line">if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">terminated();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">ctl.set(ctlOf(TERMINATED, 0));</span><br><span class="line">termination.signalAll();</span><br><span class="line">&#125;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">mainLock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">// else retry on failed CAS</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="processWorkerExit"><a href="#processWorkerExit" class="headerlink" title="processWorkerExit"></a>processWorkerExit</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private void processWorkerExit(Worker w, boolean completedAbruptly) &#123;</span><br><span class="line">// 如果是意外退出的话，那么就需要把WorkerCount--</span><br><span class="line">    if (completedAbruptly) // If abrupt, then workerCount wasn&apos;t adjusted</span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">    final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">// 加完锁后，同步将completedTaskCount进行增加，表示总共完成的任务数，并且从WorkerSet中将对应的Worker移除</span><br><span class="line">    try &#123;</span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tryTerminate();</span><br><span class="line"></span><br><span class="line">    int c = ctl.get();</span><br><span class="line">// 判断当前的线程池状态，如果当前线程池状态比STOP大的话，就不处理</span><br><span class="line">    if (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">// 判断是否是意外退出，如果不是意外退出的话，那么就会判断最少要保留的核心线程数，如果allowCoreThreadTimeOut被设置为true的话，那么说明核心线程在设置的KeepAliveTime之后，也会被销毁</span><br><span class="line">        if (!completedAbruptly) &#123;</span><br><span class="line">            int min = allowCoreThreadTimeOut ? 0 : corePoolSize;</span><br><span class="line">// 如果最少保留的Worker数为0的话，那么就会判断当前的任务队列是否为空，如果任务队列不为空的话而且线程池没有停止，那么说明至少还需要1个线程继续将任务完成</span><br><span class="line">            if (min == 0 &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min = 1;</span><br><span class="line">// 判断当前的Worker是否大于min，也就是说当前的Worker总数大于最少需要的Worker数的话，那么就直接返回，因为剩下的Worker会继续从WorkQueue中获取任务执行</span><br><span class="line">            if (workerCountOf(c) &gt;= min)</span><br><span class="line">                return; // replacement not needed</span><br><span class="line">        &#125;</span><br><span class="line">// 如果当前运行的Worker数比当前所需要的Worker数少的话，那么就会调用addWorker，添加新的Worker，也就是新开启线程继续处理任务</span><br><span class="line">        addWorker(null, false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="getPoolSize"><a href="#getPoolSize" class="headerlink" title="getPoolSize"></a>getPoolSize</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public int getPoolSize() &#123;</span><br><span class="line">final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">mainLock.lock();</span><br><span class="line">try &#123;</span><br><span class="line">// 若线程池状态大于等于TIDYING，则线程池大小为0，否则为workers.size()</span><br><span class="line">return runStateAtLeast(ctl.get(), TIDYING) ? 0</span><br><span class="line">: workers.size();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">mainLock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="getActiveCount"><a href="#getActiveCount" class="headerlink" title="getActiveCount"></a>getActiveCount</h4><p>获取活跃线程总数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public int getActiveCount() &#123;</span><br><span class="line">final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">mainLock.lock();</span><br><span class="line">try &#123;</span><br><span class="line">int n = 0;</span><br><span class="line">for (Worker w : workers)</span><br><span class="line">// 若该线程被锁定，说明正在处理任务，属于活跃线程</span><br><span class="line">if (w.isLocked())</span><br><span class="line">++n;</span><br><span class="line">return n;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">mainLock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="getTaskCount"><a href="#getTaskCount" class="headerlink" title="getTaskCount"></a>getTaskCount</h4><p>获取任务总数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public long getTaskCount() &#123;</span><br><span class="line">final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">mainLock.lock();</span><br><span class="line">try &#123;</span><br><span class="line">long n = completedTaskCount;</span><br><span class="line">for (Worker w : workers) &#123;</span><br><span class="line">n += w.completedTasks;</span><br><span class="line">if (w.isLocked())</span><br><span class="line">++n;</span><br><span class="line">&#125;</span><br><span class="line">// 各线程已完成的任务之和+当前正在进行的任务+任务队列的大小作为任务总数</span><br><span class="line">return n + workQueue.size();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">mainLock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="getCompletedTaskCount"><a href="#getCompletedTaskCount" class="headerlink" title="getCompletedTaskCount"></a>getCompletedTaskCount</h4><p>获取完成的任务总数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public long getCompletedTaskCount() &#123;</span><br><span class="line">final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">mainLock.lock();</span><br><span class="line">try &#123;</span><br><span class="line">long n = completedTaskCount;</span><br><span class="line">// 遍历工作线程，叠加每个线程的completedTasks</span><br><span class="line">for (Worker w : workers)</span><br><span class="line">n += w.completedTasks;</span><br><span class="line">return n;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">mainLock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;创建线程的方法&quot;&gt;&lt;a href=&quot;#创建线程的方法&quot; class=&quot;headerlink&quot; title=&quot;创建线程的方法&quot;&gt;&lt;/a&gt;创建线程的方法&lt;/h2&gt;&lt;p&gt;常见的创建线程的方法，主要有以下3种:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;继承Thread类;&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="并发编程" scheme="http://ruanshubin.top/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://ruanshubin.top/tags/Java/"/>
    
      <category term="并发" scheme="http://ruanshubin.top/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>日志框架简述</title>
    <link href="http://ruanshubin.top/2019/10/28/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E7%AE%80%E8%BF%B0/"/>
    <id>http://ruanshubin.top/2019/10/28/日志框架简述/</id>
    <published>2019-10-28T13:30:00.000Z</published>
    <updated>2019-12-25T02:58:11.024Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java日志简述"><a href="#Java日志简述" class="headerlink" title="Java日志简述"></a>Java日志简述</h2><p>对于一个应用程序来说日志记录是必不可少的一部分。线上问题追踪，基于日志的业务逻辑统计分析等都离不日志。java领域存在多种日志框架，目前常用的日志框架包括Log4j 1，Log4j 2，Commons Logging，Slf4j，Logback，Jul。</p><ul><li><p>Log4j Apache Log4j是一个基于Java的日志记录工具。它是由Ceki Gülcü首创的，现在则是Apache软件基金会的一个项目。 Log4j是几种Java日志框架之一。</p></li><li><p>Log4j 2 Apache Log4j 2是apache开发的一款Log4j的升级产品。</p></li><li><p>Commons Logging Apache基金会所属的项目，是一套Java日志接口，之前叫Jakarta Commons Logging，后更名为Commons Logging。</p></li><li><p>Slf4j 类似于Commons Logging，是一套简易Java日志门面，本身并无日志的实现。（Simple Logging Facade for Java，缩写Slf4j）。</p></li><li><p>Logback 一套日志组件的实现(Slf4j阵营)。</p></li><li><p>Jul (Java Util Logging),自Java1.4以来的官方日志实现。</p></li></ul><h2 id="Java常用日志框架历史"><a href="#Java常用日志框架历史" class="headerlink" title="Java常用日志框架历史"></a>Java常用日志框架历史</h2><ul><li><p>1996年早期，欧洲安全电子市场项目组决定编写它自己的程序跟踪API(Tracing API)。经过不断的完善，这个API终于成为一个十分受欢迎的Java日志软件包，即Log4j。后来Log4j成为Apache基金会项目中的一员。</p></li><li><p>期间Log4j近乎成了Java社区的日志标准。据说Apache基金会还曾经建议Sun引入Log4j到java的标准库中，但Sun拒绝了。</p></li><li><p>2002年Java1.4发布，Sun推出了自己的日志库JUL(Java Util Logging),其实现基本模仿了Log4j的实现。在JUL出来以前，Log4j就已经成为一项成熟的技术，使得Log4j在选择上占据了一定的优势。</p></li><li><p>接着，Apache推出了Jakarta Commons Logging，JCL只是定义了一套日志接口(其内部也提供一个Simple Log的简单实现)，支持运行时动态加载日志组件的实现，也就是说，在你应用代码里，只需调用Commons Logging的接口，底层实现可以是Log4j，也可以是Java Util Logging。</p></li><li><p>后来(2006年)，Ceki Gülcü不适应Apache的工作方式，离开了Apache。然后先后创建了Slf4j(日志门面接口，类似于Commons Logging)和Logback(Slf4j的实现)两个项目，并回瑞典创建了QOS公司，QOS官网上是这样描述Logback的：The Generic，Reliable Fast&amp;Flexible Logging Framework(一个通用，可靠，快速且灵活的日志框架)。</p></li><li><p>现今，Java日志领域被划分为两大阵营：Commons Logging阵营和Slf4j阵营。</p></li><li><p>Commons Logging在Apache大树的笼罩下，有很大的用户基数。但有证据表明，形式正在发生变化。2013年底有人分析了GitHub上30000个项目，统计出了最流行的100个Libraries，可以看出Slf4j的发展趋势更好：</p></li></ul><p><img src="/2019/10/28/日志框架简述/1.jpg" alt=""></p><ul><li>Apache眼看有被Logback反超的势头，于2012-07重写了Log4j 1.x，成立了新的项目Log4j 2, Log4j 2具有Logback的所有特性。</li></ul><h2 id="Java常用日志框架之间的关系"><a href="#Java常用日志框架之间的关系" class="headerlink" title="Java常用日志框架之间的关系"></a>Java常用日志框架之间的关系</h2><ul><li><p>Log4j 2与Log4j 1发生了很大的变化，Log4j 2不兼容Log4j 1。</p></li><li><p>Commons Logging和Slf4j是日志门面(门面模式是软件工程中常用的一种软件设计模式，也被称为正面模式、外观模式。它为子系统中的一组接口提供一个统一的高层接口，使得子系统更容易使用)。Log4j和Logback则是具体的日志实现方案。可以简单的理解为接口与接口的实现，调用者只需要关注接口而无需关注具体的实现，做到解耦。</p></li><li><p>比较常用的组合使用方式是Slf4j与Logback组合使用，Commons Logging与Log4j组合使用。</p></li><li><p>Logback必须配合Slf4j使用。由于Logback和Slf4j是同一个作者，其兼容性不言而喻。</p></li></ul><h2 id="选择日志框架"><a href="#选择日志框架" class="headerlink" title="选择日志框架"></a>选择日志框架</h2><p>如果是在一个新的项目中建议使用Slf4j与Logback组合，这样有如下的几个优点。</p><ul><li><p>Slf4j实现机制决定Slf4j限制较少，使用范围更广。由于Slf4j在编译期间，静态绑定本地的LOG库使得通用性要比Commons Logging要好。</p></li><li><p>Logback拥有更好的性能。Logback声称：某些关键操作，比如判定是否记录一条日志语句的操作，其性能得到了显著的提高。这个操作在Logback中需要3纳秒，而在Log4J中则需要30纳秒。LogBack创建记录器（logger）的速度也更快：13毫秒，而在Log4J中需要23毫秒。更重要的是，它获取已存在的记录器只需94纳秒，而Log4J需要2234纳秒，时间减少到了1/23。跟JUL相比的性能提高也是显著的。</p></li><li><p>Commons Logging开销更高</p></li><li><p>Logback文档免费。Logback的所有文档是全面免费提供的，不象Log4J那样只提供部分免费文档而需要用户去购买付费文档。</p></li></ul><h2 id="SLF4J用法"><a href="#SLF4J用法" class="headerlink" title="SLF4J用法"></a>SLF4J用法</h2><h3 id="Slf4j与其它日志组件的关系说明"><a href="#Slf4j与其它日志组件的关系说明" class="headerlink" title="Slf4j与其它日志组件的关系说明"></a>Slf4j与其它日志组件的关系说明</h3><ul><li>Slf4j的设计思想比较简洁，使用了Facade设计模式，Slf4j本身只提供了一个slf4j-api-version.jar包，这个jar中主要是日志的抽象接口，jar中本身并没有对抽象出来的接口做实现。</li><li>对于不同的日志实现方案(例如Logback，Log4j…)，封装出不同的桥接组件(例如logback-classic-version.jar，slf4j-log4j12-version.jar)，这样使用过程中可以灵活的选取自己项目里的日志实现。</li></ul><h3 id="Slf4j与其它日志组件调用关系图"><a href="#Slf4j与其它日志组件调用关系图" class="headerlink" title="Slf4j与其它日志组件调用关系图"></a>Slf4j与其它日志组件调用关系图</h3><p><img src="/2019/10/28/日志框架简述/2.jpg" alt=""></p><h3 id="Slf4j与其他各种日志组件的桥接说明"><a href="#Slf4j与其他各种日志组件的桥接说明" class="headerlink" title="Slf4j与其他各种日志组件的桥接说明"></a>Slf4j与其他各种日志组件的桥接说明</h3><p><img src="/2019/10/28/日志框架简述/3.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Java日志简述&quot;&gt;&lt;a href=&quot;#Java日志简述&quot; class=&quot;headerlink&quot; title=&quot;Java日志简述&quot;&gt;&lt;/a&gt;Java日志简述&lt;/h2&gt;&lt;p&gt;对于一个应用程序来说日志记录是必不可少的一部分。线上问题追踪，基于日志的业务逻辑统计分析等都
      
    
    </summary>
    
      <category term="Java" scheme="http://ruanshubin.top/categories/Java/"/>
    
    
      <category term="Java" scheme="http://ruanshubin.top/tags/Java/"/>
    
      <category term="日志" scheme="http://ruanshubin.top/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Java的持久化</title>
    <link href="http://ruanshubin.top/2019/10/26/Java%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>http://ruanshubin.top/2019/10/26/Java的持久化/</id>
    <published>2019-10-26T13:30:00.000Z</published>
    <updated>2019-12-25T02:52:23.376Z</updated>
    
    <content type="html"><![CDATA[<h2 id="持久化方案发展过程"><a href="#持久化方案发展过程" class="headerlink" title="持久化方案发展过程"></a>持久化方案发展过程</h2><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>当断电或者系统故障宕机时，内存中Java创建的对象将荡然无存，解决该问题的初始方式为—序列化。</p><ul><li>序列化</li></ul><p>将内存中的对象转换为二进制文件存储到硬盘。</p><ul><li>反序列化</li></ul><p>将二进制文件加载为内存中的对象。</p><p>序列化的缺点是效率低，对象少的时候还可以，如果需要对大规模的对象进行存储、查询则就捉襟见肘了。</p><p>比如想选取age&gt;26的所有Person对象，则需要把所有序列化之后的Person对象都装入内存，然后逐个比对年龄，效率慢到爆炸。</p><p>解决上述问题的方式为—使用关系型数据库存储大规模数据。</p><h3 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h3><p>关系型数据库用类似二维表格的形式来存储数据。并提供中间层SQL来支持关系代数、关系演算等，屏蔽了具体的实现细节和各个数据库之间的差异。</p><p>为了将Java对象映射到数据库的二维表格上去，需要将对象的属性变成数据库的行/列，该种过程称之为Object-Relational Mapping，实现该种过程的一系列框架称之为ORM框架。</p><p>对象映射到数据库的表上之后，需要建立与数据库的连接，由于各种数据库的底层实现千差万别，所以Java仅提供接口，然后由各数据库厂商去各自实现该接口，该接口即为Java Database Connectivity，简称JDBC。</p><h3 id="EJB时代"><a href="#EJB时代" class="headerlink" title="EJB时代"></a>EJB时代</h3><p>JDBC是一个非常”低级”的接口。程序员需要处理太多的细节，冗余代码太多，写一个简单的查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、打开Connection</span><br><span class="line">2、创建Statement</span><br><span class="line">3、执行SQL</span><br><span class="line">4、遍历ResultSet</span><br><span class="line">5、关闭Connection</span><br></pre></td></tr></table></figure><p>在安全、事务、分布式、可伸缩性、高可用等高级功能场景下，操作系统及应用程序均不想承接这些脏活累活。</p><p>那交给谁呢？</p><p>答案是—中间件(Middleware)，它专门负责底层操作系统和上层应用程序都不愿意做的事情。</p><p>Java充分发挥制定标准的特长，制订了J2EE规范，其涵盖了大部分企业开发的需求，把通用、复杂的服务交给中间件提供商去搞定，让开发人员集中精力在业务逻辑的开发上。</p><p>其中一个标准就是EJB，使用EJB即可不用写繁琐的JDBC代码了，数据的创建、读取、查询均可以用面向对象的风格搞定，并且EJB实例可以在一个集群上分布式的运行。</p><p>当然，EJB的缺点也非常明显，它过于笨重了，且开发繁琐、难以测试、性能低下。</p><p>是到了变革的时候了！</p><h3 id="轻量级ORM框架"><a href="#轻量级ORM框架" class="headerlink" title="轻量级ORM框架"></a>轻量级ORM框架</h3><p>2001年，Gavin King发明了Hibernate，意为冬眠。</p><p>冬眠？冬天让内存中的数据进入数据库冬眠，春天来了从冬眠中醒来，进入内存工作。</p><p>同年，iBatis也出现了。</p><p>2004年，Rod Johnson给了EJB致命一击，他编写了Export One-on-One J2EE Development without EJB一书,公开宣扬抛弃笨重的EJB，使用由他开发出的轻量框架Spring。</p><p>Spring不但自己提供了轻量级的访问数据库的方法JdbcTemplate，还可轻松集成Hibernate、IBatis等一系列ORM框架，所以受到越来越多Java开发者的欢迎，EJB已名存实亡。</p><h3 id="JPA"><a href="#JPA" class="headerlink" title="JPA"></a>JPA</h3><p>后面出现的EJB3.0虽然兼收并蓄，融合了Hibernate的优点，但其笨重的底子是难以被改变的，最终还是被Java开发者无情地抛弃了。</p><p>EJB3.0定义的ORM标准却神奇地活了下来，也就是Java Persistence API(JPA)，Hibernate、EclipseLink、OpenJPA等明星框架均提供了针对JPA的实现，由于其简便性，收到了一部分开发者的喜爱。</p><h2 id="JDBC发展过程"><a href="#JDBC发展过程" class="headerlink" title="JDBC发展过程"></a>JDBC发展过程</h2><ul><li>Socket</li></ul><p>最开始数据库仅能支持网络访问，即通过Socket的方式获取数据库中的数据。</p><p>这种方式可以实现业务功能，但是业务层需要更换数据库时，由于各个数据库提供的接口不统一，则需要将业务代码的相关部分重写，统一接口迫在眉睫。</p><ul><li>JDBC</li></ul><p>继续抽象，用Connection来代表与数据库的连接，Statement中书写SQL代码，返回的结果统一用ResultSet来表示。</p><p>接口的具体实现由各数据库完成。</p><ul><li>Driver</li></ul><p>但还不够彻底，由于各数据库的实现类不同，更换数据库的时候还是需要更改相应代码。</p><p>继续抽象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Driver&#123;</span><br><span class="line">public static Connection getConnection(String dbType, Properties info)&#123;</span><br><span class="line">if(&quot;mysql&quot;.equals(dbType))&#123;</span><br><span class="line">return new MySqlConnentionImpl(info);</span><br><span class="line">&#125;</span><br><span class="line">if(&quot;oracle&quot;.equals(dbType))&#123;</span><br><span class="line">return new OracleConnentionImpl(info);</span><br><span class="line">&#125;</span><br><span class="line">if(&quot;db2&quot;.equals(dbType))&#123;</span><br><span class="line">return new DB2ConnentionImpl(info);</span><br><span class="line">&#125;</span><br><span class="line">throw new RuntimeException(&quot;unsupport db type: &quot; + dbType);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但还是存在问题，比如需要增加新的数据库，则需要频繁修改Driver代码，如果Driver已经打包到JDK里，则就无法修改了。</p><p>解决的方式也很简单，基于反射的方式从外部读取配置，然后创建相应的Connection实现类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// Connection-type.properties</span><br><span class="line">// mysql = com.mysql.jdbc.MySqlConnectionImpl</span><br><span class="line"></span><br><span class="line">public class Driver&#123;</span><br><span class="line">public static Connection getConnection(String dbType, Properties info)&#123;</span><br><span class="line">Class&lt;?&gt; clz = getConnectionImplClass(dbType);</span><br><span class="line">try&#123;</span><br><span class="line">Constructor&lt;?&gt; c = clz.getConstructor(Properties.class);</span><br><span class="line">return (Connection) c.newInstance(info);</span><br><span class="line">&#125;catch(Exception e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static Class&lt;?&gt; getConnectionImplClass(String dbType)&#123;</span><br><span class="line">// 读取配置文件，从中根据dbType来读取相应的Connection实现类，过程略</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，创建实现类的过程不应该被暴露出来。应该让各个厂商在各自的.jar中去创建各自的Connection实例对象。</p><p>使用工厂方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 属于JDK的Driver类</span><br><span class="line">public interface Driver&#123;</span><br><span class="line">public Connection getConnection(Properties info);</span><br><span class="line">&#125;</span><br><span class="line">// 属于mysql-jdbc.jar的MySqlDriver类</span><br><span class="line">public class MySqlDriver implements Driver&#123;</span><br><span class="line">@override</span><br><span class="line">public Connection getConnection(Properties info)&#123;</span><br><span class="line">return new MySqlConnentionImpl(info);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，Driver变成了接口，由各数据库厂商去具体实现。</p><p>业务层调用的时候通过反射的方式来进行Connection实现类的加载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clz = Class.forName(&quot;com.mysql.MySqlDriver&quot;);</span><br><span class="line">Driver driver = (Driver)clz.newInstance();</span><br><span class="line">Connection conn = driver.getConnection(info);</span><br></pre></td></tr></table></figure><p>进一步简化，将上面的脏活累活交给DriverManager。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class DriverManager&#123;</span><br><span class="line">private static List&lt;Driver&gt; registeredDrivers = new ArrayList&lt;&gt;();</span><br><span class="line">public static Connection getConnection(String url, String user, String password)&#123;</span><br><span class="line">Properties info = new Properties();</span><br><span class="line">info.put(&quot;user&quot;, user);</span><br><span class="line">info.put(&quot;password&quot;, password);</span><br><span class="line">for(Driver driver : registeredDrivers)&#123;</span><br><span class="line">Connection conn = driver.getConnection(url, info);</span><br><span class="line">if(conn != null)&#123;</span><br><span class="line">return conn;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">thow new RuntimeExecption(&quot;can&apos;t create a connection&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void register(Driver driver)&#123;</span><br><span class="line">if(!registeredDrivers.contains(driver))&#123;</span><br><span class="line">registeredDrivers.add(driver);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如，MySqlDriver的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class MySqlDriver implements Driver&#123;</span><br><span class="line">static&#123;</span><br><span class="line">DriverManager.register(new MySqlDriver())</span><br><span class="line">&#125;</span><br><span class="line">public Connection getConnection(String url, Properties info)&#123;</span><br><span class="line">if(acceptsURL(url))&#123;</span><br><span class="line">return new MySqlConnectionImpl(info);</span><br><span class="line">&#125;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean acceptURL(String url)&#123;</span><br><span class="line">return url.startsWith(&quot;jdbc:mysql&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;持久化方案发展过程&quot;&gt;&lt;a href=&quot;#持久化方案发展过程&quot; class=&quot;headerlink&quot; title=&quot;持久化方案发展过程&quot;&gt;&lt;/a&gt;持久化方案发展过程&lt;/h2&gt;&lt;h3 id=&quot;序列化&quot;&gt;&lt;a href=&quot;#序列化&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="Java" scheme="http://ruanshubin.top/categories/Java/"/>
    
    
      <category term="Java" scheme="http://ruanshubin.top/tags/Java/"/>
    
      <category term="基础" scheme="http://ruanshubin.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ是什么</title>
    <link href="http://ruanshubin.top/2019/10/25/RabbitMQ%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>http://ruanshubin.top/2019/10/25/RabbitMQ是什么/</id>
    <published>2019-10-25T13:30:00.000Z</published>
    <updated>2019-12-25T02:47:47.319Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>首先，明确一下MQ是啥？</p><p>MQ是Message Queue的简称，意即消息队列，队列可以理解成管道，即通过管道来进行消息的传递，</p><p>接着想一下MQ可以用来解决什么问题？</p><p>双十一秒杀场景，瞬间来了海量请求，服务器短时间处理不过来，可以先给用户一个返回结果，然后将未处理的请求先放入消息队列，后台慢慢处理队列中的消息，整个过程是异步的。</p><p>MQ既然很有用，各大厂商们便开始考虑构建符合自己业务需求的MQ组件。</p><p>如同TCP协议、HTTP协议一样，业界也存在MQ协议，我们将其称之为AMQP，即Advanced Message Queuing Protocol，高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。</p><p>AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全，其基本架构如下：</p><p><img src="/2019/10/25/RabbitMQ是什么/1.jpg" alt=""></p><p>可以看出，AMQP协议主要分为3大部分：</p><ul><li>Producer: 消息生产者；</li><li>Broker: 消息队列的服务实体；<ul><li>Exchange: 消息交换机，相当于消息的转发中心；</li><li>Binding: 关系绑定，作用是建立Exchange与Queue的映射；</li><li>Queue: 队列，消息的队列载体，每条消息都会由Exchange投递到一个或多个Queue中；</li></ul></li><li>Consumer: 消息消费者。</li></ul><p>由于，RabbitMQ是AMQP的标准实现，下面我们通过RabbitMQ来具体讲解上述协议的各个组件。</p><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>Queue（队列）是RabbitMQ的内部对象，用于存储消息，用下图表示：</p><p><img src="/2019/10/25/RabbitMQ是什么/2.jpg" alt=""></p><p>RabbitMQ中的消息都只能存储在Queue中，生产者（下图中的P）生产消息并最终投递到Queue中，消费者（下图中的C）可以从Queue中获取消息并消费。</p><p><img src="/2019/10/25/RabbitMQ是什么/3.jpg" alt=""></p><p>多个消费者可以订阅同一个Queue，这时Queue中的消息会被平均分摊给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理。 </p><p><img src="/2019/10/25/RabbitMQ是什么/4.jpg" alt=""></p><p>这里可能会存在一个问题，就是假设同一个Queue的多个消费者对消息的处理速度不一致，就会出现有的消费者忙的不堪重负，而有的消费者则闲的一直喝茶，造成消费速度缓慢、系统资源浪费等问题。</p><p>为解决上述问题，RabbitMQ引入了Prefetch count参数，可以通过设置prefetchCount来限制Queue每次发送给每个消费者的消息数，比如我们设置prefetchCount=1，则Queue每次给每个消费者发送一条消息；消费者处理完这条消息后，Queue再给该消费者发送一条消息，从而实现了“能者多劳”。</p><p><img src="/2019/10/25/RabbitMQ是什么/5.jpg" alt=""></p><p>可以看到，上面Producer将消息直接投递到Queue，然后Consumer去相应Queue去取数据，看起来问题不大，但上述模式下的生产者和消费者存在严重的耦合。</p><p>比如以下场景：</p><p>ConsumerA和ConsumerB均想获取ProducerA发送的全部消息，由于Queue的特性，必须构建2个队列QueueA及QueueB，然后由Producer将数据分别投递到QueueA及QueueB。</p><p>假设后面又有一个ConsumerC想获取ProducerA发送的全部消息，此时，我们不但要创建一个QueueC，而且要修改Producer端的代码，使其将数据分别投递到QueueA、QueueB、QueueC。</p><p>此时，每来一个消费者，我们就得修改一次Producer端的代码，生产和消费紧耦合。</p><p>如何解耦呢，套用软件界有名的一句话：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决！</span><br><span class="line">Any problem in computer science can be solved by another layer of indirection！</span><br></pre></td></tr></table></figure><p>所以，AMQP引入Exchange来将消息的Producer和Consumer解耦。</p><h2 id="Exchange"><a href="#Exchange" class="headerlink" title="Exchange"></a>Exchange</h2><p>AMQP 协议中的核心思想就是生产者和消费者的解耦，生产者从不直接将消息发送给队列。生产者通常不知道是否一个消息会被发送到队列中，只是将消息发送到一个交换机。先由 Exchange 来接收，然后 Exchange 按照特定的策略转发到 Queue 进行存储。Exchange 就类似于一个交换机，将各个消息分发到相应的队列中。</p><p><img src="/2019/10/25/RabbitMQ是什么/6.jpg" alt=""></p><p>在实际应用中我们只需要定义好 Exchange 的路由策略，而生产者则不需要关心消息会发送到哪个 Queue 或被哪些 Consumer 消费。在这种模式下生产者只面向 Exchange 发布消息，消费者只面向 Queue 消费消息，Exchange 定义了消息路由到 Queue 的规则，将各个层面的消息传递隔离开，使每一层只需要关心自己面向的下一层，降低了整体的耦合度。</p><h2 id="Binding及RoutingKey"><a href="#Binding及RoutingKey" class="headerlink" title="Binding及RoutingKey"></a>Binding及RoutingKey</h2><p>Binding负责建立Exchange与Queue之间的映射，绑定需要依赖一个额外的参数:RoutingKey，Exchange根据RoutingKey与当前所有绑定的Binding匹配，若满足匹配，则往Exchange所绑定的Queue发送消息。</p><p>向RabbitMQ发送一次消息，可以将其分发到不同的Queue，而RoutingKey的意义依赖于Exchange的类型。</p><p>Exchange主要有三种类型：Fanout、Direct 和Topic。</p><h3 id="Direct-Exchange"><a href="#Direct-Exchange" class="headerlink" title="Direct Exchange"></a>Direct Exchange</h3><p><img src="/2019/10/25/RabbitMQ是什么/7.jpg" alt=""></p><p>Direct Exchange是RabbitMQ默认的Exchange，完全根据RoutingKey来路由消息。设置Exchange和Queue的Binding时需指定RoutingKey（一般为Queue Name），发消息时也指定一样的RoutingKey，消息就会被路由到对应的Queue。</p><p>现在我们考虑只把重要的日志消息写入磁盘文件，例如只把Error级别的日志发送给负责记录写入磁盘文件的Queue。这种场景下我们可以使用指定的RoutingKey（例如 error）将写入磁盘文件的Queue绑定到Direct Exchange上。</p><h3 id="Fanout-Exchange"><a href="#Fanout-Exchange" class="headerlink" title="Fanout Exchange"></a>Fanout Exchange</h3><p><img src="/2019/10/25/RabbitMQ是什么/8.jpg" alt=""></p><p>Fanout Exchange会忽略RoutingKey的设置，直接将Message广播到所有绑定的Queue中。</p><p>以日志系统为例：假设我们定义了一个Exchange来接收日志消息，同时定义了两个Queue来存储消息：一个记录将被打印到控制台的日志消息；另一个记录将被写入磁盘文件的日志消息。我们希望Exchange接收到的每一条消息都会同时被转发到两个Queue，这种场景下就可以使用FanoutExchange来广播消息到所有绑定的Queue。</p><h3 id="Topic-Exchange"><a href="#Topic-Exchange" class="headerlink" title="Topic Exchange"></a>Topic Exchange</h3><p><img src="/2019/10/25/RabbitMQ是什么/9.jpg" alt=""></p><p>Topic Exchange和Direct Exchange类似，也需要通过RoutingKey来路由消息，区别在于Direct Exchange对Routing Key是精确匹配，而Topic Exchange支持模糊匹配。分别支持<em>和#通配符，</em>表示匹配一个单词，#则表示匹配没有或者多个单词。</p><p>假设我们的消息路由规则除了需要根据日志级别来分发之外还需要根据消息来源分发，可以将RoutingKey定义为消息来源.级别如 order.info、user.error等。处理所有来源为user的Queue就可以通过user.<em> 绑定到Topic Exchange上，而处理所有日志级别为info的Queue可以通过 </em>.info 绑定到Exchange上。</p><p>除此以外，还有2种特殊的Exchange。</p><h3 id="Headers-Exchange"><a href="#Headers-Exchange" class="headerlink" title="Headers Exchange"></a>Headers Exchange</h3><p>Headers Exchange会忽略RoutingKey而根据消息中的Headers和创建绑定关系时指定的Arguments来匹配决定路由到哪些Queue。</p><p>Headers Exchange的性能比较差，而且Direct Exchange完全可以代替它，所以不建议使用。</p><h3 id="Default-Exchange"><a href="#Default-Exchange" class="headerlink" title="Default Exchange"></a>Default Exchange</h3><p>Default Exchange是一种特殊的Direct Exchange。当你手动创建一个队列时，后台会自动将这个队列绑定到一个名称为空的Direct Exchange 上，绑定RoutingKey与队列名称相同。有了这个默认的交换机和绑定，使我们只关心队列这一层即可，这个比较适合做一些简单的应用。</p><p>相当于<strong>直接往Queue里发送消息</strong>。</p><p><strong>参考文献：</strong></p><p>1.<a href="https://www.sojson.com/blog/48.html" target="_blank" rel="noopener">https://www.sojson.com/blog/48.html</a><br>2.<a href="https://blog.csdn.net/y4x5M0nivSrJaY3X92c/article/details/80416996#" target="_blank" rel="noopener">https://blog.csdn.net/y4x5M0nivSrJaY3X92c/article/details/80416996#</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;首先，明确一下MQ是啥？&lt;/p&gt;
&lt;p&gt;MQ是Message Queue的简称，意即消息队列，队列可以理解成管道，即通过管道来进行消息的传递
      
    
    </summary>
    
      <category term="基础" scheme="http://ruanshubin.top/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="基础" scheme="http://ruanshubin.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="消息队列" scheme="http://ruanshubin.top/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>如何正确使用RabbitMQ</title>
    <link href="http://ruanshubin.top/2019/10/25/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8RabbitMQ/"/>
    <id>http://ruanshubin.top/2019/10/25/如何正确使用RabbitMQ/</id>
    <published>2019-10-25T13:30:00.000Z</published>
    <updated>2019-12-25T02:49:03.793Z</updated>
    
    <content type="html"><![CDATA[<p>在介绍RabbitMQ的使用之前，我们再具体阐述RabbitMQ里面的一些相关参数，有利于以后使用过程中排坑。</p><p>首先，深入聊一下Queues:</p><h2 id="Queues"><a href="#Queues" class="headerlink" title="Queues"></a>Queues</h2><p>RabbitMQ的Queue存储着Consumer待消费的消息，其与Exchange基于Binding Key进行绑定，除了Binding相关参数外，Queue还有以下重要属性：</p><ul><li>name</li></ul><p>队列名支持最多255字节的UTF-8字符。应用程序在声明队列的时候可以自己指定队列名，或者当应用程序指定name属性为空时，代理（broker）会自动地为其生成一个唯一的队列名。</p><p>需要注意的是，<strong>以”amq.”开头的队列名是由AMQP内部使用的命名前缀，请开发者不要使用</strong>，否则将抛出403异常。</p><ul><li>durability</li></ul><p>durability属性对应两种情况，分别是durable（持久的）和transient（短暂的）。durable类型的队列会持久化至硬盘上，所以当代理（broker）重启之后，它依然存在。相反地，当代理重启之后，transient类型的队列就消失了。</p><p>需要注意的是，队列的持久化是相对队列而言，对存储在持久化队列中的消息来说，当代理重启之后：队列还存在、消息则不存在。</p><p>所以，当broker重启之后，如果想让消息仍然存在，这就是消息持久化机制干的事了，后面再说消息属性的相关内容。</p><h3 id="Queue创建"><a href="#Queue创建" class="headerlink" title="Queue创建"></a>Queue创建</h3><p>需要注意的是，<strong>队列在使用之前必须先声明</strong>。声明之前，如果该队列不存在，那么声明之后就会创建一个队列；如果该队列已经存在了，并且声明的队列与存在的队列属性相同，则不产生任何影响；如果该队列已经存在了，但是声明的队列与存在的队列属性不同，则会抛出一个错误码为406（PRECONDITION_FAILED）的异常。</p><h3 id="Binding"><a href="#Binding" class="headerlink" title="Binding"></a>Binding</h3><p>队列获取来自交换器的消息的前提是该队列必须先与交换器进行绑定。绑定之后，交换器才能将消息按照特定的规则，路由至相应的队列中去。随后，消费者才能从队列中消费消息。</p><p>如果生产者生产的某条消息，没有与之匹配的任何一个队列可供路由（比如，没有任何队列与交换器绑定）。那么，根据该条消息的属性，该消息要么丢弃，要么返回至生产者。</p><h2 id="连接及通道"><a href="#连接及通道" class="headerlink" title="连接及通道"></a>连接及通道</h2><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>AMQP是一个应用层协议，并且是基于TCP可靠传输的应用层协议。除此之外，AMQP也提供了加密传输的机制（使用TSL或SSL），让消息传递更加安全。</p><p>当需要断开AMQP代理时，正确的做法是关闭AMQP连接，而不是粗鲁的直接断开其底层的TCP连接。</p><h3 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h3><p>有的应用程序需要与AMQP broker建立多个连接。在AMQP模型中，我们不需要通过建立太多的TCP连接来实现。假如针对每一个AMQP连接都建立一个TCP连接的话，会占用大量的系统资源。对此，AMQP提供了通道（channel）机制。即，共享一个TCP连接，可创建多个通道。</p><p>在多线程/进程的应用程序中正确做法是，对于每一个线程/进程，应分别建立一个通道，而不是多个线程/进程之间去共享一个通道。</p><h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><p>AMQP使用了虚拟机的概念，在一个broker上面划分出多个隔离的环境（各环境下的用户、交换器以及队列等互不影响）。这样一来，AMQP客户端们在进行连接的时候，需要协商指定同一个vhost才能进行正常的往来业务。</p><h2 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h2><p>接下来，看一下消息的生产、传输、消费相关的机制。</p><h3 id="Message-acknowledgements"><a href="#Message-acknowledgements" class="headerlink" title="Message acknowledgements"></a>Message acknowledgements</h3><p>试想一下这个问题：如果消费者应用程序在处理某个消息的时候突然奔溃了，那么这条消息该何去何从？再进一步的说，AMQP消息代理要在什么时候将某条消息从队列中移除？对此，AMQP给出了两种处理办法：一是，当消息代理（broker）将一条消息发送给消费者应用程序之后就将其从队列中移除；二是，当消费者应用程序返还一条确认信息之后（类似于TCP三次握手中的ack确认）就将其从队列中移除。</p><p>第一种处理方法是自动确认的，称为automatic acknowledgement；第二种处理方法则需要由消费者进行确认操作，称为explicit acknowledgement。针对第二种处理方法，消费者在何时返回ack也是比较灵活的。比如，消费者可以在接收到消息的第一时间就返回一个ack，或者在将消息持久化到硬盘之后返回ack，又或者在消息完全处理完之后返回ack。</p><p>如果一个接收到消息的消费者在没有返回ack之前就挂掉了，那么，AMQP消息代理将会将这条消息发送给其他能匹配上的消费者。但是，若没有任何消费者能够匹配上这条消息，AMQP代理将会一直等待，直到有能匹配上的消费者出现，再将该消息投递给它。</p><h3 id="Rejecting-messages"><a href="#Rejecting-messages" class="headerlink" title="Rejecting messages"></a>Rejecting messages</h3><p>消费者应用程序在处理消息失败时，应用程序可以通知broker：消息处理失败，拒绝消息。当拒绝消息时，消费者应用程序可以要求broker丢弃或重新发送该消息。</p><h3 id="Prefetching-messages"><a href="#Prefetching-messages" class="headerlink" title="Prefetching messages"></a>Prefetching messages</h3><p>多个消费者从一个队列中消费消息时，可以指定每个消费者在返回下一个ack之前，每次发送给他们的消息数量，即预取消息的数量。这可以当做一个简单的负载均衡技术来使用，</p><p>也可以在批量生产消息的情景下提高吞吐量。</p><h3 id="Message-attributes-and-payload"><a href="#Message-attributes-and-payload" class="headerlink" title="Message attributes and payload"></a>Message attributes and payload</h3><p>AMQP模型中的消息实体各种属性，比如：</p><ul><li>content type</li><li>content encoding</li><li>routing key</li><li>delivery mode(persistent or not)</li><li>message priority</li><li>message publish timestamp</li><li>expiration period</li><li>publisher application id等。</li></ul><p>消息的属性是在消息被生产时设置的。</p><p>AMQP消息除了属性之外还有一个有效负载（可以理解为消息体，即它携带的数据），AMQP视这些负载数据为一个不透明的字节数组。并且，AMQP代理不会去窥探和改变这些负载的数据。对于这些负载的数据，你可以使用例如JSON这样的序列化格式来存储。</p><p>如果将消息属性设置为持久化，AMQP代理将会将这些持久化的消息写入磁盘，这可以保证当服务重启之后，消息不会丢失。</p><p>仍需要啰嗦的一点是：如果仅仅将一个消息生产到一个持久化的交换器，或者将这条消息路由到一个持久化的队列中去，并不能使这个消息本身变成持久化消息。消息的持久化与否主要取决于消息本身的属性设置。</p><p><strong>参考资料：</strong></p><ol><li><a href="http://dulishu.top/rabbitmq-amqp/" target="_blank" rel="noopener">http://dulishu.top/rabbitmq-amqp/</a></li><li><a href="http://www.rabbitmq.com/tutorials/amqp-concepts.html" target="_blank" rel="noopener">http://www.rabbitmq.com/tutorials/amqp-concepts.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在介绍RabbitMQ的使用之前，我们再具体阐述RabbitMQ里面的一些相关参数，有利于以后使用过程中排坑。&lt;/p&gt;
&lt;p&gt;首先，深入聊一下Queues:&lt;/p&gt;
&lt;h2 id=&quot;Queues&quot;&gt;&lt;a href=&quot;#Queues&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
      <category term="基础" scheme="http://ruanshubin.top/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="基础" scheme="http://ruanshubin.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="消息队列" scheme="http://ruanshubin.top/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Centos下安装MongoDB</title>
    <link href="http://ruanshubin.top/2019/10/24/Centos%E4%B8%8B%E5%AE%89%E8%A3%85MongoDB/"/>
    <id>http://ruanshubin.top/2019/10/24/Centos下安装MongoDB/</id>
    <published>2019-10-24T13:30:00.000Z</published>
    <updated>2019-12-25T02:44:08.314Z</updated>
    
    <content type="html"><![CDATA[<p>查看MongoDB的版本，到<a href="https://www.mongodb.com/download-center#community下，选择Community" target="_blank" rel="noopener">https://www.mongodb.com/download-center#community下，选择Community</a> Server后选择linux，之后再选择对应版本。</p><p>如果装的是Amazon的，启动mongodb时会出现Error parsing INI config file: unrecognised option ‘nohttpinterface’ 错误，所以选择RHEL版本。</p><p><img src="/2019/10/24/Centos下安装MongoDB/1.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">weget http://downloads.mongodb.org/linux/mongodb-linux-x86_64-rhel70-latest.tgz</span><br></pre></td></tr></table></figure><ul><li>解压</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zvxf mongodb-linux-x86_64-rhel70-latest.tgz</span><br></pre></td></tr></table></figure><ul><li>创建数据库目录</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /usr/local/software/mongodb/db</span><br><span class="line">mkdir -p /usr/local/software/mongodb/log</span><br></pre></td></tr></table></figure><ul><li>创建配置文件mongodb.conf</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">设置数据文件的存放目录 </span><br><span class="line">dbpath = /usr/local/software/mongodb/db </span><br><span class="line">设置日志文件的存放目录及其日志文件名 </span><br><span class="line">logpath = /usr/local/software/mongodb/log/mongodb.log </span><br><span class="line">设置端口号（默认的端口号是 27017） </span><br><span class="line">port = 27017 </span><br><span class="line">设置为以守护进程的方式运行，即在后台运行 </span><br><span class="line">fork = true </span><br><span class="line">关闭http接口，默认关闭27018端口访问 </span><br><span class="line">nohttpinterface = true</span><br></pre></td></tr></table></figure><ul><li>启动</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 命令行启动</span><br><span class="line">mongod --dbpath=/usr/local/software/mongodb/db --logpath=/usr/local/software/mongodb/log/mongodb.log &amp;</span><br><span class="line"># 配置文件启动</span><br><span class="line">./mongod --config mongodb.conf</span><br><span class="line"># 守护进程启动</span><br><span class="line">mongod --dbpath=/usr/local/software/mongodb/db --logpath=/usr/local/software/mongodb/log/mongodb.log --fork --port 27017</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;查看MongoDB的版本，到&lt;a href=&quot;https://www.mongodb.com/download-center#community下，选择Community&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.mongodb
      
    
    </summary>
    
      <category term="基础" scheme="http://ruanshubin.top/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="数据库" scheme="http://ruanshubin.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="基础" scheme="http://ruanshubin.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch入门</title>
    <link href="http://ruanshubin.top/2019/10/24/Elasticsearch%E5%85%A5%E9%97%A8/"/>
    <id>http://ruanshubin.top/2019/10/24/Elasticsearch入门/</id>
    <published>2019-10-24T13:30:00.000Z</published>
    <updated>2019-12-25T02:45:44.022Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h2><p>一个文档不仅仅包含它的数据 ，也包含元数据——有关文档的信息。 三个必须的元数据元素如下：</p><ul><li>_index</li></ul><p>文档在哪存放 。一个索引应该是因共同的特性被分组到一起的文档集合。索引名必须小写，不能以下划线开头，不能包含逗号；</p><ul><li>_type </li></ul><p>文档表示的对象类别；</p><ul><li>_id </li></ul><p>文档唯一标识。</p><p>Elasticsearch 支持 RESTFUL 风格 API，其 API 基本格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://&lt;ip&gt;:&lt;port&gt;/&lt;索引&gt;/&lt;类型&gt;/&lt;文档id&gt;</span><br></pre></td></tr></table></figure><h3 id="创建-删除索引"><a href="#创建-删除索引" class="headerlink" title="创建/删除索引"></a>创建/删除索引</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">post http://&lt;ip&gt;:&lt;port&gt;/index/type/id # 手动指定id</span><br><span class="line">或者</span><br><span class="line">post http://&lt;ip&gt;:&lt;port&gt;/index/type # es自动生成id</span><br></pre></td></tr></table></figure><p>请记住， _index 、 _type 和 _id 的组合可以唯一标识一个文档。所以，确保创建一个新文档的最简单办法是，使用索引请求的 POST 形式让 Elasticsearch 自动生成唯一 _id :</p><p>如果已经有自己的 _id ，那么我们必须告诉 Elasticsearch ，只有在相同的 _index 、 _type 和 _id 不存在时才接受我们的索引请求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">post http://&lt;ip&gt;:&lt;port&gt;/index/type/id?op_type=create</span><br><span class="line"></span><br><span class="line">post http://&lt;ip&gt;:&lt;port&gt;/index/type/id/_create</span><br></pre></td></tr></table></figure><p>如果创建新文档的请求成功执行，Elasticsearch 会返回元数据和一个 201 Created 的 HTTP 响应码。</p><p>另一方面，如果具有相同的 _index 、 _type 和 _id 的文档已经存在，Elasticsearch 将会返回 409 Conflict 响应码，以及如下的错误信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;error&quot;: &#123;</span><br><span class="line">        &quot;root_cause&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;type&quot;: &quot;version_conflict_engine_exception&quot;,</span><br><span class="line">                &quot;reason&quot;: &quot;[employee][1]: version conflict, document already exists (current version [4])&quot;,</span><br><span class="line">                &quot;index_uuid&quot;: &quot;lo-6VdTHQWKAYVuMu3djQg&quot;,</span><br><span class="line">                &quot;shard&quot;: &quot;3&quot;,</span><br><span class="line">                &quot;index&quot;: &quot;megacorp&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        &quot;type&quot;: &quot;version_conflict_engine_exception&quot;,</span><br><span class="line">        &quot;reason&quot;: &quot;[employee][1]: version conflict, document already exists (current version [4])&quot;,</span><br><span class="line">        &quot;index_uuid&quot;: &quot;lo-6VdTHQWKAYVuMu3djQg&quot;,</span><br><span class="line">        &quot;shard&quot;: &quot;3&quot;,</span><br><span class="line">        &quot;index&quot;: &quot;megacorp&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;status&quot;: 409</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除一个索引，需要使用 DELETE 请求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete http://&lt;ip&gt;:&lt;port&gt;/index/type/id</span><br></pre></td></tr></table></figure><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>put请求。</p><h3 id="查找数据"><a href="#查找数据" class="headerlink" title="查找数据"></a>查找数据</h3><ul><li>GET方式简单搜索</li></ul><p>查询指定ID的数据，使用 GET 请求。</p><p>查询id是1的雇员信息，执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[GET] http://39.106.195.92:9200/megacorp/employee/1</span><br></pre></td></tr></table></figure><p>返回结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;_index&quot;: &quot;megacorp&quot;,</span><br><span class="line">    &quot;_type&quot;: &quot;employee&quot;,</span><br><span class="line">    &quot;_id&quot;: &quot;1&quot;,</span><br><span class="line">    &quot;_version&quot;: 2,</span><br><span class="line">    &quot;found&quot;: true,    //表示文档被找到</span><br><span class="line">    &quot;_source&quot;: &#123;</span><br><span class="line">        &quot;first_name&quot;: &quot;Douglas&quot;,</span><br><span class="line">        &quot;last_name&quot;: &quot;Fir&quot;,</span><br><span class="line">        &quot;age&quot;: 35,</span><br><span class="line">        &quot;about&quot;: &quot;I like to build cabinets&quot;,</span><br><span class="line">        &quot;interests&quot;: [</span><br><span class="line">            &quot;forestry&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询文档的一部分（只查询名字）:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[GET] http://39.106.195.92:9200/megacorp/employee/1?_source=first_name,last_name</span><br></pre></td></tr></table></figure><p>查询所有信息，不指定id，使用_search,执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[GET] http://39.106.195.92:9200/megacorp/employee/_search</span><br></pre></td></tr></table></figure><p>按条件查询，仍然在请求路径中使用 _search 端点，并将查询本身赋值给参数 q= ，执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[GET] http://39.106.195.92:9200/megacorp/employee/_search?q=last_name:Smith</span><br></pre></td></tr></table></figure><p>查询文档是否存在，把GET方式换位HEAD方式就可以了，HEAD 请求没有返回体，只返回一个 HTTP 请求报头： 存在返回200，否在返回404。</p><ul><li>POST方式搜索</li></ul><p>GET条件查询的方式虽然方便，但有很大的局限性，ES提供了POST的方式查询语言–查询表达式，它支持构建更加复杂和健壮的查询。 POST方式的搜索url都相同，只是body不同:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[POST] http://39.106.195.92:9200/megacorp/employee/_search</span><br></pre></td></tr></table></figure><p>请求参数：使用 JSON 构造，并使用了一个 match 查询（属于查询类型之一,这里match不能匹配多个字段。匹配多个字段要使用multi_match ）</p><p>查找 last_name= “Smith”：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;query&quot; : &#123;</span><br><span class="line">        &quot;match&quot; : &#123;</span><br><span class="line">            &quot;last_name&quot; : &quot;Smith&quot;   //只能写一个</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>复杂的搜索</li></ul><p>使用过滤器filter搜索姓氏为 Smith 的雇员 且年龄大于30，使用的是range过滤器，其中 gt 表示_大于 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;query&quot; : &#123;</span><br><span class="line">        &quot;bool&quot;: &#123;</span><br><span class="line">            &quot;must&quot;: &#123;</span><br><span class="line">                &quot;match&quot; : &#123;</span><br><span class="line">                    &quot;last_name&quot; : &quot;smith&quot; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;filter&quot;: &#123;</span><br><span class="line">                &quot;range&quot; : &#123;</span><br><span class="line">                    &quot;age&quot; : &#123; &quot;gt&quot; : 30 &#125; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>全文搜索</li></ul><p>使用match全文搜索，Elasticsearch 默认按照相关性得分排序，即每个文档跟查询的匹配程度:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;query&quot; : &#123;</span><br><span class="line">        &quot;match&quot; : &#123;</span><br><span class="line">            &quot;about&quot; : &quot;rock climbing&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>短语搜索</li></ul><p>使用match_phrase短语搜索（准确搜索）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;query&quot; : &#123;</span><br><span class="line">        &quot;match_phrase&quot; : &#123;</span><br><span class="line">            &quot;about&quot; : &quot;rock climbing&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>高亮搜索</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;query&quot; : &#123;</span><br><span class="line">        &quot;match_phrase&quot; : &#123;</span><br><span class="line">            &quot;about&quot; : &quot;rock climbing&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;highlight&quot;: &#123;</span><br><span class="line">        &quot;fields&quot; : &#123;</span><br><span class="line">            &quot;about&quot; : &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>分析</li></ul><p>Elasticsearch 有一个功能叫聚合（aggregations），允许我们基于数据生成一些精细的分析结果。聚合与 SQL 中的 GROUP BY 类似但更强大。</p><p>挖掘出雇员中最受欢迎的兴趣爱好：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;all_interests&quot;: &#123;</span><br><span class="line">      &quot;terms&quot;: &#123; &quot;field&quot;: &quot;interests&quot; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>mget批量查询</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[POST] http://39.106.195.92:9200/_mget</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   &quot;docs&quot; : [</span><br><span class="line">      &#123;</span><br><span class="line">         &quot;_index&quot; : &quot;megacorp&quot;,</span><br><span class="line">         &quot;_type&quot; :  &quot;employee&quot;,</span><br><span class="line">         &quot;_id&quot; :    2</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         &quot;_index&quot; : &quot;website&quot;,    //没有索引的话，会报错搜索不到该索引的内容</span><br><span class="line">         &quot;_type&quot; :  &quot;employee&quot;,</span><br><span class="line">         &quot;_id&quot; :    1,</span><br><span class="line">         &quot;_source&quot;: &quot;age&quot;</span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><ul><li>文档全部更新</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[PUT] http://39.106.195.92:9200/megacorp/employee/1</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;_index&quot;: &quot;megacorp&quot;,</span><br><span class="line">    &quot;_type&quot;: &quot;employee&quot;,</span><br><span class="line">    &quot;_id&quot;: &quot;1&quot;,</span><br><span class="line">    &quot;_version&quot;: 3,</span><br><span class="line">    &quot;result&quot;: &quot;updated&quot;,</span><br><span class="line">    &quot;_shards&quot;: &#123;</span><br><span class="line">        &quot;total&quot;: 2,</span><br><span class="line">        &quot;successful&quot;: 1,</span><br><span class="line">        &quot;failed&quot;: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;created&quot;: false    //这里变成了false,表示是更新</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>文档部分更新</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[POST] http://39.106.195.92:9200/megacorp/employee/1/_update</span><br></pre></td></tr></table></figure><p>请求参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;doc&quot;: &#123;</span><br><span class="line">        &quot;age&quot;: &quot;88&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="es的并发控制"><a href="#es的并发控制" class="headerlink" title="es的并发控制"></a>es的并发控制</h2><p>在数据库领域中，有两种方法通常被用来确保并发更新时变更不会丢失：</p><ul><li>悲观并发控制 </li></ul><p>这种方法被关系型数据库广泛使用，它假定有变更冲突可能发生，因此阻塞访问资源以防止冲突。 一个典型的例子是读取一行数据之前先将其锁住，确保只有放置锁的线程能够对这行数据进行修改。</p><ul><li>乐观并发控制 </li></ul><p>Elasticsearch 中使用的这种方法假定冲突是不可能发生的，并且不会阻塞正在尝试的操作。 然而，如果源数据在读写当中被修改，更新将会失败。应用程序接下来将决定该如何解决冲突。 例如，可以重试更新、使用新的数据、或者将相关情况报告给用户。</p><p>lasticsearch 是分布式的。当文档创建、更新或删除时， 新版本的文档必须复制到集群中的其他节点。Elasticsearch 也是异步和并发的，这意味着这些复制请求被并行发送，并且到达目的地时也许 顺序是乱的 。 Elasticsearch 需要一种方法确保文档的旧版本不会覆盖新的版本。</p><p>当我们之前讨论 index ， GET 和 delete 请求时，我们指出每个文档都有一个 _version （版本）号，当文档被修改时版本号递增。 Elasticsearch 使用这个 _version 号来确保变更以正确顺序得到执行。如果旧版本的文档在新版本之后到达，它可以被简单的忽略。</p><p>我们可以利用 _version 号来确保 应用中相互冲突的变更不会导致数据丢失。我们通过指定想要修改文档的 version 号来达到这个目的。 如果该版本不是当前版本号，我们的请求将会失败。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据对象&quot;&gt;&lt;a href=&quot;#数据对象&quot; class=&quot;headerlink&quot; title=&quot;数据对象&quot;&gt;&lt;/a&gt;数据对象&lt;/h2&gt;&lt;p&gt;一个文档不仅仅包含它的数据 ，也包含元数据——有关文档的信息。 三个必须的元数据元素如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;_in
      
    
    </summary>
    
      <category term="基础" scheme="http://ruanshubin.top/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="数据库" scheme="http://ruanshubin.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="基础" scheme="http://ruanshubin.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Spark与Springboot的集成</title>
    <link href="http://ruanshubin.top/2019/10/23/Spark%E4%B8%8ESpringboot%E7%9A%84%E9%9B%86%E6%88%90/"/>
    <id>http://ruanshubin.top/2019/10/23/Spark与Springboot的集成/</id>
    <published>2019-10-23T13:30:00.000Z</published>
    <updated>2019-12-25T02:40:43.568Z</updated>
    
    <content type="html"><![CDATA[<h2 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h2><h3 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;spark-springboot&lt;/artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.ruanshubin.spark&lt;/groupId&gt;</span><br><span class="line">        &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;spark-demo&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">            &lt;exclusions&gt;</span><br><span class="line">                &lt;exclusion&gt;</span><br><span class="line">                    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                    &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;</span><br><span class="line">                &lt;/exclusion&gt;</span><br><span class="line">            &lt;/exclusions&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--ELK系统--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;net.logstash.logback&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;logstash-logback-encoder&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.3&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;log4j-over-slf4j&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;logback-core&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span><br><span class="line">            &lt;exclusions&gt;</span><br><span class="line">                &lt;exclusion&gt;</span><br><span class="line">                    &lt;artifactId&gt;log4j-to-slf4j&lt;/artifactId&gt;</span><br><span class="line">                    &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;</span><br><span class="line">                &lt;/exclusion&gt;</span><br><span class="line">            &lt;/exclusions&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--kafka--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--ElasticSearch--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--服务监控--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.postgresql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;postgresql&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--spark--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spark-core_2.11&lt;/artifactId&gt;</span><br><span class="line">            &lt;exclusions&gt;</span><br><span class="line">                &lt;exclusion&gt;</span><br><span class="line">                    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">                    &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</span><br><span class="line">                &lt;/exclusion&gt;</span><br><span class="line">            &lt;/exclusions&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spark-sql_2.11&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spark-catalyst_2.11&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--test--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;id&gt;copy-resources&lt;/id&gt;</span><br><span class="line">                        &lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;copy-resources&lt;/goal&gt;</span><br><span class="line">                        &lt;/goals&gt;</span><br><span class="line">                        &lt;configuration&gt;</span><br><span class="line">                            &lt;outputDirectory&gt;$&#123;project.build.directory&#125;/conf&lt;/outputDirectory&gt;</span><br><span class="line">                            &lt;resources&gt;</span><br><span class="line">                                &lt;resource&gt;</span><br><span class="line">                                    &lt;directory&gt;src/main/resources&lt;/directory&gt;</span><br><span class="line">                                    &lt;filtering&gt;false&lt;/filtering&gt;</span><br><span class="line">                                &lt;/resource&gt;</span><br><span class="line">                            &lt;/resources&gt;</span><br><span class="line">                        &lt;/configuration&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">                &lt;/executions&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;id&gt;copy&lt;/id&gt;</span><br><span class="line">                        &lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;copy-dependencies&lt;/goal&gt;</span><br><span class="line">                        &lt;/goals&gt;</span><br><span class="line">                        &lt;configuration&gt;</span><br><span class="line">                            &lt;includeScope&gt;runtime&lt;/includeScope&gt;</span><br><span class="line">                            &lt;excludeScope&gt;provided,test&lt;/excludeScope&gt;</span><br><span class="line">                            &lt;excludeArtifactIds&gt;junit,dbunit,mockito-all&lt;/excludeArtifactIds&gt;</span><br><span class="line">                            &lt;excludeTransitive&gt;false&lt;/excludeTransitive&gt;</span><br><span class="line">                            &lt;outputDirectory&gt;</span><br><span class="line">                                $&#123;project.build.directory&#125;/lib</span><br><span class="line">                            &lt;/outputDirectory&gt;</span><br><span class="line">                        &lt;/configuration&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">                &lt;/executions&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;dependencies&gt;</span><br><span class="line">                    &lt;dependency&gt;</span><br><span class="line">                        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                        &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">                        &lt;version&gt;$&#123;spring.boot.version&#125;&lt;/version&gt;</span><br><span class="line">                    &lt;/dependency&gt;</span><br><span class="line">                &lt;/dependencies&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;finalName&gt;tcd-data-manager-1.0-jar-with-dependencies&lt;/finalName&gt;</span><br><span class="line">                    &lt;keepDependenciesWithProvidedScope&gt;true&lt;/keepDependenciesWithProvidedScope&gt;</span><br><span class="line">                    &lt;createDependencyReducedPom&gt;true&lt;/createDependencyReducedPom&gt;</span><br><span class="line">                    &lt;filters&gt;</span><br><span class="line">                        &lt;filter&gt;</span><br><span class="line">                            &lt;artifact&gt;*:*&lt;/artifact&gt;</span><br><span class="line">                            &lt;excludes&gt;</span><br><span class="line">                                &lt;exclude&gt;META-INF/*.SF&lt;/exclude&gt;</span><br><span class="line">                                &lt;exclude&gt;META-INF/*.DSA&lt;/exclude&gt;</span><br><span class="line">                                &lt;exclude&gt;META-INF/*.RSA&lt;/exclude&gt;</span><br><span class="line">                            &lt;/excludes&gt;</span><br><span class="line">                        &lt;/filter&gt;</span><br><span class="line">                    &lt;/filters&gt;</span><br><span class="line">                    &lt;artifactSet&gt;</span><br><span class="line">                        &lt;excludes&gt;</span><br><span class="line">                            &lt;exclude&gt;org.apache.spark:*&lt;/exclude&gt;</span><br><span class="line">                        &lt;/excludes&gt;</span><br><span class="line">                    &lt;/artifactSet&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;shade&lt;/goal&gt;</span><br><span class="line">                        &lt;/goals&gt;</span><br><span class="line">                        &lt;configuration&gt;</span><br><span class="line">                            &lt;transformers&gt;</span><br><span class="line">                                &lt;transformer implementation=&quot;org.springframework.boot.maven.PropertiesMergingResourceTransformer&quot;&gt;</span><br><span class="line">                                    &lt;resource&gt;META-INF/spring.factories&lt;/resource&gt;</span><br><span class="line">                                &lt;/transformer&gt;</span><br><span class="line">                                &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.AppendingTransformer&quot;&gt;</span><br><span class="line">                                    &lt;resource&gt;META-INF/spring.handlers&lt;/resource&gt;</span><br><span class="line">                                &lt;/transformer&gt;</span><br><span class="line">                                &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.AppendingTransformer&quot;&gt;</span><br><span class="line">                                    &lt;resource&gt;META-INF/spring.schemas&lt;/resource&gt;</span><br><span class="line">                                &lt;/transformer&gt;</span><br><span class="line">                                &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.AppendingTransformer&quot;&gt;</span><br><span class="line">                                    &lt;resource&gt;META-INF/spring.tooling&lt;/resource&gt;</span><br><span class="line">                                &lt;/transformer&gt;</span><br><span class="line">                                &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ServicesResourceTransformer&quot;/&gt;</span><br><span class="line">                                &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&gt;</span><br><span class="line">                                    &lt;mainClass&gt;xxx.xxx.xxx.Application&lt;/mainClass&gt;</span><br><span class="line">                                &lt;/transformer&gt;</span><br><span class="line">                            &lt;/transformers&gt;</span><br><span class="line">                        &lt;/configuration&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">                &lt;/executions&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;appendAssemblyId&gt;false&lt;/appendAssemblyId&gt;</span><br><span class="line">                    &lt;descriptors&gt;</span><br><span class="line">                        &lt;descriptor&gt;src/assembly/assembly.xml&lt;/descriptor&gt;</span><br><span class="line">                    &lt;/descriptors&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;id&gt;make-assembly&lt;/id&gt;</span><br><span class="line">                        &lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;single&lt;/goal&gt;</span><br><span class="line">                        &lt;/goals&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">                &lt;/executions&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><h3 id="assembly-xml"><a href="#assembly-xml" class="headerlink" title="assembly.xml"></a>assembly.xml</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;assembly xmlns=&quot;http://maven.apache.org/ASSEMBLY/2.0.0&quot;</span><br><span class="line">          xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">          xsi:schemaLocation=&quot;http://maven.apache.org/ASSEMBLY/2.0.0 http://maven.apache.org/xsd/assembly-2.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;id&gt;build&lt;/id&gt;</span><br><span class="line">    &lt;formats&gt;</span><br><span class="line">        &lt;format&gt;tar.gz&lt;/format&gt;</span><br><span class="line">    &lt;/formats&gt;</span><br><span class="line">    &lt;includeBaseDirectory&gt;false&lt;/includeBaseDirectory&gt;</span><br><span class="line">    &lt;fileSets&gt;</span><br><span class="line">        &lt;fileSet&gt;</span><br><span class="line">            &lt;directory&gt;target&lt;/directory&gt;</span><br><span class="line">            &lt;includes&gt;</span><br><span class="line">                &lt;include&gt;*dependencies.jar&lt;/include&gt;</span><br><span class="line">                &lt;include&gt;/conf/**&lt;/include&gt;</span><br><span class="line">            &lt;/includes&gt;</span><br><span class="line">            &lt;outputDirectory&gt;/&lt;/outputDirectory&gt;</span><br><span class="line">            &lt;directoryMode&gt;0755&lt;/directoryMode&gt;</span><br><span class="line">        &lt;/fileSet&gt;</span><br><span class="line">    &lt;/fileSets&gt;</span><br><span class="line">&lt;/assembly&gt;</span><br></pre></td></tr></table></figure><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><h3 id="自定义Spark的依赖包"><a href="#自定义Spark的依赖包" class="headerlink" title="自定义Spark的依赖包"></a>自定义Spark的依赖包</h3><blockquote><p>启动Spark任务时，在没有配置spark.yarn.archive或者spark.yarn.jars时， 会看到不停地上传jar，非常耗时；使用spark.yarn.archive可以大大地减少任务的启动时间；同时，也可以在不污染原有spark环境的前提下，解决包冲突的问题。整个处理过程如下:</p></blockquote><ul><li>在本地创建zip文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hzlishuming@hadoop691:~/env/spark$ cd jars/</span><br><span class="line">hzlishuming@hadoop691:~/env/spark$ zip spark2.1.1-hadoop2.7.3.zip ./*</span><br></pre></td></tr></table></figure><ul><li>上传至HDFS并更改权限</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hzlishuming@hadoop691:~/env/spark$ /usr/ndp/current/hdfs_client/bin/hdfs dfs -mkdir /tmp/spark-archive</span><br><span class="line">hzlishuming@hadoop691:~/env/spark$ /usr/ndp/current/hdfs_client/bin/hdfs dfs -put ./spark2.1.1-hadoop2.7.3.zip /tmp/spark-archive</span><br><span class="line">hzlishuming@hadoop691:~/env/spark$ /usr/ndp/current/hdfs_client/bin/hdfs dfs -chmod 775 /tmp/spark-archive/spark2.1.1-hadoop2.7.3.zip</span><br></pre></td></tr></table></figure><ul><li>配置spark-defaut.conf</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spark.yarn.archive hdfs:///tmp/spark-archive/spark2.1.1-hadoop2.7.3.zip</span><br></pre></td></tr></table></figure><p>也可以在提交任务的时候指定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">./bin/spark-submit \</span><br><span class="line">--class xxx.xxx.xxx.Application \</span><br><span class="line">--name XXXApplication \</span><br><span class="line">--master yarn \</span><br><span class="line">--deploy-mode cluster \</span><br><span class="line">--queue root.root \</span><br><span class="line">--driver-cores 1 \</span><br><span class="line">--driver-memory 2g \</span><br><span class="line">--executor-cores 4 \</span><br><span class="line">--executor-memory 2g \</span><br><span class="line">--num-executors 4 \</span><br><span class="line">--driver-java-options &apos;-XX:MaxDirectMemorySize=128M -XX:NewRatio=1 -XX:SurvivorRatio=8 -XX:TargetSurvivorRatio=90 -XX:MaxTenuringThreshold=8 -XX:+UseConcMarkSweepGC -XX:ConcGCThreads=4 -XX:ParallelGCThreads=4 -XX:+CMSScavengeBeforeRemark -XX:PretenureSizeThreshold=64m -XX:+UseCMSInitiatingOccupancyOnly -XX:CMSInitiatingOccupancyFraction=50 -XX:CMSMaxAbortablePrecleanTime=6000 -XX:+CMSParallelRemarkEnabled -XX:+ParallelRefProcEnabled -XX:-OmitStackTraceInFastThrow&apos; \</span><br><span class="line">--files hdfs://&#123;ip&#125;:&#123;port&#125;/xxx/xxx/xxx/bootstrap.yml,hdfs://&#123;ip&#125;:&#123;port&#125;/xxx/xxx/xxx/logback.xml \</span><br><span class="line">--conf spark.yarn.driver.memoryOverhead=1024  \</span><br><span class="line">--conf spark.yarn.executor.memoryOverhead=384  \</span><br><span class="line">--conf spark.yarn.archive=hdfs://&#123;ip&#125;:&#123;port&#125;/spark/yarn/spark2.4.0-hadoop2.6.0.zip \</span><br><span class="line">hdfs://&#123;ip&#125;:&#123;port&#125;/apps/xxx-jar-with-dependencies.jar</span><br></pre></td></tr></table></figure><h3 id="冲突包解决"><a href="#冲突包解决" class="headerlink" title="冲突包解决"></a>冲突包解决</h3><p>当Spark的jars目录下的相关jar包与应用中的依赖jar包冲突时，程序会报类找不到的Error。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># spark中需要替换的jar包</span><br><span class="line">snakeyaml-1.15.jar --&gt; snakeyaml-1.19.jar</span><br><span class="line">validation-api-1.1.0.Final.jar --&gt; validation-api-2.0.1.Final.jar</span><br><span class="line">gson-2.2.4.jar --&gt; gson-2.8.5.jar</span><br><span class="line"># 日志相关</span><br><span class="line">apache-log4j-extras-1.2.17.jar --&gt; log4j-over-slf4j-1.7.23.jar</span><br><span class="line">commons-logging-1.1.3.jar --&gt; logback-access-1.2.1.jar</span><br><span class="line">log4j-1.2.17.jar --&gt; logback-classic-1.2.1.jar</span><br><span class="line">slf4j-log4j12-1.7.16.jar --&gt; logback-core-1.2.1.jar</span><br><span class="line"># Swagger相关</span><br><span class="line">guava-14.0.1.jar --&gt; guava-20.0.jar</span><br><span class="line"></span><br><span class="line"># hadoop需要替换的包(不一定需要)</span><br><span class="line">rm -rf /usr/lib/LOCALCLUSTER/hadoop/share/hadoop/common/lib/slf4j-log4j12-1.7.5.jar</span><br><span class="line"></span><br><span class="line">Swagger上yarn的话，需要将SwaggerHeaderFilter的配置删除掉，否则拉取不到配置。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;项目配置&quot;&gt;&lt;a href=&quot;#项目配置&quot; class=&quot;headerlink&quot; title=&quot;项目配置&quot;&gt;&lt;/a&gt;项目配置&lt;/h2&gt;&lt;h3 id=&quot;pom-xml&quot;&gt;&lt;a href=&quot;#pom-xml&quot; class=&quot;headerlink&quot; title=&quot;pom
      
    
    </summary>
    
      <category term="大数据" scheme="http://ruanshubin.top/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="大数据" scheme="http://ruanshubin.top/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Spark" scheme="http://ruanshubin.top/tags/Spark/"/>
    
  </entry>
  
</feed>
